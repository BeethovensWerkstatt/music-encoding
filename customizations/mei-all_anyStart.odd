<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>MEI Next Release (2015?) Testing</title>
        <respStmt>
          <resp>Authored by</resp>
          <name xml:id="PR">Perry Roland</name>
        </respStmt>
      </titleStmt>
      <publicationStmt>
        <p/>
      </publicationStmt>
      <sourceDesc>
        <p/>
      </sourceDesc>
    </fileDesc>
    <revisionDesc>
      <change n="1" when="2014-12-04" who="#PR">
        <desc>Creation of the initial ODD.</desc>
      </change>
    </revisionDesc>
  </teiHeader>
  <text>
    <front>
      <divGen type="toc"/>
    </front>
    <body>
      <!-- This file is a superset of mei-all. It contains changes to both mei-all_anyStart and mei-all.
        This file permits the validation of MEI fragments, whereas mei-all presumes a smaller set of
        possible start elements: mei, meiHead, meiCorpus, and music. Some elements (line, marker, symbol, 
        and title) explicitly reference the element in the MEI namespace, since SVG also has elements 
        with these names. -->
      <schemaSpec ident="mei"
        start="abbr accessRestrict accid acqSource actor add address addrLine altId anchoredText annot app 
        appInfo application arpeg arranger artic audience author availability avFile back barLine barre beam 
        beamSpan beatRpt bend bibl biblList biblScope body breath bTrem byline caption captureMode carrierForm 
        castGrp castItem castList cc chan change changeDesc chanPr choice chord chordDef chordMember 
        chordTable classCode classification clef clefGrp clip componentGrp composer condition contentItem 
        contents context corpName corr correction creation cue curve custos damage date del depth dimensions
        dir distributor div dot dynam edition editionStmt editor editorialDecl encodingDesc ending  
        event eventList exhibHist expan expansion expression expressionList extent f facsimile fb fermata fig 
        figDesc fileChar fileDesc fing fingGrp fingerprint flags front fTrem funder fw gap genre geogName gliss 
        graphic group grpSym hairpin halfmRpt hand handList handShift harm harpPedal head height hex history 
        identifier imprint incip incipCode incipText ineume inscription instrDef instrGrp perfRes perfResList 
        interpretation item itemList key keyAccid keySig l label language langUsage  layer layerDef lb lem lg 
        li librettist ligature mei_line list lyricist lyrics mei_marker mdiv measure mei meiCorpus meiHead 
        mensur mensuration metaText meter meterSig meterSigGrp midi mordent mRest mRpt mRpt2 mSpace multiRest 
        multiRpt music name normalization note notehead noteOff noteOn notesStmt num octave orig ossia 
        otherChar p pad part parts pb pedal perfMedium performance periodName persName pgDesc pgFoot pgFoot2 
        pgHead pgHead2 phrase physDesc physLoc physMedium plateNum playingSpeed port price prog projectDesc 
        proport provenance ptr publisher pubPlace pubStmt quote rdg recipient recording ref reg reh relatedItem 
        relation relationList rend repository resp respStmt rest restore revisionDesc role roleDesc samplingDecl 
        sb score scoreDef scoreFormat section segmentation seqNum series seriesStmt sic slur soundChan source 
        sourceDesc space specRepro sponsor stack staff staffDef staffGrp stdVals stem styleName subst supplied 
        surface syl syllable mei_symbol symbolDef symbolTable sysReq table tapeConfig td tempo term termList 
        textLang th tie timeline mei_title titlePage titleStmt tr trackConfig treatHist treatSched trill trkName 
        tuplet tupletSpan turn unclear uneume unpub useRestrict vel verse watermark when width work workDesc zone"
        prefix="mei_" ns="http://www.music-encoding.org/ns/mei">

        <moduleRef key="MEI"/>
        <moduleRef key="MEI.shared"/>
        <moduleRef key="MEI.header"/>
        <moduleRef key="MEI.cmn"/>
        <moduleRef key="MEI.mensural"/>
        <moduleRef key="MEI.neumes"/>
        <moduleRef key="MEI.analysis"/>
        <moduleRef key="MEI.cmnOrnaments"/>
        <moduleRef key="MEI.corpus"/>
        <moduleRef key="MEI.critapp"/>
        <moduleRef key="MEI.edittrans"/>
        <!-- Support SMuFL, issue #213 -->
        <!-- Add MEI.externalsymbols module -->
        <moduleRef key="MEI.externalsymbols"/>
        <moduleRef key="MEI.facsimile"/>
        <moduleRef key="MEI.figtable"/>
        <!-- Add a generic fingering element, issue #224 -->
        <!-- Add new module for fingerings -->
        <moduleRef key="MEI.fingering"/>
        <moduleRef key="MEI.frbr"/>
        <moduleRef key="MEI.harmony"/>
        <!-- Revise timeline and performance, issue #94 -->
        <!-- Remove MEI.linkalign module -->
        <!--<moduleRef key="MEI.linkalign"/>-->
        <moduleRef key="MEI.lyrics"/>
        <moduleRef key="MEI.midi"/>
        <moduleRef key="MEI.namesdates"/>
        <moduleRef key="MEI.performance"/>
        <moduleRef key="MEI.ptrref"/>
        <moduleRef key="MEI.tablature"/>
        <moduleRef key="MEI.text"/>
        <moduleRef key="MEI.usersymbols"/>

        <!-- =============================== RESOLVE ISSUES =============================== -->

        <!-- Include SVG, issue #53 -->
        <moduleRef url="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/svg11.rng">
          <content>
            <rng:define name="mei_model.graphicLike" combine="choice">
              <rng:ref name="svg"/>
            </rng:define>
          </content>
        </moduleRef>
        <!-- Revise content model of midi element to explicitly reference marker in the MEI namespace.
          This is necessary because SVG has a marker element. -->
        <elementSpec ident="midi" module="MEI.midi" mode="replace">
          <desc>Container for elements that contain information useful when generating MIDI
            output.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.midi.log"/>
            <memberOf key="att.midi.vis"/>
            <memberOf key="att.midi.ges"/>
            <memberOf key="att.midi.anl"/>
            <memberOf key="model.midiLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="cc"/>
                <rng:ref name="chan"/>
                <rng:ref name="chanPr"/>
                <rng:ref name="cue"/>
                <rng:ref name="hex"/>
                <rng:ref name="mei_marker"/>
                <rng:ref name="metaText"/>
                <rng:ref name="noteOff"/>
                <rng:ref name="noteOn"/>
                <rng:ref name="port"/>
                <rng:ref name="prog"/>
                <rng:ref name="seqNum"/>
                <rng:ref name="trkName"/>
                <rng:ref name="vel"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <att>label</att> attribute can be used to differentiate between multiple MIDI
              data streams, e.g. quantized/unquantized, straight/swing, ornamented/as notated,
              etc.</p>
          </remarks>
        </elementSpec>

        <!-- Add <extent> in <work> to accommodate intended duration of work, issue #45 -->
        <elementSpec ident="work" module="MEI.header" mode="replace">
          <desc>Provides a detailed description of a work, specifically its history, language use,
            and high-level musical attributes: key, tempo, meter, and medium of performance.</desc>
          <classes>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="model.workLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.identifierLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="titleStmt"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="model.workIdent"/>
            </rng:zeroOrMore>
            <!-- Allow otherChar to be repeatable -->
            <rng:zeroOrMore>
              <rng:ref name="otherChar"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="history"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="langUsage"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="perfMedium"/>
            </rng:optional>
            <!-- Add extent to capture intended duration of work -->
            <rng:optional>
              <rng:ref name="extent"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="audience"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="contents"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="context"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="biblList"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="notesStmt"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="classification"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="expressionList"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="componentGrp"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="relationList"/>
            </rng:optional>
          </content>
          <remarks>
            <p>In this context,the extent element captures the intended duration of the work.</p>
          </remarks>
        </elementSpec>
        <!-- Add @duration to hold a W3C duration and make extent member of att.quantity -->
        <elementSpec ident="extent" module="MEI.shared" mode="replace">
          <desc>Used to express quantity or size in terms other than physical dimensions, such as
            number of pages, number of records in file, number of bytes, performance duration for
            music, audio recordings and visual projections, etc.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.measurement"/>
            <memberOf key="att.quantity"/>
            <memberOf key="model.biblPart"/>
            <memberOf key="model.physDescPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="quantity_needs_unit" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:extent[@quantity]">
                <sch:assert test="@unit" role="warning">When quantity attribute is present, usually
                  the unit attribute is also present.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="duration_excludes_quantity_and_unit" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:extent[@duration]">
                <sch:assert test="not(@quantity) and not(@unit)">When duration attribute is present,
                  quantity and unit attributes are not allowed.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="duration" usage="opt">
              <desc>Holds a W3C duration value.</desc>
              <datatype>
                <rng:data type="duration"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>Use the <gi scheme="MEI">dimensions</gi> element when it is necessary to specify the
                <hi rend="bold">physical</hi> size of materials being described, for example, height
              and width. The @unit attribute can be used to record the unit of measure in which the
              the extent element's content (or its equivalent, as specified in the @quantity
              attribute) is provided.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Text Encoding Initiative (TEI) and
              Encoded Archival Description (EAD) standards.</p>
          </remarks>
        </elementSpec>
        <!-- Extend @unit values to include "byte", "character", and "record" -->
        <classSpec ident="att.measurement" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that record the unit of measurement in which a value is expressed.</desc>
          <attList>
            <attDef ident="unit" usage="opt">
              <desc>Indicates the unit of measurement.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <valList type="semi">
                <valItem ident="byte">
                  <desc>Byte.</desc>
                </valItem>
                <valItem ident="char">
                  <desc>Character.</desc>
                </valItem>
                <valItem ident="cm">
                  <desc>Centimeter.</desc>
                </valItem>
                <valItem ident="in">
                  <desc>Inch.</desc>
                </valItem>
                <valItem ident="issue">
                  <desc>Serial issue.</desc>
                </valItem>
                <valItem ident="mm">
                  <desc>Millimeter.</desc>
                </valItem>
                <valItem ident="page">
                  <desc>Page.</desc>
                </valItem>
                <valItem ident="pc">
                  <desc>Pica.</desc>
                </valItem>
                <valItem ident="pt">
                  <desc>Point.</desc>
                </valItem>
                <valItem ident="px">
                  <desc>Pixel.</desc>
                </valItem>
                <valItem ident="record">
                  <desc>Record.</desc>
                </valItem>
                <valItem ident="vol">
                  <desc>Serial volume.</desc>
                </valItem>
                <valItem ident="vu">
                  <desc>MEI virtual unit.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise timeline and performance, issue #94 -->
        <!-- Create new datatype for begin/end and interval types -->
        <macroSpec ident="data.BETYPE" module="MEI.shared" type="dt" mode="add">
          <desc>Datatypes for values in begin, end, abstype and inttype attributes.</desc>
          <content>
            <valList type="closed">
              <valItem ident="byte">
                <desc>Bytes.</desc>
              </valItem>
              <valItem ident="smil">
                <desc>Synchronized Multimedia Integration Language.</desc>
              </valItem>
              <valItem ident="midi">
                <desc>MIDI clicks.</desc>
              </valItem>
              <valItem ident="mmc">
                <desc>MIDI machine code.</desc>
              </valItem>
              <valItem ident="mtc">
                <desc>MIDI time code.</desc>
              </valItem>
              <valItem ident="smpte-25">
                <desc>SMPTE 25 EBU.</desc>
              </valItem>
              <valItem ident="smpte-24">
                <desc>SMPTE 24 Film Sync.</desc>
              </valItem>
              <valItem ident="smpte-df30">
                <desc>SMPTE 30 Drop.</desc>
              </valItem>
              <valItem ident="smpte-ndf30">
                <desc>SMPTE 30 Non-Drop.</desc>
              </valItem>
              <valItem ident="smpte-df29.97">
                <desc>SMPTE 29.97 Drop.</desc>
              </valItem>
              <valItem ident="smpte-ndf29.97">
                <desc>SMPTE 29.97 Non-Drop.</desc>
              </valItem>
              <valItem ident="tcf">
                <desc>AES Time-code character format.</desc>
              </valItem>
              <valItem ident="time">
                <desc>ISO 24-hour time format: HH:MM:SS.ss.</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>
        <!-- Revise att.mediabounds to refer to new BETYPEs -->
        <classSpec ident="att.mediabounds" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that establish the boundaries of a media object.</desc>
          <attList>
            <attDef ident="begin" usage="opt">
              <desc>Specifies a point where the relevant content begins. A numerical value must be
                less and a time value must be earlier than that given by the end attribute.</desc>
              <datatype>
                <rng:text/>
              </datatype>
            </attDef>
            <attDef ident="end" usage="opt">
              <desc>Specifies a point where the relevant content ends. If not specified, the end of
                the content is assumed to be the end point. A numerical value must be greater and a
                time value must be later than that given by the begin attribute.</desc>
              <datatype>
                <rng:text/>
              </datatype>
            </attDef>
            <attDef ident="betype" usage="opt">
              <desc>Type of values used in the begin/end attributes. The begin and end attributes
                can only be interpreted meaningfully in conjunction with this attribute.</desc>
              <datatype>
                <rng:ref name="data.BETYPE"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Remove reference to model.alignLike in music element -->
        <elementSpec ident="music" module="MEI.shared" mode="replace">
          <desc>Contains a single musical text of any kind, whether unitary or composite, for
            example, an etude, opera, song cycle, symphony, or anthology of piano solos.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.meiversion"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.resourceLike"/>
            </rng:zeroOrMore>
            <rng:ref name="macro.musicPart"/>
          </content>
        </elementSpec>
        <!-- Remove reference to model.alignLike in scoreDef element -->
        <elementSpec ident="scoreDef" module="MEI.shared" mode="replace">
          <desc>(score definition) – Container for score meta-information.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.scoreDef.log"/>
            <memberOf key="att.scoreDef.vis"/>
            <memberOf key="att.scoreDef.ges"/>
            <memberOf key="att.scoreDef.anl"/>
            <memberOf key="model.scoreDefLike"/>
          </classes>
          <content>
            <rng:optional>
              <rng:ref name="model.chordTableLike"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="model.symbolTableLike"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="model.keySigLike"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="model.meterSigLike"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgHead"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgHead2"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgFoot"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgFoot2"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="instrGrp"/>
            </rng:optional>
            <rng:choice>
              <rng:optional>
                <rng:ref name="model.staffGrpLike"/>
              </rng:optional>
            </rng:choice>
            <!-- Facilitate overlapping staff groups, issue #178 -->
            <!-- Allow grpSym in scoreDef -->
            <rng:zeroOrMore>
              <rng:ref name="grpSym"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <!-- Re-create att.alignment in MEI.performance (now that MEI.linkalign has been removed) -->
        <classSpec ident="att.alignment" module="MEI.performance" type="atts" mode="add">
          <desc>Temporal alignment attributes.</desc>
          <constraintSpec ident="check_whenTarget" scheme="isoschematron">
            <constraint>
              <sch:rule context="@when">
                <sch:assert role="warning" test="not(normalize-space(.) eq '')">@when attribute has
                  no content.</sch:assert>
                <sch:assert role="warning"
                  test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
                  >The value in @when must correspond to the @xml:id attribute of a when
                  element.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="when" usage="opt">
              <desc>Indicates the point of occurrence of this feature along a time line. Its value
                must be the ID of a <gi scheme="MEI">when</gi> element elsewhere in the
                document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Re-create when element in MEI.performance (now that MEI.linkalign has been removed) -->
        <elementSpec ident="when" module="MEI.performance" mode="add">
          <desc>Indicates a point in time either absolutely (using the absolute attribute), or
            relative to another when element (using the interval and since attributes).</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.datapointing"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <constraintSpec ident="check_when_interval" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:when[@interval]">
                <sch:assert test="@since">@since must be present when @interval is
                  used.</sch:assert>
                <sch:assert
                  test="every $i in tokenize(@since, '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
                  >The value in @since must correspond to the @xml:id attribute of a when
                  element.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="absolute" usage="opt">
              <desc>Provides an absolute value for the time point.</desc>
              <datatype>
                <rng:text/>
              </datatype>
            </attDef>
            <attDef ident="interval" usage="opt">
              <desc>Specifies the time interval between this time point and the one designated by
                the since attribute. This attribute can only be interpreted meaningfully in
                conjunction with the inttype attribute.</desc>
              <datatype>
                <rng:data type="decimal">
                  <rng:param name="minInclusive">1</rng:param>
                </rng:data>
              </datatype>
            </attDef>
            <attDef ident="abstype" usage="opt">
              <desc>Specifies the kind of values used in the absolute attribute.</desc>
              <datatype>
                <rng:ref name="data.BETYPE"/>
              </datatype>
            </attDef>
            <attDef ident="inttype" usage="opt">
              <desc>Specifies the kind of values used in the interval attribute.</desc>
              <datatype>
                <rng:ref name="data.BETYPE"/>
              </datatype>
            </attDef>
            <!-- Enforce constraints on attribute targets, issue #226 -->
            <attDef ident="since" usage="opt">
              <desc>Identifies the reference point for determining the time of the current when
                element, which is obtained by adding the interval to the time of the reference
                point. The value should be the ID of another when element within the same parent
                element. If the since attribute is omitted and the absolute attribute is not
                specified, then the reference point is understood to be the immediately preceding
                when element.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_sinceTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@since">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@since attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
                      >The value in @since must correspond to the @xml:id attribute of a when
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>data</att> attribute may be used to reference one or more features that
              occur at this point in time.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <!-- Allow <when> as child of recording; make recording a member of att.datapointing -->
        <elementSpec ident="recording" module="MEI.performance" mode="replace">
          <desc>A recorded performance.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.mediabounds"/>
            <memberOf key="att.startid"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="avFile"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="when"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="clip"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <att>startid</att> attribute may be used to hold a reference to the first feature
              occurring in this performance. This element is analogous to the <gi scheme="MEI"
                >surface</gi> element in the facsimile module.</p>
          </remarks>
        </elementSpec>
        <!-- Allow <when> as child of clip; make clip a member of att.datapointing -->
        <elementSpec ident="clip" module="MEI.performance" mode="replace">
          <desc>Defines a time segment of interest within a recording or within a digital audio or
            video file.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.mediabounds"/>
            <memberOf key="att.startid"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="avFile"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="when"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is analogous to the <gi scheme="MEI">zone</gi> element in the facsimile
              module.</p>
          </remarks>
        </elementSpec>

        <!-- Reserve @rend and @style for CSS-like renditional information, issue #144 -->
        <!-- THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <classSpec ident="att.barLine.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.meterconformance.bar"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Records the appearance and usually the function of the bar line.</desc>
              <datatype>
                <rng:ref name="data.BARRENDITION"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.beamrend" module="MEI.cmn" type="atts" mode="replace">
          <desc>Attributes that record the visual rendition of beams.</desc>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Captures whether a beam is "feathered" and in which direction.</desc>
              <valList type="closed">
                <valItem ident="acc">
                  <desc>(accelerando) indicates that the secondary beams get progressively closer
                    together toward the end of the beam.</desc>
                </valItem>
                <valItem ident="mixed">
                  <desc>(mixed acc and rit) for beams that are "feathered" in both
                    directions.</desc>
                </valItem>
                <valItem ident="rit">
                  <desc>(ritardando) means that the secondary beams become progressively more
                    distant toward the end of the beam.</desc>
                </valItem>
                <valItem ident="norm">
                  <desc>(normal) indicates that the secondary beams are equidistant along the course
                    of the beam.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="slope" usage="opt">
              <desc>Records the slope of the beam.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.beatRpt.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.expandable"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <!-- Make member of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="form" usage="req">
              <desc>Indicates the number of slashes required to render the appropriate beat repeat
                symbol. When a single beat is repeated, consisting of a single note or chord, it is
                indicated by a single thick, slanting slash; therefore, the value '1' should be
                used. The following values should be used when the beat is divided into even notes:
                4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the beat is comprised of
                mixed duration values, the symbol is always rendered as 2 slashes and 2 dots.</desc>
              <datatype>
                <rng:ref name="data.BEATRPT.REND"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.chord.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes for chord. The slur, slur.dir, slur.rend, tie, tie.dir, and
            tie.rend attributes here are syntactic sugar for these attributes on each of the chord's
            individual notes. The values here apply to all the notes in the chord. If some notes are
            slurred or tied while others aren't, then the individual note attributes must be
            used.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Make att.chord.vis a member of att.enclosingchars -->
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.stems"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visibility"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.visualoffset.to"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.chord.vis.cmn"/>
          </classes>
          <attList>
            <attDef ident="cluster" usage="opt">
              <desc>Indicates a single, alternative note head should be displayed instead of
                individual note heads. The highest and lowest notes of the chord usually indicate
                the upper and lower boundaries of the cluster note head.</desc>
              <datatype>
                <rng:ref name="data.CLUSTER"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.meterSig.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <!-- Make member of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Contains an indication of how the meter signature should be rendered.</desc>
              <valList type="closed">
                <valItem ident="num">
                  <desc>Show only the number of beats.</desc>
                </valItem>
                <valItem ident="denomsym">
                  <desc>The lower number in the meter signature is replaced by a note symbol.</desc>
                </valItem>
                <valItem ident="norm">
                  <desc>Meter signature rendered using traditional numeric values.</desc>
                </valItem>
                <valItem ident="invis">
                  <desc>Meter signature not rendered.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.note.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.coloration"/>
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.noteheads"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.stems"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visibility"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.visualoffset.to"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.note.vis.cmn"/>
          </classes>
        </classSpec>
        <classSpec ident="att.proport.vis" module="MEI.mensural" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.rest.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.rest.vis.cmn"/>
            <memberOf key="att.rest.vis.mensural"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.staffloc.pitched"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.sb.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <!-- Make member of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Indicates whether hash marks should be rendered between systems. See Read, p.
                436, ex. 26-3.</desc>
              <valList type="closed">
                <valItem ident="hash">
                  <desc>Display hash marks between systems.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.pedal.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes. The place attribute captures the placement of the pedal
            marking with respect to the staff with which it is associated. Modern publishing
            standards require the place to be 'below'; however, for transcriptions of manuscript
            works, this attribute class allows the full range of values.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.linerend"/>
            <memberOf key="att.placement"/>
            <!-- Make member of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Determines whether piano pedal marks should be rendered as lines or as
                terms.</desc>
              <valList type="closed">
                <valItem ident="line">
                  <desc>Continuous line with start and end positions rendered by vertical bars and
                    bounces shown by upward-pointing "blips".</desc>
                </valItem>
                <valItem ident="pedstar">
                  <desc>Pedal down and half pedal rendered with "Ped.", pedal up rendered by "*",
                    pedal "bounce" rendered with "* Ped.".</desc>
                </valItem>
                <valItem ident="altpedstar">
                  <desc>Pedal up and down indications same as with "pedstar", but bounce is rendered
                    with "Ped." only.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.bTrem.log" module="MEI.cmn" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.event"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.musical"/>
            <memberOf key="att.numbered"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Indicates whether the tremolo is measured or unmeasured.</desc>
              <valList type="closed">
                <valItem ident="meas">
                  <desc>Measured tremolo.</desc>
                </valItem>
                <valItem ident="unmeas">
                  <desc>Unmeasured tremolo.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- Provide new data.HORIZONTALALIGMENT datatype -->
        <macroSpec ident="data.HORIZONTALALIGNMENT" module="MEI" type="dt" mode="add">
          <desc>Data values for attributes that capture horizontal alignment.</desc>
          <content>
            <valList type="closed">
              <valItem ident="left">
                <desc>Left aligned.</desc>
              </valItem>
              <valItem ident="right">
                <desc>Right aligned.</desc>
              </valItem>
              <valItem ident="center">
                <desc>Centered.</desc>
              </valItem>
              <valItem ident="justify">
                <desc>Left and right aligned.</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>
        <!-- Add new att.horizontalalign class -->
        <classSpec ident="att.horizontalalign" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that record horizontal alignment.</desc>
          <attList>
            <attDef ident="halign" usage="opt">
              <desc>Records horizontal alignment.</desc>
              <datatype>
                <rng:ref name="data.HORIZONTALALIGNMENT"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Fix rip articulation, issue #164; data.ARTICULATIONS is missing 'scoop', issue #204 -->
        <!-- Add scoop, shake, and longfall; revise documentation of rip, damp, dampall, and fall -->
        <macroSpec ident="data.ARTICULATION" module="MEI" type="dt" mode="replace">
          <desc>The following list of articulations mostly corresponds to symbols from the Western
            Musical Symbols portion of the Unicode Standard. The dot and stroke values may be used
            in cases where interpretation is difficult or undesirable.</desc>
          <content>
            <valList type="closed">
              <valItem ident="acc">
                <desc>Accent (Unicode 1D17B).</desc>
              </valItem>
              <valItem ident="stacc">
                <desc>Staccato (Unicode 1D17C).</desc>
              </valItem>
              <valItem ident="ten">
                <desc>Tenuto (Unicode 1D17D).</desc>
              </valItem>
              <valItem ident="stacciss">
                <desc>Staccatissimo (Unicode 1D17E).</desc>
              </valItem>
              <valItem ident="marc">
                <desc>Marcato (Unicode 1D17F).</desc>
              </valItem>
              <valItem ident="marc-stacc">
                <desc>Marcato + staccato (Unicode 1D180).</desc>
              </valItem>
              <valItem ident="spicc">
                <desc>Spiccato.</desc>
              </valItem>
              <valItem ident="doit">
                <desc>Main note followed by short slide to higher, indeterminate pitch (Unicode
                  1D185).</desc>
              </valItem>
              <valItem ident="scoop">
                <desc>Main note preceded by short slide from lower, indeterminate pitch (Unicode
                  1D186).</desc>
              </valItem>
              <valItem ident="rip">
                <desc>Main note preceded by long slide from lower, often indeterminate pitch; also
                  known as "squeeze".</desc>
              </valItem>
              <valItem ident="plop">
                <desc>Main note preceded by "slide" from higher, indeterminate pitch.</desc>
              </valItem>
              <valItem ident="fall">
                <desc>Main note followed by short "slide" to lower, indeterminate pitch.</desc>
              </valItem>
              <valItem ident="longfall">
                <desc>Main note followed by long "slide" to lower, indeterminate pitch.</desc>
              </valItem>
              <valItem ident="bend">
                <desc>"lip slur" to lower pitch, then return to written pitch.</desc>
              </valItem>
              <valItem ident="flip">
                <desc>Main note followed by quick upward rise, then descent in pitch (Unicode
                  1D187).</desc>
              </valItem>
              <valItem ident="smear">
                <desc>(Unicode 1D188).</desc>
              </valItem>
              <valItem ident="shake">
                <desc>Alternation between written pitch and next highest overtone (brass
                  instruments) or note minor third higher (woodwinds).</desc>
              </valItem>
              <valItem ident="dnbow">
                <desc>Down bow (Unicode 1D1AA).</desc>
              </valItem>
              <valItem ident="upbow">
                <desc>Up bow (Unicode 1D1AB).</desc>
              </valItem>
              <valItem ident="harm">
                <desc>Harmonic (Unicode 1D1AC).</desc>
              </valItem>
              <valItem ident="snap">
                <desc>Snap pizzicato (Unicode 1D1AD).</desc>
              </valItem>
              <valItem ident="fingernail">
                <desc>Fingernail (Unicode 1D1B3).</desc>
              </valItem>
              <valItem ident="ten-stacc">
                <desc>Tenuto + staccato (Unicode 1D182).</desc>
              </valItem>
              <valItem ident="damp">
                <desc>Stop harp string from sounding (Unicode 1D1B4).</desc>
              </valItem>
              <valItem ident="dampall">
                <desc>Stop all harp strings from sounding (Unicode 1D1B5).</desc>
              </valItem>
              <valItem ident="open">
                <desc>Full (as opposed to stopped) tone.</desc>
              </valItem>
              <valItem ident="stop">
                <desc>"muffled" tone.</desc>
              </valItem>
              <valItem ident="dbltongue">
                <desc>Double tongue (Unicode 1D18A).</desc>
              </valItem>
              <valItem ident="trpltongue">
                <desc>Triple tongue (Unicode 1D18B).</desc>
              </valItem>
              <valItem ident="heel">
                <desc>Use heel (organ pedal).</desc>
              </valItem>
              <valItem ident="toe">
                <desc>Use toe (organ pedal).</desc>
              </valItem>
              <valItem ident="tap">
                <desc>Percussive effect on guitar string(s).</desc>
              </valItem>
              <valItem ident="lhpizz">
                <desc>Left-hand pizzicato.</desc>
              </valItem>
              <valItem ident="dot">
                <desc>Uninterpreted dot.</desc>
              </valItem>
              <valItem ident="stroke">
                <desc>Uninterpreted stroke.</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>

        <!-- Allow octave to have text content for associated text, e.g., "in 8va", "ottava bassa", etc.  -->
        <elementSpec ident="octave" module="MEI.cmn" mode="replace">
          <desc>An indication that a passage should be performed one or more octaves above or below
            its written pitch.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.octave.log"/>
            <memberOf key="att.octave.vis"/>
            <memberOf key="att.octave.ges"/>
            <memberOf key="att.octave.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike.cmn"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="octave_start-_and_end-type_attributes_required"
            scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:octave">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the
                  attributes: dur, dur.ges, endid, or tstamp2</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>The <att>dis</att> and <att>dis.place</att> attributes record the amount and
              direction of displacement, respectively. The <att>lform</att> and <att>lwidth</att>
              attributes capture the appearance of the continuation line associated with the octave
              displacement. The starting point of the octave displacement may be indicated by either
              a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or
                <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
                <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att>
              attribute. It is a semantic error not to specify one starting and one ending type of
              attribute. Also, note that the <att>dur</att> attribute is not required because the
              octave displacement can be visually instantaneous.</p>
          </remarks>
        </elementSpec>

        <!-- Allow curve to deal with slurs that continue across system or page breaks. -->
        <elementSpec ident="phrase" module="MEI.cmn" mode="replace">
          <desc>Indication of 1) a "unified melodic idea" or 2) performance technique.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.slur.log"/>
            <memberOf key="att.slur.vis"/>
            <memberOf key="att.slur.ges"/>
            <memberOf key="att.slur.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike.cmn"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="curve"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="phrase_start-_and_end-type_attributes_required"
            scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:phrase">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the
                  attributes: dur, dur.ges, endid, or tstamp2</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="phrase_containing_curve" scheme="isoschematron">
            <constraint>
              <sch:rule
                context="mei:phrase[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or 
 @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2]]">
                <sch:assert
                  test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or @endho or 
 @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
                  role="warning">The visual attributes of the phrase (@bezier, @bulge, @curvedir,
                  @lform, @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo,
                  @endvo, @x, @y, @x2, and @y2) will be overridden by visual attributes of the
                  contained curve elements.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Historically, the term "slur" indicated two notes performed legato, while the term
              "phrase" was used for a "unified melodic idea". Nowadays, however, "slur" often has
              the same meaning as "phrase" (See Read, p. 265-266), since the visual rendition of the
              two concepts is the same. MEI provides two distinct elements so that those users
              wishing to maintain a distinction for historical reasons may do so. If the user does
              not want to maintain the distinction, then the more generic <gi scheme="MEI">slur</gi>
              element should be employed. The starting point of the slur may be indicated by either
              a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or
                <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
                <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att>
              attribute. It is a semantic error not to specify one starting and one ending type of
              attribute. Either <att>place</att>, <att>bulge</att>, or <att>bezier</att> attributes
              may be used to record the curvature of the slur. The <gi scheme="MEI">slur</gi> and
                <gi scheme="MEI">tie</gi> elements may be used instead of the slur.* and tie.*
              attributes provided on <gi scheme="MEI">chord</gi> and <gi scheme="MEI">note</gi>
              elements when 1) they are required by software, or 2) multiple, alternative slurs are
              needed.</p>
          </remarks>
        </elementSpec>

        <!-- Allow curve to deal with slurs that continue across system or page breaks. Also,
            fix a bug in the schematron constraint. -->
        <elementSpec ident="slur" module="MEI.cmn" mode="replace">
          <desc>Indication of 1) a "unified melodic idea" or 2) performance technique.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.slur.log"/>
            <memberOf key="att.slur.vis"/>
            <memberOf key="att.slur.ges"/>
            <memberOf key="att.slur.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike.cmn"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="curve"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="slur_start-_and_end-type_attributes_required"
            scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:slur">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the
                  attributes: dur, dur.ges, endid, or tstamp2</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="slur_containing_curve" scheme="isoschematron">
            <constraint>
              <sch:rule
                context="mei:slur[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or 
                @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or 
                @x or @y or @x2 or @y2]]">
                <sch:assert
                  test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or 
                  @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
                  role="warning">The visual attributes of the slur (@bezier, @bulge, @curvedir,
                  @lform, @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo,
                  @endvo, @x, @y, @x2, and @y2) will be overridden by visual attributes of the
                  contained curve elements.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Historically, the term "slur" indicated two notes performed legato, while the term
              "phrase" was used for a "unified melodic idea". Nowadays, however, "slur" often has
              the same meaning as "phrase" (See Read, p. 265-266), since the visual rendition of the
              two concepts is the same. MEI provides two distinct elements so that those users
              wishing to maintain a distinction for historical reasons may do so. If the user does
              not want to maintain the distinction, then the more generic <gi scheme="MEI">slur</gi>
              element should be employed. The starting point of the slur may be indicated by either
              a <att>startid</att>, <att>tstamp</att>, <att>tstamp.ges</att>, or
                <att>tstamp.real</att> attribute, while the ending point may be recorded by either a
                <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or <att>tstamp2</att>
              attribute. It is a semantic error not to specify one starting and one ending type of
              attribute. Either <att>place</att>, <att>bulge</att>, or <att>bezier</att> attributes
              may be used to record the curvature of the slur. The <gi scheme="MEI">slur</gi> and
                <gi scheme="MEI">tie</gi> elements may be used instead of the slur.* and tie.*
              attributes provided on <gi scheme="MEI">chord</gi> and <gi scheme="MEI">note</gi>
              elements when 1) they are required by software, or 2) multiple, alternative slurs are
              needed.</p>
          </remarks>
        </elementSpec>

        <!-- Make member of att.bibl -->
        <elementSpec ident="tempo" module="MEI.shared" mode="replace">
          <desc>Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo",
            "cantabile", "Moderato", "♩=60", "Moderato ♩ =60").</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.tempo.log"/>
            <memberOf key="att.tempo.vis"/>
            <memberOf key="att.tempo.ges"/>
            <memberOf key="att.tempo.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike"/>
            <memberOf key="model.workIdent"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="tempo_in_header_disallow_most_attrs" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:tempo[ancestor::mei:meiHead]">
                <sch:assert
                  test="not(@*[name() != 'label' and name() != 'n' and name() != 'xml:base' and name() != 'xml:id' and name() != 'xml:lang'])"
                  >Only label, n, xml:base, xml:id, and xml:lang attributes allowed when this
                  element occurs in the header.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="tempo_start-type_attributes_required" scheme="isoschematron">
            <constraint>
              <sch:rule
                context="mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:meiHead)]">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>

        <!-- Allow curve to deal with ties that continue across system or page breaks. -->
        <elementSpec ident="tie" module="MEI.cmn" mode="replace">
          <desc>An indication that two notes of the same pitch form a single note with their
            combined rhythmic values.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.tie.log"/>
            <memberOf key="att.tie.vis"/>
            <memberOf key="att.tie.ges"/>
            <memberOf key="att.tie.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike.cmn"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="curve"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="tie_start-_and_end-type_attributes_required" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:tie">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the
                  attributes: dur, dur.ges, endid, or tstamp2</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="tie_containing_curve" scheme="isoschematron">
            <constraint>
              <sch:rule
                context="mei:tie[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or 
                @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or 
                @endvo or @x or @y or @x2 or @y2]]">
                <sch:assert
                  test="not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or 
                  @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
                  role="warning">The visual attributes of the tie (@bezier, @bulge, @curvedir,
                  @lform, @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo,
                  @endvo, @x, @y, @x2, and @y2) will be overridden by visual attributes of the
                  contained curve elements.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Most often, a tie is rendered as a curved line connecting the two notes. See Read, p.
              110-111, 122.</p>
          </remarks>
        </elementSpec>

        <!-- Make <breath> a member of att.typography, issue #167. -->
        <classSpec ident="att.breath.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>

        <!-- Add ending value for hairpin -->
        <classSpec ident="att.hairpin.ges" module="MEI.cmn" type="atts" mode="replace">
          <desc>Gestural domain attributes.</desc>
          <classes>
            <memberOf key="att.duration.performed"/>
            <memberOf key="att.midivalue"/>
            <memberOf key="att.midivalue2"/>
          </classes>
        </classSpec>
        <!-- Add indication of whether hairpin starts from / ends in silence. This is often
        rendered as a small circle attached to the closed end of the hairpin. See Gould, p. 108. -->
        <classSpec ident="att.hairpin.log" module="MEI.cmn" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
          <attList>
            <attDef ident="form" usage="req">
              <desc>Captures the visual rendition and function of the hairpin; that is, whether it
                indicates an increase or a decrease in volume.</desc>
              <valList type="closed">
                <valItem ident="cres">
                  <desc>Crescendo; i.e., louder.</desc>
                </valItem>
                <valItem ident="dim">
                  <desc>Diminuendo; i.e., softer.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="niente" usage="opt">
              <desc>Indicates that the hairpin starts from or ends in silence. Often rendered as a
                small circle attached to the closed end of the hairpin. See Gould, p. 108.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Facilitate overlapping staff groups, issue #178 -->
        <elementSpec ident="grpSym" module="MEI.shared" mode="replace">
          <desc>(group symbol) – A brace or bracket used to group two or more staves of a score or
            part.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.grpSym.log"/>
            <memberOf key="att.grpSym.vis"/>
            <memberOf key="att.grpSym.ges"/>
            <memberOf key="att.grpSym.anl"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.labelLike"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="check_grpSym_attributes_scoreDef" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:grpSym[parent::mei:scoreDef]">
                <sch:assert test="@startid and @endid and @level">In this context, grpSym must have
                  startid, endid, and level attributes.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="check_grpSym_attributes_staffDef" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:grpSym[parent::mei:staffGrp]">
                <sch:assert test="not(@startid or @endid or @level)">In this context, grpSym must
                  not have startid, endid, or level attributes.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>This element provides an alternative to the <gi scheme="MEI">staffGrp</gi> element's
                <att>symbol</att> attribute. It may be used when exact placement or editorial
              details for the grouping symbol must be recorded.</p>
          </remarks>
        </elementSpec>
        <classSpec ident="att.grpSym.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.staffgroupingsym"/>
            <memberOf key="att.startendid"/>
          </classes>
          <attList>
            <attDef ident="level" usage="opt">
              <desc>Indicates the nesting level of staff grouping symbols.</desc>
              <datatype>
                <rng:data type="positiveInteger"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Harmonize content model of <fw> and <pgHead>, <pgFoot>, etc., issue #179 -->
        <!-- Actually, the best course of action is to replace <fw> with <pgHead> and <pgFoot>.
          <pgHead>, etc. are all now members of att.typed. In addition, <pgHead2> and <pgFoot2>
          have been given a new @halign attribute which facilitates the capture of horizontal
          alignment. -->
        <elementSpec ident="fw" module="MEI.shared" mode="delete"/>
        <macroSpec ident="macro.metaLike.page" module="MEI.shared" type="pe" mode="replace">
          <desc>Groups elements that contain meta-data about a single page.</desc>
          <content>
            <rng:optional>
              <rng:ref name="pgHead"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgFoot"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="pgDesc"/>
            </rng:optional>
          </content>
        </macroSpec>
        <elementSpec ident="pgFoot" module="MEI.shared" mode="replace">
          <desc>(page footer) – A running footer on the first page. Also, used to temporarily
            override a running footer on individual pages.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.appLike"/>
                <rng:ref name="anchoredText"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is used to capture the textual data that often appears on the first page
              of printed music. It may also be used for similarly formatted material in manuscripts.
              When used within <gi scheme="MEI">pb</gi>, it records a temporary suspension of the
              pattern of page footers established by the use of <gi scheme="MEI">pgFoot</gi> within
              a previous <gi scheme="MEI">scoreDef</gi>. Auto-generated page numbers may be
              indicated with a processing instruction. The pgHead, pgHead2, pgFoot, and pgFoot2
              elements should <hi rend="bold">*not*</hi> be used to encode textual
              notes/annotations.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="pgFoot2" module="MEI.shared" mode="replace">
          <desc>(page footer 2) – A running footer on the pages following the first.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.appLike"/>
                <rng:ref name="anchoredText"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="halign" usage="opt">
              <desc>Records horizontal alignment. Use multiple values to capture a repeating
                pattern.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.HORIZONTALALIGNMENT"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>This element is used to capture the textual data that often appears on the second and
              succeeding pages of printed music. It may also be used for similarly formatted
              material in manuscripts. Auto-generated page numbers may be indicated with a
              processing instruction. The pgHead, pgHead2, pgFoot, and pgFoot2 elements should <hi
                rend="bold">*not*</hi> be used to encode textual notes/annotations.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="pgHead" module="MEI.shared" mode="replace">
          <desc>(page header) – A running header on the first page. Also, used to temporarily
            override a running header on individual pages.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.appLike"/>
                <rng:ref name="anchoredText"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is used to capture the textual data that often appears on the first page
              of printed music. It may also be used for similarly formatted material in manuscripts.
              When used within <gi scheme="MEI">pb</gi>, it records a temporary suspension of the
              pattern of page headers established by the use of <gi scheme="MEI">pgHead</gi> within
              a previous <gi scheme="MEI">scoreDef</gi>. Auto-generated page numbers may be
              indicated with a processing instruction. The pgHead, pgHead2, pgFoot, and pgFoot2
              elements should <hi rend="bold">*not*</hi> be used to encode textual
              notes/annotations.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="pgHead2" module="MEI.shared" mode="replace">
          <desc>(page header 2) – A running header on the pages following the first.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.appLike"/>
                <rng:ref name="anchoredText"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="halign" usage="opt">
              <desc>Records horizontal alignment. Use multiple values to capture a repeating
                pattern.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.HORIZONTALALIGNMENT"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>This element is used to capture the textual data that often appears at the top of the
              second and succeeding pages of printed music. It may also be used for similarly
              formatted material in manuscripts. Auto-generated page numbers may be indicated with a
              processing instruction. The pgHead, pgHead2, pgFoot, and pgFoot2 elements should <hi
                rend="bold">*not*</hi> be used to encode textual notes/annotations.</p>
          </remarks>
        </elementSpec>

        <!-- Modify @symbol values on grpSym, issue #180 -->
        <!-- THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <classSpec ident="att.staffgroupingsym" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that describe the symbol used to group a set of staves.</desc>
          <attList>
            <attDef ident="symbol" usage="opt">
              <desc>Specifies the symbol used to group a set of staves.</desc>
              <valList type="closed">
                <valItem ident="brace">
                  <desc>Curved symbol, i.e., {.</desc>
                </valItem>
                <valItem ident="bracket">
                  <desc>Square symbol, i.e., [, but with curved/angled top and bottom
                    segments.</desc>
                </valItem>
                <valItem ident="bracketsq">
                  <desc>Square symbol, i.e., [, with horizontal top and bottom segments.</desc>
                </valItem>
                <valItem ident="line">
                  <desc>Line symbol, i.e., |, (wide) line without top and bottom curved/horizontal
                    segments.</desc>
                </valItem>
                <valItem ident="none">
                  <desc>Grouping symbol missing.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise staff grouping symbols, issue #182 -->
        <!-- Break att.scoreDef.* into more atomic units, issue #115 -->
        <classSpec ident="att.endings" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that record ending style information</desc>
          <attList>
            <attDef ident="ending.rend" usage="opt">
              <desc>Describes where ending marks should be displayed.</desc>
              <valList type="closed">
                <valItem ident="top">
                  <desc>Ending rendered only above top staff.</desc>
                </valItem>
                <valItem ident="barred">
                  <desc>Ending rendered above staves that have bar lines drawn across them.</desc>
                </valItem>
                <valItem ident="grouped">
                  <desc>Endings rendered above staff groups.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.measurenumbers" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes pertaining to measure numbers</desc>
          <attList>
            <attDef ident="mnum.visible" usage="opt">
              <desc>Indicates whether measure numbers should be displayed.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.notationstyle" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that capture music font name and size.</desc>
          <attList>
            <attDef ident="music.name" usage="opt">
              <desc>Sets the default music font name.</desc>
              <datatype>
                <rng:ref name="data.MUSICFONT"/>
              </datatype>
            </attDef>
            <attDef ident="music.size" usage="opt">
              <desc>Sets the default music font size.</desc>
              <datatype>
                <rng:ref name="data.FONTSIZE"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.optimization" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes pertaining to layout optimization.</desc>
          <attList>
            <attDef ident="optimize" usage="opt">
              <desc>Indicates whether staves without notes, rests, etc. should be displayed. When
                the value is 'true', empty staves are displayed.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.pages" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that record page-level layout information.</desc>
          <attList>
            <attDef ident="page.height" usage="opt">
              <desc>Specifies the height of the page; may be expressed in real-world units or staff
                steps.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.width" usage="opt">
              <desc>Describes the width of the page; may be expressed in real-world units or staff
                steps.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.topmar" usage="opt">
              <desc>Indicates the amount of whitespace at the top of a page.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.botmar" usage="opt">
              <desc>Indicates the amount of whitespace at the bottom of a page.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.leftmar" usage="opt">
              <desc>Indicates the amount of whitespace at the left side of a page.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.rightmar" usage="opt">
              <desc>Indicates the amount of whitespace at the right side of a page.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="page.panels" usage="opt">
              <desc>Indicates the number of logical pages to be rendered on a single physical
                page.</desc>
              <datatype>
                <rng:ref name="data.PAGE.PANELS"/>
              </datatype>
            </attDef>
            <attDef ident="page.scale" usage="opt">
              <desc>Indicates how the page should be scaled when rendered.</desc>
              <datatype>
                <rng:ref name="data.PGSCALE"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.spacing" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that capture notation spacing information.</desc>
          <attList>
            <attDef ident="spacing.packexp" usage="opt">
              <desc>Describes a note's spacing relative to its time value.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
            <attDef ident="spacing.packfact" usage="opt">
              <desc>Describes the note spacing of output.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
            <attDef ident="spacing.staff" usage="opt">
              <desc>Specifies the minimum amount of space between adjacent staves in the same
                system; measured from the bottom line of the staff above to the top line of the
                staff below.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="spacing.system" usage="opt">
              <desc>Describes the space between adjacent systems; a pair of space-separated values
                (minimum and maximum, respectively) provides a range between which a rendering
                system-supplied value may fall, while a single value indicates a fixed amount of
                space; that is, the minimum and maximum values are equal.</desc>
              <datatype>
                <rng:list>
                  <rng:ref name="data.MEASUREMENT"/>
                </rng:list>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add @system.leftline for score-wide specification of left line -->
        <classSpec ident="att.systems" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that capture system layout information.</desc>
          <attList>
            <attDef ident="system.leftline" usage="opt">
              <desc>Indicates whether the staves are joined at the left by a continuous line. The
                default value is "true". Do not confuse this with the heavy vertical line used as a
                grouping symbol.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
            <attDef ident="system.leftmar" usage="opt">
              <desc>Describes the amount of whitespace at the left system margin relative to
                page.leftmar.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="system.rightmar" usage="opt">
              <desc>Describes the amount of whitespace at the right system margin relative to
                page.rightmar.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="system.topmar" usage="opt">
              <desc>Describes the distance from page's top edge to the first system; used for first
                page only.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.scoreDef.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes for scoreDef in the CMN repertoire.</desc>
          <classes>
            <memberOf key="att.barplacement"/>
            <memberOf key="att.cleffing.vis"/>
            <memberOf key="att.distances"/>
            <memberOf key="att.endings"/>
            <memberOf key="att.keySigDefault.vis"/>
            <memberOf key="att.lyricstyle"/>
            <memberOf key="att.measurenumbers"/>
            <memberOf key="att.meterSigDefault.vis"/>
            <memberOf key="att.multinummeasures"/>
            <memberOf key="att.notationstyle"/>
            <memberOf key="att.onelinestaff"/>
            <memberOf key="att.optimization"/>
            <memberOf key="att.pages"/>
            <memberOf key="att.spacing"/>
            <memberOf key="att.systems"/>
            <memberOf key="att.textstyle"/>
            <memberOf key="att.scoreDef.vis.cmn"/>
            <memberOf key="att.scoreDef.vis.mensural"/>
          </classes>
          <attList>
            <attDef ident="vu.height" usage="opt">
              <desc>Defines the height of a "virtual unit" (vu) in terms of real-world units. A
                single vu is half the distance between the vertical center point of a staff line and
                that of an adjacent staff line.</desc>
              <datatype>
                <rng:data type="token">
                  <!-- px and vu are *not* allowed here -->
                  <rng:param name="pattern">\d+(\.\d+)?(cm|mm|in|pt|pc)</rng:param>
                </rng:data>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise description of title/@level, issue #184 -->
        <!-- Method for capturing non-filing part of title/name, issue #185 -->
        <!-- Add att.filing class -->
        <classSpec ident="att.filing" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that deal with string filing characteristics.</desc>
          <attList>
            <attDef ident="nonfiling" usage="opt">
              <desc>Holds the number of initial characters (such as those constituing an article or
                preposition) that should not be used for sorting a title or name.</desc>
              <datatype>
                <rng:data type="positiveInteger"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make att.name a member of att.filing -->
        <!-- Enforce constraints on attribute targets, issue #226 -->
        <classSpec ident="att.name" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes shared by names.</desc>
          <classes>
            <memberOf key="att.authorized"/>
            <memberOf key="att.canonical"/>
            <memberOf key="att.filing"/>
          </classes>
          <attList>
            <attDef ident="nymref" usage="opt">
              <desc>Used to record a pointer to the regularized form of the name elsewhere in the
                document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_instrTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@nymref">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@nymref
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >The value in @nymref must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="role" usage="opt">
              <desc>Used to specify further information about the entity referenced by this name,
                for example, the occupation of a person or the status of a place. Use a standard
                value whenever possible.</desc>
              <datatype>
                <rng:text/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make <title> a member of att.filing; add @prefix -->
        <!-- Include SVG, issue #53: add @prefix to explicitly reference title in MEI namespace -->
        <elementSpec ident="title" module="MEI.shared" mode="replace" prefix="mei_">
          <desc>Title of a bibliographic entity.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.canonical"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.filing"/>
            <memberOf key="att.lang"/>
            <!--<memberOf key="att.typed"/>-->
            <memberOf key="model.titleLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="level" usage="opt">
              <desc>Indicates the bibliographic level for a title.</desc>
              <valList type="closed">
                <valItem ident="a">
                  <desc>Analyzed component, such as an article or chapter, within a larger
                    bibliographic entity.</desc>
                </valItem>
                <valItem ident="m">
                  <desc>Monograph.</desc>
                </valItem>
                <valItem ident="j">
                  <desc>Journal.</desc>
                </valItem>
                <valItem ident="s">
                  <desc>Series.</desc>
                </valItem>
                <valItem ident="u">
                  <desc>Unpublished (including theses and dissertations unless published by a
                    commercial press).</desc>
                </valItem>
              </valList>
            </attDef>
            <!-- att.typed (@type and @subtype) expanded here to encourage use of recommended type values -->
            <attDef ident="type" usage="opt">
              <desc>Characterizes the element in some sense, using any convenient classification
                scheme or typology.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <valList type="semi">
                <valItem ident="main">
                  <desc>Main title.</desc>
                </valItem>
                <valItem ident="subordinate">
                  <desc>Subtitle or title of part.</desc>
                </valItem>
                <valItem ident="abbreviated">
                  <desc>Abbreviated form of title.</desc>
                </valItem>
                <valItem ident="alternative">
                  <desc>Alternate title by which the item is also known.</desc>
                </valItem>
                <valItem ident="translated">
                  <desc>Translated form of title.</desc>
                </valItem>
                <valItem ident="uniform">
                  <desc>Collective title.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" usage="opt">
              <desc>Provide any sub-classification for the element, additional to that given by its
                type attribute.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>type</att> attribute may be used to classify the title according to some
              convenient typology. Sample values include: main (main title), subordinate (subtitle,
              title of part), abbreviated (abbreviated form of title), alternative (alternate title
              by which the work is also known), translated (translated form of title), uniform
              (collective title). The <att>type</att> attribute is provided for convenience in
              analysing titles and processing them according to their type; where such specialized
              processing is not necessary, there is no need for such analysis, and the entire title,
              including subtitles and any parallel titles, may be enclosed within a single <gi
                scheme="MEI">title</gi> element. Title parts may be encoded in <gi scheme="MEI"
                >title</gi> sub-elements. The name of the list from which a controlled value is
              taken may be recorded using the <att>authority</att> attribute. The number of initial
              characters (such as those constituing an article or preposition) that should not be
              used for sorting a title or name may be indicated in the <att>nonfiling</att>
              attribute.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>

        <!-- Head not permitted in projectDesc, issue #187. Also make head available in other 
          children of encodingDesc (appInfo, editorialDecl, and samplingDesc) and other list-like
          and grouping header elements (classification, componentGrp, expressionList, itemList,
          langUsage, relationList). -->
        <elementSpec ident="appInfo" module="MEI.header" mode="replace">
          <desc>(application information) – Groups information about applications which have acted
            upon the MEI file.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="model.encodingPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="application"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>Applications in this context is not to be confused with applications which were used
              to create the MEI file. The latter may be recorded in the <gi scheme="MEI"
                >projectDesc</gi> element.</p>
          </remarks>
          <remarks>
            <p> This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="projectDesc" module="MEI.header" mode="replace">
          <desc>(project description) – Project-level meta-data describing the aim or purpose for
            which the electronic file was encoded, funding agencies, etc. together with any other
            relevant information concerning the process by which it was assembled or
            collected.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.lang"/>
            <memberOf key="model.encodingPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="model.pLike"/>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="editorialDecl" module="MEI.header" mode="replace">
          <desc>(editorial declaration) – Used to provide details of editorial principles and
            practices applied during the encoding of musical text.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.lang"/>
            <memberOf key="model.encodingPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:choice>
              <rng:oneOrMore>
                <rng:ref name="model.pLike"/>
              </rng:oneOrMore>
              <rng:group>
                <rng:oneOrMore>
                  <rng:ref name="model.editorialDeclPart"/>
                </rng:oneOrMore>
                <rng:zeroOrMore>
                  <rng:ref name="model.pLike"/>
                </rng:zeroOrMore>
              </rng:group>
            </rng:choice>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="samplingDecl" module="MEI.header" mode="replace">
          <desc>(sampling declaration) – Contains a prose description of the rationale and methods
            used in sampling texts in the creation of a corpus or collection.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.lang"/>
            <memberOf key="model.encodingPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="model.pLike"/>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="classification" module="MEI.header" mode="replace">
          <desc>Groups information which describes the nature or topic of an entity.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:choice>
                <rng:ref name="classCode"/>
                <rng:ref name="termList"/>
              </rng:choice>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>Although the use of names and terms from locally controlled vocabularies is possible,
              best practice suggests that terms should come from standard national or international
              vocabularies whenever they are available in order to enable searches in systems that
              include multiple MEI documents, or MEI documents and bibliographic records from many
              institutions.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="componentGrp" module="MEI.frbr" mode="replace">
          <desc>(component group) – Container for components of a bibliographic entity.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:choice>
              <rng:zeroOrMore>
                <rng:ref name="model.workLike"/>
              </rng:zeroOrMore>
              <rng:zeroOrMore>
                <rng:ref name="model.expressionLike"/>
              </rng:zeroOrMore>
              <rng:zeroOrMore>
                <rng:ref name="model.manifestationLike"/>
              </rng:zeroOrMore>
              <rng:zeroOrMore>
                <rng:ref name="model.itemLike"/>
              </rng:zeroOrMore>
            </rng:choice>
          </content>
          <constraintSpec ident="checkComponentGrp" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:componentGrp">
                <sch:assert
                  test="every $i in ./child::mei:*[not(local-name()='head')] satisfies $i/local-name() eq ./parent::mei:*/local-name()"
                  >Only child elements of the same name as the parent of the componentGrp-element
                  are allowed.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>The child elements of this element are treated as parts of the bibliographic entity
              containing the <gi scheme="MEI">componentGrp</gi>. Although this is an implicit way of
              expressing FRBR's hasPart / isPartOf-relationships, it avoids this terminology in
              order to prevent confusion with musical terminology. All children of a component must
              be the same type as its parent: only <gi scheme="MEI">work</gi> children are allowed
              within <gi scheme="MEI">work</gi>, <gi scheme="MEI">item</gi> in <gi scheme="MEI"
                >item</gi>, etc.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="expressionList" module="MEI.frbr" mode="replace">
          <desc>Gathers bibliographic expression entities.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.expressionLike"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <elementSpec ident="itemList" module="MEI.frbr" mode="replace">
          <desc>Gathers bibliographic item entities.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.itemLike"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <elementSpec ident="langUsage" module="MEI.header" mode="replace">
          <desc>(language usage) – Groups elements describing the languages, sub-languages,
            dialects, etc., represented within the encoded resource.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="language"/>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="relationList" module="MEI.frbr" mode="replace">
          <desc>Gathers bibliographic relation elements.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.relationLike"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>

        <!-- Support SMuFL, issue #213 -->
        <!-- Add att.extsym attribute class. -->
        <classSpec ident="att.extsym" module="MEI.externalsymbols" type="atts" mode="add">
          <desc>Attributes used to associated MEI features with corresponding glyphs in an
            externally-defined standard such as SMuFL.</desc>
          <attList>
            <attDef ident="glyphname" usage="opt">
              <desc>Glyph name.</desc>
              <datatype>
                <rng:data type="string"/>
              </datatype>
            </attDef>
            <attDef ident="glyphnum" usage="opt">
              <desc>Numeric glyph reference.</desc>
              <datatype>
                <rng:data type="string">
                  <rng:param name="pattern">#x[A-F0-9]+</rng:param>
                </rng:data>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Provide more granular and more TEI-like description of user-defined symbols -->
        <elementSpec ident="symbolDef" module="MEI.usersymbols" mode="replace">
          <desc>(symbol definition) – Declaration of an individual symbol in a symbolTable.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.coordinated"/>
          </classes>
          <content>
            <rng:optional>
              <rng:ref name="symName"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="symProp"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="mapping"/>
            </rng:zeroOrMore>
            <!-- Use either SVG or MEI elements to "draw" the symbol -->
            <rng:choice>
              <rng:optional>
                <rng:ref name="svg"/>
              </rng:optional>
              <rng:zeroOrMore>
                <rng:choice>
                  <rng:ref name="model.graphicprimitiveLike"/>
                  <!-- With symbol no longer in model.graphicprimitiveLike, it must be added. -->
                  <rng:ref name="mei_symbol"/>
                  <rng:ref name="graphic"/>
                </rng:choice>
              </rng:zeroOrMore>
            </rng:choice>
            <rng:zeroOrMore>
              <rng:ref name="model.annotLike"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>Like a chord table, a symbolTable may be shared between MEI instances through the use
              of an external parsed entity containing the symbolTable to be shared.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="symName" module="MEI.usersymbols" mode="add">
          <desc>(symbol name) – Contains the name of a symbol, expressed following Unicode
            conventions.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:text/>
          </content>
        </elementSpec>
        <elementSpec ident="symProp" module="MEI.usersymbols" mode="add">
          <desc>(symbol property) – Provides a name and value for some property of the parent
            symbol.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:ref name="propName"/>
            <rng:ref name="propValue"/>
          </content>
        </elementSpec>
        <elementSpec ident="propName" module="MEI.usersymbols" mode="add">
          <desc>(property name) – Name of a property of the symbol.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:text/>
          </content>
          <attList>
            <attDef ident="type" usage="req">
              <desc>Characterizes the property name.</desc>
              <valList type="closed">
                <valItem ident="unicode">
                  <desc>A registered Unicode normative or informative property name.</desc>
                </valItem>
                <valItem ident="local">
                  <desc>A locally defined name.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="propValue" module="MEI.usersymbols" mode="add">
          <desc>(property value) – A single property value.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:text/>
          </content>
        </elementSpec>
        <elementSpec ident="mapping" module="MEI.usersymbols" mode="add">
          <desc>One or more characters which are related to the parent symbol in some respect, as
            specified by the type attribute.</desc>
          <classes>
            <memberOf key="att.common"/>
            <!--<memberOf key="att.authorized"/>
            <memberOf key="att.extsym"/>-->
            <memberOf key="att.responsibility"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <!-- Include SVG, issue #53: add @prefix to explicitly reference symbol in MEI namespace -->
                <rng:ref name="mei_symbol"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <!-- Allow the use of symbol to include music characters anywhere text is permitted. Make 
          symbol member of att.altsym. The @ref attribute is no longer necessary. Its function can 
          be performed by @altsym. Remove symbol from model.graphicprimitiveLike class and add to 
          model.textphraseLike.imited class. This last change fixes a problem that allowed symbol to 
          occur in too many places, for instance, within measure. With this change, symbol can only 
          occur if wrapped by anchoredText. -->
        <!-- Include SVG, issue #53: add @prefix to explicitly reference symbol in MEI namespace -->
        <elementSpec ident="symbol" module="MEI.usersymbols" mode="replace" prefix="mei_">
          <desc>A reference to a previously defined symbol.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.color"/>
            <memberOf key="att.common"/>
            <memberOf key="att.common.anl"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.scalable"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
            <!-- Make member of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.textphraseLike.limited"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <remarks>
            <p>The starting point, e.g. "hotspot", of the symbol may be identified in absolute
              output coordinate terms using the <att>x</att> and <att>y</att> attributes or relative
              to another element using the <att>startid</att> attribute. Attributes in the
              att.visualoffset class may be used to record horizontal, vertical, or time offsets
              from the absolute coordinates or from the location of the referenced element. The
                <att>ref</att> attribute must contain the id of a <gi scheme="MEI">symbolDef</gi>
              element. The <att>scale</att> attribute indicates that the printed output must be
              scaled by the specified percentage.</p>
          </remarks>
        </elementSpec>
        <!-- THESE CHANGES BREAK BACKWARD COMPATIBILITY! -->
        <!-- Add data.FLAGSHAPE and data.FLAGPOSITION datatypes -->
        <!-- <macroSpec ident="data.FLAGSHAPE" module="MEI" type="dt" mode="add">
          <desc>Captures the general shape of flags on a stem.</desc>
          <content>
            <valList type="closed">
              <valItem ident="straight"/>
              <valItem ident="angled"/>
              <valItem ident="curled"/>
              <valItem ident="circular"/>
              <valItem ident="rounded"/>
              <valItem ident="flared"/>
              <valItem ident="extended"/>
              <valItem ident="hooked"/>
            </valList>
          </content>
        </macroSpec>
        <macroSpec ident="data.FLAGPOSITION" module="MEI" type="dt" mode="add">
          <desc>Captures the position of flags relative to the stem.</desc>
          <content>
            <valList type="closed">
              <valItem ident="left"/>
              <valItem ident="right"/>
              <valItem ident="end"/>
            </valList>
          </content>
        </macroSpec> -->
        <!-- Add notehead element -->
        <!--<classSpec ident="att.notehead.vis" module="MEI.shared" type="atts" mode="add">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.coloration"/>
            <memberOf key="att.enclosingchars"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.stems"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visibility"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.visualoffset.to"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="fill" usage="opt">
              <desc>Describes how/if the notehead is filled.</desc>
              <datatype>
                <rng:ref name="data.FILL"/>
              </datatype>
            </attDef>
            <attDef ident="fillcolor" usage="opt">
              <desc>Captures the fill color of a notehead if it's different from the overall note
                color.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="mod" usage="opt">
              <desc>Records any additional symbols applied to the notehead.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.NOTEHEADMODIFIER"/>
              </datatype>
            </attDef>
            <attDef ident="rotation" usage="opt">
              <desc>A positive value for rotation rotates the notehead in a counter-clockwise
                fashion, while negative values produce clockwise rotation.</desc>
              <datatype>
                <rng:ref name="data.DEGREES"/>
              </datatype>
            </attDef>
            <attDef ident="shape" usage="opt">
              <desc>Used to override the head shape normally used for the given duration.</desc>
              <datatype>
                <rng:ref name="data.HEADSHAPE"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec ident="notehead" module="MEI.shared" mode="add">
          <desc>The part of the note that, when placed on a staff, indicates pitch (and often
            duration).</desc>
          <classes>
            <memberOf key="att.notehead.vis"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
        </elementSpec>
        <!-\- Add stem element -\->
        <classSpec ident="att.stem.vis" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that describe the properties of stemmed features; that is, chords and
            notes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visibility"/>
          </classes>
          <attList>
            <attDef ident="dir" usage="opt">
              <desc>Describes the direction of a stem.</desc>
              <datatype>
                <rng:ref name="data.STEMDIRECTION"/>
              </datatype>
            </attDef>
            <attDef ident="len" usage="opt">
              <desc>Encodes the stem length.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="mod" usage="opt">
              <desc>Encodes any stem "modifiers"; that is, symbols rendered on the stem, such as
                tremolo or Sprechstimme indicators.</desc>
              <datatype>
                <rng:ref name="data.STEMMODIFIER"/>
              </datatype>
            </attDef>
            <attDef ident="pos" usage="opt">
              <desc>Records the position of the stem in relation to the note head(s).</desc>
              <datatype>
                <rng:ref name="data.STEMPOSITION"/>
              </datatype>
            </attDef>
            <attDef ident="with" usage="opt">
              <desc>Contains an indication of which staff a note or chord that logically belongs to
                the current staff should be visually placed on; that is, the one above or the one
                below.</desc>
              <datatype>
                <rng:ref name="data.OTHERSTAFF"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec ident="stem" module="MEI.shared" mode="add">
          <desc>Part of the note that indicates duration or other modifications of the note.</desc>
          <classes>
            <memberOf key="att.stem.vis"/>
            <memberOf key="model.rdgPart.critapp"/>
          </classes>
          <content>
            <rng:optional>
              <rng:ref name="flags"/>
            </rng:optional>
          </content>
          <constraintSpec ident="stem_must_have_note_or_chord_ancestor" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:stem">
                <sch:assert test="ancestor::mei:note or ancestor::mei:chord">A stem must have a note
                  or chord ancestor.</sch:assert>
                <sch:assert test="not(ancestor::mei:note and ancestor::mei:chord)">Stems for notes
                  in a chord must be specified as children of the chord, not the note.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <!-\- Does this constraint only apply to CMN? -\->
          <constraintSpec ident="chord_single_stem" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:chord[mei:stem]">
                <sch:assert test="not(count(mei:stem) &gt; 1)">A chord may only have one stem
                  subelement.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <!-\- Add flags element -\->
        <classSpec ident="att.flags.vis" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that capture information regarding flags.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="color" usage="opt">
              <desc>The color of the flags when different from stem, note, and chord ancestors.
                Multiple values are permitted if flags have differing colors.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="pos" usage="opt">
              <desc>Position of flags relative to the stem. Multiple values are permitted if flags
                have differing positions.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.FLAGPOSITION"/>
              </datatype>
            </attDef>
            <attDef ident="shape" usage="opt">
              <desc>Captures the general shape of flags on a stem. Multiple values are permitted if
                flags have differing shapes.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.FLAGSHAPE"/>
              </datatype>
            </attDef>
            <attDef ident="fillcolor" usage="opt">
              <desc>Captures the fill color of flags when different from stem, note, and chord
                ancestors. Multiple values are permitted if flags have differing shapes.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec ident="flags" module="MEI.shared" mode="add">
          <desc>The part of a note that, along with a stem, indicates duration.</desc>
          <classes>
            <memberOf key="att.flags.vis"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
        </elementSpec>
        <!-\- Revise content of note -\->
        <elementSpec ident="note" module="MEI.shared" mode="replace">
          <desc>A single pitched event. <!-\- (Read, p. 63) -\->
          </desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.note.log"/>
            <memberOf key="att.note.vis"/>
            <memberOf key="att.note.ges"/>
            <memberOf key="att.note.anl"/>
            <memberOf key="model.eventLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <!-\-<rng:ref name="notehead"/>
                <rng:ref name="stem"/>-\->
                <rng:ref name="model.noteModifierLike"/>
                <rng:ref name="model.verseLike"/>
                <rng:ref name="model.sylLike"/>
                <rng:ref name="model.appLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="note_only_one_notehead" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:note[mei:notehead]">
                <sch:assert test="count(mei:notehead) = 1">A note may only have one
                  notehead.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>The <gi scheme="MEI">accid</gi>, <gi scheme="MEI">artic</gi>, <gi scheme="MEI"
                >dot</gi>, and <gi scheme="MEI">stem</gi> sub-elements may be used instead of the
              note element's attributes when accid and artic represent first-class objects, e.g.,
              when they require attributes, such as <att>x</att> and <att>y</att> location
              attributes. Similarly, the <gi scheme="MEI">syl</gi> sub-element may be used instead
              of the <att>syl</att> attribute. The verse sub-element may be used to group text
              syllables by verse. The <att>colored</att> attribute may be used to indicate
              coloration. In the mensural repertoire, coloration is a temporary change in the
              underlying mensuration from perfect to imperfect. In the CMN repertoire, coloration is
              an inversion of the note head's normal rendition, that is, the note head is void when
              it would otherwise be filled and vice versa. Do not confuse this with visual
              color.</p>
          </remarks>
        </elementSpec>
        <!-\- Revise content of chord -\->
        <elementSpec ident="chord" module="MEI.shared" mode="replace">
          <desc>A simultaneous sounding of two or more notes in the same layer *with the same
            duration*.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.chord.log"/>
            <memberOf key="att.chord.vis"/>
            <memberOf key="att.chord.ges"/>
            <memberOf key="att.chord.anl"/>
            <memberOf key="model.eventLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="note"/>
                <rng:ref name="artic"/>
                <rng:ref name="stem"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>-->

        <!-- Harmonize models of gliss and line by allowing gliss to contain text to be 
          rendered with the line, issue #215 -->
        <!-- Remove @text. THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <classSpec ident="att.gliss.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <!-- Make att.["musical" element].vis members of att.altsym and att.typography -->
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.xy2"/>
            <memberOf key="att.linerend"/>
          </classes>
        </classSpec>
        <elementSpec ident="gliss" module="MEI.cmn" mode="replace">
          <desc>(glissando) – A continuous or sliding movement from one pitch to another, usually
            indicated by a straight or wavy line.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.gliss.log"/>
            <memberOf key="att.gliss.vis"/>
            <memberOf key="att.gliss.ges"/>
            <memberOf key="att.gliss.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="gliss_start-_and_end-type_attributes_required"
            scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:gliss">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the
                  attributes: dur, dur.ges, endid, or tstamp2</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Commonly also called a 'slide'. The term 'glissando' is frequently used to indicate
              both the case where distinct intermediate pitches are produced (as on the piano) and
              the case where they are not (as on the trombone), though the latter is sometimes
              referred to as 'portamento'. The visual appearance of the indicating line may be
              recorded in the <att>lform</att> and <att>lwidth</att> attributes. The starting point
              of the glissando may be indicated by either a <att>startid</att>, <att>tstamp</att>,
                <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the ending point
              may be recorded by either a <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or
                <att>tstamp2</att> attribute. It is a semantic error not to specify one starting and
              one ending type of attribute.</p>
          </remarks>
        </elementSpec>

        <!--<!-\- Add clones of SVG elements to model.graphicprimitives, issue #216 -\->
        <!-\- Add circle element -\->
        <elementSpec ident="circle" module="MEI.usersymbols" mode="add">
          <desc>A circle.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.color"/>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
            <!-\- att.visualoffset attrs place the circle relative to the 
              entity referenced in @startid -\->
            <memberOf key="att.visualoffset"/>
            <!-\- @x & @y record the center of the circle -\->
            <memberOf key="att.xy"/>
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <attDef ident="lcolor" usage="opt">
              <desc>Color of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="lwidth" usage="opt">
              <desc>Width of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.LINEWIDTH"/>
              </datatype>
            </attDef>
            <attDef ident="r" usage="opt">
              <desc>Radius</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>color</att> attribute records the fill color of the circle. Use
                <att>lcolor</att> to capture the color of its boundary line.</p>
          </remarks>
        </elementSpec>
        <!-\- Add ellipse element -\->
        <elementSpec ident="ellipse" module="MEI.usersymbols" mode="add">
          <desc>An ellipse.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.color"/>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
            <!-\- att.visualoffset attrs place the ellipse relative to the entity 
              referenced in @startid -\->
            <memberOf key="att.visualoffset"/>
            <!-\- cs, cy, rx, ry determine the location & extent of the ellipse -\->
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <attDef ident="lcolor" usage="opt">
              <desc>Color of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="lwidth" usage="opt">
              <desc>Width of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.LINEWIDTH"/>
              </datatype>
            </attDef>
            <attDef ident="cx" usage="opt">
              <desc>the x-axis center of the ellipse.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
            <attDef ident="cy" usage="opt">
              <desc>the y-axis center of the ellipse.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
            <attDef ident="rx" usage="req">
              <desc>the length of the ellipse's radius along the x-axis.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
            <attDef ident="ry" usage="req">
              <desc>the length of the ellipse's radius along the y-axis.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>color</att> attribute records the fill color of the ellipse. Use
                <att>lcolor</att> to capture the color of its boundary line.</p>
          </remarks>
        </elementSpec>
        <!-\- Add polyline element -\->
        <elementSpec ident="polyline" module="MEI.usersymbols" mode="add">
          <desc>Defines any shape that consists of only straight lines.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.common"/>
            <memberOf key="att.color"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
            <!-\- att.visualoffset attrs place the starting point of the shape relative 
              to the entity referenced in @startid -\->
            <memberOf key="att.visualoffset"/>
            <!-\- the @points attribute contains the defining points of the shape -\->
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Visual form of the line.</desc>
              <datatype>
                <rng:ref name="data.LINEFORM"/>
              </datatype>
            </attDef>
            <attDef ident="points" usage="opt">
              <desc>describes a polyline as a set of xy coordinates, e.g., 19 45, -32 118.</desc>
              <constraintSpec ident="polylinepoints_constraint" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:polyline[@points]">
                    <sch:assert test="matches(normalize-space(@points),
                      '^[0-9]+(\.[0-9]+)?\s*,\s*([0-9]+(\.[0-9]+)?)((\s+[0-9]+(\.[0-9]+)?\s*,\s*[0-9]+(\.[0-9]+)?)){1,}$')"
                      >The points attribute must contain at least two comma-separated xy
                      coordinates.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="width" usage="opt">
              <desc>Width of the line.</desc>
              <datatype>
                <rng:ref name="data.LINEWIDTH"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <!-\- Add a polygon element -\->
        <elementSpec ident="polygon" module="MEI.usersymbols" mode="add">
          <desc>Defines any shape that has at least three sides.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.common"/>
            <memberOf key="att.color"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
            <!-\- att.visualoffset attrs place the polygon relative to the entity referenced in @startid -\->
            <memberOf key="att.visualoffset"/>
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <!-\- the @points attribute contains the defining points of the shape -\->
            <attDef ident="points" usage="opt">
              <desc>describes a polyline as a set of xy coordinates, e.g., 19 45, -32 118.</desc>
              <constraintSpec ident="polygonpoints_constraint" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:polygon[@points]">
                    <sch:assert test="matches(normalize-space(@points),
                      '^[0-9]+(\.[0-9]+)?\s*,\s*([0-9]+(\.[0-9]+)?)((\s+[0-9]+(\.[0-9]+)?\s*,\s*[0-9]+(\.[0-9]+)?)){2,}$')"
                      >The points attribute must contain at least three comma-separated xy
                      coordinates.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="lcolor" usage="opt">
              <desc>Color of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="lwidth" usage="opt">
              <desc>Width of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.LINEWIDTH"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>color</att> attribute records the fill color of the polygon. Use
                <att>lcolor</att> to capture the color of its boundary line.</p>
          </remarks>
        </elementSpec>
        <!-\- DO NOT add rectangle element as it causes problem interaction between att.coordinated and att. -\->
        <!-\-<elementSpec ident="rectangle" module="MEI.usersymbols" mode="add">
          <desc>A rectangle.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.color"/>
            <memberOf key="att.common"/>
            <!-\\- attrs in att.coordinated capture the defining of the rectangle -\\->
            <memberOf key="att.coordinated"/>
            <!-\\- requires new att.dimensions class -\\->
            <memberOf key="att.dimensions"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2"/>
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <!-\\-<attDef ident="form" usage="opt">
              <desc>Visual form of the line.</desc>
              <datatype>
                <rng:ref name="data.LINEFORM"/>
              </datatype>
            </attDef>-\\->
            <!-\\- @length implies we know the direction of the vector which we 
              can't know without establishing an end point, which in turn makes
              @length redundant.
            -\\->
            <!-\\-<attDef ident="length" usage="opt">
              <desc>Length of the line.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>-\\->
            <attDef ident="lcolor" usage="opt">
              <desc>Color of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="lwidth" usage="opt">
              <desc>Width of the outer boundary.</desc>
              <datatype>
                <rng:ref name="data.LINEWIDTH"/>
              </datatype>
            </attDef>
            <attDef ident="rx" usage="opt">
              <desc>the x-axis radius of a rectangle with rounded corners.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
            <attDef ident="ry" usage="opt">
              <desc>the y-axis radius of a rectangle with rounded corners.</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>color</att> attribute records the fill color of the rectangle. Use
                <att>lcolor</att> to capture the color of its boundary line.</p>
          </remarks>
        </elementSpec>-\->                
        -->

        <!-- Revise content model of figDesc, issue #217 -->
        <!-- THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <elementSpec ident="figDesc" module="MEI.figtable" mode="replace">
          <desc>(figure description) – Contains a brief prose description of the appearance or
            content of a graphic figure, for use when documenting an image without displaying
            it.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.lang"/>
            <memberOf key="model.figDescLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="figDesc_content_constraint" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:figDesc[mei:lg or mei:p or mei:quote or mei:table]">
                <sch:assert test="not(*[../text()[normalize-space()]])">Mixed content is not allowed
                  when lg, p, quote, or table is used.</sch:assert>
                <sch:assert
                  test="not(*[not(local-name() eq 'biblList' or local-name() eq 'castList' or 
                  local-name() eq 'lg' or local-name() eq 'list' or local-name() eq 'p' or 
                  local-name() eq 'quote' or local-name() eq 'table')])"
                  >Unstructured text not allowed when lg, p, quote, or table elements are
                  used.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Best practice suggests the use of controlled vocabulary for figure descriptions.
              Don't confuse this entity with a figure caption. A caption is text primarily intended
              for display with an illustration. It may or may not function as a description of the
              illustration.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>

        <!-- Harmonize content models of biblList, eventList, handList, list, and termList 
        by allowing head and by permitting each item to be preceded by an optional label. biblList
        is also allowed to be recursive, issue #218. -->
        <elementSpec ident="biblList" module="MEI.shared" mode="replace">
          <desc>List of bibliographic references.</desc>
          <classes>
            <memberOf key="att.common"/>
            <!-- Make member of att.bibl -->
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.listLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:group>
                  <rng:optional>
                    <rng:ref name="model.labelLike"/>
                  </rng:optional>
                  <rng:ref name="model.biblLike"/>
                </rng:group>
                <rng:ref name="biblList"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="handList" module="MEI.header" mode="replace">
          <desc>Container for one or more hand elements.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.physDescPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:optional>
                <rng:ref name="model.labelLike"/>
              </rng:optional>
              <rng:ref name="hand"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="list" module="MEI.text" mode="replace">
          <desc>A formatting element that contains a series of items separated from one another and
            arranged in a linear, often vertical, sequence.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.listLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:optional>
                <rng:ref name="model.labelLike"/>
              </rng:optional>
              <rng:ref name="li"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="list_type_constraint" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:list[@type='gloss']">
                <sch:assert test="count(mei:label) = count(mei:li)">In a list of type "gloss" all
                  items must be immediately preceded by a label.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Used to indicate the format of a list. In a "simple" list, <gi scheme="MEI"
                  >li</gi> elements are not numbered or bulleted. In a "marked" list, the sequence
                of the list items is not critical, and a bullet, box, dash, or other character is
                displayed at the start of each <gi scheme="MEI">item</gi>. In an "ordered" list, the
                sequence of the items is important, and each <gi scheme="MEI">li</gi> is lettered or
                numbered. Style sheet functions should be used to specify the mark or numeration
                system for each <gi scheme="MEI">li</gi>.</desc>
              <valList type="closed">
                <valItem ident="simple">
                  <desc>Items are not numbered or bulleted.</desc>
                </valItem>
                <valItem ident="marked">
                  <desc>Bullet, box, dash, or other character is displayed before each item.</desc>
                </valItem>
                <valItem ident="ordered">
                  <desc>Each item is numbered or lettered.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="type" usage="opt">
              <desc>Captures the nature of the content of a list.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <valList type="semi">
                <valItem ident="gloss">
                  <desc>Each list item glosses some term or concept, which is given by a label
                    element preceding the list item.</desc>
                </valItem>
                <valItem ident="index">
                  <desc>Each list item is an entry in an index such as the alphabetical topical
                    index at the back of a print volume.</desc>
                </valItem>
                <valItem ident="instructions">
                  <desc>Each list item is a step in a sequence of instructions, as in a
                    recipe.</desc>
                </valItem>
                <valItem ident="litany">
                  <desc>Each list item is one of a sequence of petitions, supplications or
                    invocations, typically in a religious ritual.</desc>
                </valItem>
                <valItem ident="syllogism">
                  <desc>Each list item is part of an argument consisting of two or more propositions
                    and a final conclusion derived from them.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>In a list of type "gloss" it is a semantic error not to precede each list item
                  with a label.</p>
              </remarks>
            </attDef>
          </attList>
          <remarks>
            <p>This element is modelled on elements in Encoded Archival Description (EAD), Text
              Encoding Initiative (TEI), and HTML standards.</p>
          </remarks>
        </elementSpec>
        <!-- Enforce constraints on attribute targets, issue #226 -->
        <elementSpec ident="termList" module="MEI.header" mode="replace">
          <desc>Collection of text phrases which describe a resource.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.classcodeident"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:optional>
                <rng:ref name="model.labelLike"/>
              </rng:optional>
              <rng:ref name="term"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>

        <!-- Allow <lg> in <p>, issue #219 -->
        <classSpec ident="model.lgLike" module="MEI.text" type="model" mode="replace">
          <desc>Groups elements that have a line-grouping function.</desc>
          <classes>
            <memberOf key="model.paracontentPart"/>
            <memberOf key="model.textcomponentLike"/>
          </classes>
        </classSpec>

        <!-- Move <head> to MEI.shared since it occurs in multiple modules, issue #220 -->
        <elementSpec ident="head" module="MEI.shared" mode="replace">
          <desc>(heading) – Contains any heading, for example, the title of a section of text, or
            the heading of a list.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.headLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>One or more <gi scheme="MEI">head</gi> elements usually identify the parent element
              and/or its purpose.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in Encoded Archival Description (EAD), Text
              Encoding Initiative (TEI), and HTML standards.</p>
          </remarks>
        </elementSpec>

        <!-- Revise usage of <head>: allow multiple head elements, allow head in more places, issue #221 -->
        <!-- add schematron to disallow mixing of structured and unstructured text -->
        <!-- ADDED SCHEMATRON IN ANNOT, EVENT, AND INSTRVOICEGRP BREAKS BACKWARD COMPATIBILITY! -->
        <elementSpec ident="annot" module="MEI.shared" mode="replace">
          <desc>(annotation) – Provides a short statement explaining the text or indicating the
            basis for an assertion.</desc>
          <classes>
            <memberOf key="att.bibl"/>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.source"/>
            <memberOf key="att.annot.log"/>
            <memberOf key="att.annot.vis"/>
            <memberOf key="att.annot.ges"/>
            <memberOf key="att.annot.anl"/>
            <memberOf key="att.plist"/>
            <memberOf key="att.responsibility"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.annotLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.headLike"/>
                <rng:ref name="model.textcomponentLike"/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="annot_content_constraint" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:annot[mei:head or mei:lg or mei:p or mei:quote or mei:table]">
                <sch:assert test="not(mei:head[preceding-sibling::*[not(local-name()='head')]])"
                  >Head elements can only occur at the start of annot.</sch:assert>
                <sch:assert test="not(*[../text()[normalize-space()]])">Mixed content is not allowed
                  when head, lg, p, quote, or table is used.</sch:assert>
                <sch:assert
                  test="not(*[not(local-name() eq 'biblList' or local-name() eq 'castList' or local-name() eq 'head' or 
                  local-name() eq 'lg' or local-name() eq 'list' or local-name() eq 'p' or local-name() eq 'quote' or 
                  local-name() eq 'table')])"
                  >Unstructured text not allowed when head, lg, p, quote, or table elements are
                  used.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>The <gi scheme="MEI">annot</gi> element can be used for both general comments and for
              annotations of the musical text. It provides a way to group participating *events*
              and/or *control events*, for example, the notes that form a descending bass line, and
              provide a label for and comment regarding the group. Participating entities may be
              identified in the <att>plist</att> attribute. An editorial or analytical comment or
              observation may be included directly within the <gi scheme="MEI">annot</gi> element.
              The starting point of the annotation may be indicated by either a <att>tstamp</att>,
                <att>tstamp.ges</att>, <att>tstamp.real</att> or <att>startid</att> attribute, while
              the ending point may be recorded by either a <att>dur</att>, <att>dur.ges</att> or
                <att>endid</att> attribute. The <att>resp</att> attribute records the editor(s)
              responsible for identifying or creating the annotation.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="castList" module="MEI.shared" mode="replace">
          <desc>Contains a single cast list or dramatis personae.</desc>
          <classes>
            <memberOf key="att.common"/>
            <!-- Make member of att.bibl -->
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.listLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:choice>
                <rng:ref name="castItem"/>
                <rng:ref name="castGrp"/>
              </rng:choice>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="contents" module="MEI.header" mode="replace">
          <desc>Description of the material contained within a resource.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.pointing"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:choice>
              <rng:optional>
                <rng:ref name="model.pLike"/>
              </rng:optional>
              <rng:oneOrMore>
                <rng:optional>
                  <rng:ref name="model.labelLike"/>
                </rng:optional>
                <rng:ref name="contentItem"/>
              </rng:oneOrMore>
            </rng:choice>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:space="preserve">
<contents>
  <p>A suitable tone ; Left hand colouring ; Rhythm and accent ; Tempo ; 
    Flexibility ; Ornaments</p>
</contents>
            </egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:space="preserve">
<contents>
  <head>Contents</head>
  <label>1.</label><contentItem>Sonata in D major, op. V, no. 1 /
     Corelli</contentItem>
  <label>2.</label><contentItem>Sonata in G minor / Purcell (with Robert Donington,
     gamba)</contentItem>
  <label>3.</label><contentItem>Forlane from Concert royal no. 3 /
     Couperin</contentItem>
</contents>
            </egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve">
<contents target="http://www.contentProvider.org/toc/toc01.html"/>
            </egXML>
          </exemplum>
        </elementSpec>
        <elementSpec ident="div" module="MEI.text" mode="replace">
          <desc>(division) – Major structural division of text, such as a preface, chapter or
            section.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <!-- <memberOf key="att.typed"/> -->
            <!-- Expand att.typed/@type to provide suggested values -->
            <memberOf key="model.divLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.milestoneLike.text"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:choice>
                <rng:ref name="model.divLike"/>
                <rng:ref name="model.textcomponentLike"/>
              </rng:choice>
            </rng:oneOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.milestoneLike.text"/>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="type" usage="opt">
              <desc>Characterizes the element in some sense, using any convenient classification
                scheme or typology.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <valList type="semi">
                <valItem ident="abstract">
                  <desc>A summary of the content of a text as continuous prose.</desc>
                </valItem>
                <valItem ident="ack">
                  <desc>A formal declaration of acknowledgement by the author in which persons and
                    institutions are thanked for their part in the creation of a text.</desc>
                </valItem>
                <valItem ident="appendix">
                  <desc>An ancillary self-contained section of a work, often providing additional
                    but in some sense extra-canonical text.</desc>
                </valItem>
                <valItem ident="bibliography">
                  <desc>A list of bibliographic citations.</desc>
                </valItem>
                <valItem ident="colophon">
                  <desc>A statement appearing at the end of a book describing the conditions of its
                    physical production.</desc>
                </valItem>
                <valItem ident="contents">
                  <desc>A table of contents, specifying the structure of a work and listing its
                    constituents. The list element should be used to mark its structure.</desc>
                </valItem>
                <valItem ident="dedication">
                  <desc>A formal offering or dedication of a text to one or more persons or
                    institutions by the author.</desc>
                </valItem>
                <valItem ident="frontispiece">
                  <desc>A pictorial frontispiece, possibly including some text.</desc>
                </valItem>
                <valItem ident="glossary">
                  <desc>A list of terms associated with definition texts (‘glosses’).</desc>
                </valItem>
                <valItem ident="half-title">
                  <desc>A page containing only the title of a book — as opposed to the title page,
                    which also lists subtitle, author, imprint and similar data.</desc>
                </valItem>
                <valItem ident="index">
                  <desc>Any form of index to the work.</desc>
                </valItem>
                <valItem ident="annotations">
                  <desc>A section in which annotations on the text are gathered together.</desc>
                </valItem>
                <valItem ident="preface">
                  <desc>A foreword or preface addressed to the reader in which the author or
                    publisher explains the content, purpose, or origin of the text.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" usage="opt">
              <desc>Provide any sub-classification for the element, additional to that given by its
                type attribute.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="event" module="MEI.header" mode="replace">
          <desc>Contains a description of an event, including the dates and locations of its
            occurrence and prominent participants.</desc>
          <!-- This model allows for both semi-structured (using only model.eventPart members) and
            "free" descriptions (using p, table, list, and castList) as well as a mixture of
            the two approaches. -->
          <classes>
            <memberOf key="att.bibl"/>
            <memberOf key="att.calendared"/>
            <memberOf key="att.common"/>
            <memberOf key="att.datable"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.eventPart"/>
                <rng:ref name="model.pLike"/>
                <rng:ref name="model.tableLike"/>
                <rng:ref name="list"/>
                <rng:ref name="castList"/>
              </rng:choice>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="biblList"/>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <elementSpec ident="eventList" module="MEI.header" mode="replace">
          <desc>Contains historical information given as a sequence of significant past
            events.</desc>
          <classes>
            <memberOf key="att.bibl"/>
            <memberOf key="att.common"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="event"/>
            </rng:oneOrMore>
            <rng:zeroOrMore>
              <rng:ref name="biblList"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>An <gi scheme="MEI">eventList</gi> contains <gi scheme="MEI">event</gi> elements that
              capture a brief description of the associated event, including dates and locations
              where the event took place. An <gi scheme="MEI">eventList</gi> describes events
              associated with a work when it appears in the <gi scheme="MEI">workDesc</gi> element
              or events associated with the custodial history of a given copy of a source for the
              encoding when it appears within the <gi scheme="MEI">source</gi> or <gi scheme="MEI"
                >relatedItem</gi> elements. The <att>type</att> attribute may be used to distinguish
              between event lists with different functions, such as a list of events in the
              compositional process and a list of performance dates.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="history" module="MEI.header" mode="replace">
          <desc>Provides a container for information about the creation and history of a
            resource.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="creation"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="eventList"/>
                <rng:ref name="p"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <!-- instrumentation and its subelements should allow att.edit, issue #227 -->
        <!-- rename instrVoice and instrVoiceGrp to perfRes (performance resource) and
          perfResList, respectively. Delete ensemble and instrumentation and ensemble, 
          allowing the content of the former instrVoiceGrp to occur directly within
          perfMedium. Disallow text content within perfResList. In addition, make former
          members of att.coded members of att.canonical instead. -->
        <!-- THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <elementSpec ident="instrumentation" module="MEI.header" mode="delete"/>
        <elementSpec ident="ensemble" module="MEI.header" mode="delete"/>
        <elementSpec ident="instrVoice" module="MEI.header" mode="delete"/>
        <elementSpec ident="instrVoiceGrp" module="MEI.header" mode="delete"/>
        <elementSpec ident="perfResList" module="MEI.header" mode="add">
          <desc>Several instrumental or vocal resources treated as a group.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.canonical"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.lang"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="perfRes"/>
                <rng:ref name="perfResList"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="count" usage="opt">
              <desc>Indicates the number of performers.</desc>
              <datatype>
                <rng:data type="positiveInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The function of instrumentalists or vocalists is represented by the choice of <gi
                scheme="MEI">perfRes</gi> and <gi scheme="MEI">perfResList</gi> child elements.
              Arrangements are coded for the medium of the work being described, not for the
              original medium.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="perfRes" module="MEI.header" mode="add">
          <desc>(performance resource) – Name of an instrument on which a performer plays, a
            performer's voice range, or a standard performing ensemble designation.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.canonical"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.lang"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="count" usage="opt">
              <desc>Indicates the number of performers.</desc>
              <datatype>
                <rng:data type="positiveInteger"/>
              </datatype>
            </attDef>
            <attDef ident="solo" usage="opt">
              <desc>Marks this instrument or vocal part as a soloist. Do not use this attribute for
                a solo instrument which is not accompanied.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <!-- Replace references to instrVoice and instrVoiceGrp in castItem and incip elements -->
        <elementSpec ident="castItem" module="MEI.shared" mode="replace">
          <desc>Contains a single entry within a cast list, describing either a single role or a
            list of non-speaking roles.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
          </classes>
          <content>
            <rng:oneOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="role"/>
                <rng:ref name="roleDesc"/>
                <rng:ref name="actor"/>
                <rng:ref name="perfRes"/>
              </rng:choice>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="incip" module="MEI.shared" mode="replace">
          <desc>(incipit) – The opening music and/or words of a composition.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.incipLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="tempo"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="role"/>
            </rng:optional>
            <rng:optional>
              <rng:choice>
                <rng:ref name="clef"/>
                <rng:ref name="clefGrp"/>
              </rng:choice>
            </rng:optional>
            <rng:optional>
              <rng:choice>
                <rng:ref name="perfRes"/>
                <rng:ref name="perfResList"/>
              </rng:choice>
            </rng:optional>
            <rng:optional>
              <rng:ref name="key"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="meter"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="mensuration"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="incipCode"/>
                <rng:ref name="incipText"/>
                <rng:ref name="model.scoreLike"/>
                <rng:ref name="model.graphicLike"/>
                <rng:ref name="annot"/>
                <!-- 
              Can XSLT be used here to "select" an incipit from the already-encoded MEI transcription in the music element?
              <rng:ref name="macro.XSLT"/> 
            -->
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <gi scheme="MEI">incipText</gi> element may be used to capture a text incipit,
              while <gi scheme="MEI">score</gi> is available to provide an MEI-encoded musical
              incipit. Images of an incipit may be referenced using the <gi scheme="MEI"
                >graphic</gi> element. An incipit encoded in a text format other than MEI may be
              placed in the <gi scheme="MEI">incipCode</gi> element.</p>
          </remarks>
        </elementSpec>

        <!-- merge @dbkey and @code into att.canonical/@codedval -->
        <classSpec ident="att.coded" module="MEI.shared" type="atts" mode="delete"/>
        <classSpec ident="att.canonical" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that can be used to associate a representation such as a name or title
            with canonical information about the object being named or referenced.</desc>
          <attList>
            <attDef ident="codedval" usage="opt">
              <desc>a value that represents or identifies the element content. May serve as a
                primary key in a web-accessible database identified by the authURI attribute.</desc>
              <datatype maxOccurs="unbounded">
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec ident="resp" module="MEI.shared" mode="replace">
          <desc>(responsibility) – A phrase describing the nature of intellectual
            responsibility.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.canonical"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
          </classes>
          <content>
            <rng:text/>
          </content>
          <remarks>
            <p>The name of the list from which a controlled value is taken may be recorded using the
                <att>authority</att> attribute.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="lg" module="MEI.text" mode="replace">
          <desc>(line group) – May be used for any section of text that is organized as a group of
            lines; however, it is most often used for a group of verse lines functioning as a formal
            unit, e.g. a stanza, refrain, verse paragraph, etc.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.lgLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:choice>
              <rng:ref name="model.lLike"/>
              <rng:ref name="model.lgLike"/>
            </rng:choice>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.lLike"/>
                <rng:ref name="model.lgLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="notesStmt" module="MEI.header" mode="replace">
          <desc>(notes statement)– Collects any notes providing information about a text additional
            to that recorded in other parts of the bibliographic description.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="model.annotLike"/>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="perfMedium" module="MEI.header" mode="replace">
          <desc>(performance medium) – Indicates the number and character of the performing forces
            used in a musical composition.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.authorized"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="castList"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="perfResList"/>
            </rng:optional>
            <!-- Add <annot> -->
            <rng:zeroOrMore>
              <rng:ref name="model.annotLike"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p> Arrangements are coded for the medium of the work being described, not for the
              original medium.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="sourceDesc" module="MEI.header" mode="replace">
          <desc>(source description) – A container for the descriptions of the source(s) used in the
            creation of the electronic file.</desc>
          <classes>
            <memberOf key="att.common"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.headLike"/>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:ref name="source"/>
            </rng:oneOrMore>
          </content>
          <remarks>
            <p>This element is recommended where the MEI file is a transcription of existing music,
              but is not required when the data is originally created in MEI form.</p>
          </remarks>
        </elementSpec>

        <!-- Enforce constraints on attribute targets, issue #226 -->
        <!-- Add constraintSpec to att.altsym, move att.altsym to MEI.usersymbols -->
        <classSpec ident="att.altsym" module="MEI.usersymbols" type="atts" mode="replace">
          <desc>Attributes supplying pointers to user-defined symbols.</desc>
          <attList>
            <attDef ident="altsym" usage="opt">
              <desc>Provides a way of pointing to a user-defined symbol. It must contain an ID of a
                &lt;symbolDef&gt; element elsewhere in the document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_altsymTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@altsym">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@altsym
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:symbolDef/@xml:id"
                      >The value in @altsym must correspond to the @xml:id attribute of a symbolDef
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.common.anl -->
        <classSpec ident="att.common.anl" module="MEI.analysis" type="atts" mode="replace">
          <desc>Common analytical attributes. When the MEI.performance module is used, the when
            attribute is also a member of this attribute class.</desc>
          <classes>
            <memberOf key="att.alignment"/>
          </classes>
          <attList>
            <attDef ident="copyof" usage="opt">
              <desc>Points to an element of which the current element is a copy.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="When_copyof_element_empty" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:*[@copyof]">
                    <sch:assert test="count(child::node()) = 0">An element with a copyof attribute
                      cannot have content.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <constraintSpec ident="check_copyofTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@copyof">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@copyof
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >The value in @copyof must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="corresp" usage="opt">
              <desc>Used to point to other elements that correspond to this one in a generic
                fashion.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_correspTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@corresp">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@corresp
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @corresp must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="next" usage="opt">
              <desc>Used to point to the next event(s) in a user-defined collection.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_nextTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@next">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@next attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @next must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="prev" usage="opt">
              <desc>Points to the previous event(s) in a user-defined collection.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_prevTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@prev">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@prev attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @prev must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="sameas" usage="opt">
              <desc>Points to an element that is the same as the current element but is not a
                literal copy of the current element.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_sameasTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@sameas">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@sameas
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @sameas must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="synch" usage="opt">
              <desc>Points to elements that are synchronous with the current element.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_synchTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@synch">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@synch attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @synch must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Create new att.classcodeident class -->
        <classSpec ident="att.classcodeident" module="MEI.shared" type="atts" mode="add">
          <attList>
            <attDef ident="classcode" usage="opt">
              <desc>Contains a reference to the controlled vocabulary from which the term is drawn.
                The value must match the value of an ID attribute on a classCode element given
                elsewhere in the document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_classcodeTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@classcode">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@classcode
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:classCode/@xml:id"
                      >The value in @classcode must correspond to the @xml:id attribute of a
                      classCode element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make term member of att.classcodeident -->
        <elementSpec ident="term" module="MEI.header" mode="replace">
          <desc>Keyword or phrase which describes a resource.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.classcodeident"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="term"/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <att>classcode</att> attribute may be used to link the term to a terminological
              source given in a <gi scheme="MEI">classCode</gi> element. The <gi scheme="MEI"
                >term</gi> element may include other <gi scheme="MEI">term</gi> elements in order to
              allow the creation of coordinated terms; i.e., terms created from a combination of
              other, independent terms.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <!-- Add constraintSpec in att.custos.log -->
        <classSpec ident="att.custos.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.pitched"/>
          </classes>
          <attList>
            <attDef ident="target" usage="opt">
              <desc>Encodes the target note when its pitch differs from the pitch at which the
                custos appears.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_goalTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:custos/@target">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@target
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:note/@xml:id"
                      >The value in @target must correspond to the @xml:id attribute of a note
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.datapointing -->
        <classSpec ident="att.datapointing" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes for linking metadata to data.</desc>
          <attList>
            <attDef ident="data" usage="opt">
              <desc>Used to link metadata elements to one or more data-containing elements.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_dataTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@data">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@data attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:music]/@xml:id"
                      >The value in @data must correspond to the @xml:id attribute of a descendant
                      of the music element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.declaring -->
        <classSpec ident="att.declaring" module="MEI.shared" type="atts" mode="replace">
          <desc>Provides attributes for elements which may be associated with particular contextual
            elements within the header.</desc>
          <attList>
            <attDef ident="decls" usage="opt">
              <desc>Identifies one or more metadata elements within the header, which are understood
                to apply to the element bearing this attribute and its content.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_dataTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@decls">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@decls attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
                      >Each value in @decls must correspond to the @xml:id attribute of an element
                      within the metadata header.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.facsimile -->
        <classSpec ident="att.facsimile" module="MEI.facsimile" type="atts" mode="replace">
          <desc>Attributes that associate a feature corresponding with all or part of an
            image.</desc>
          <attList>
            <attDef ident="facs" usage="opt">
              <desc>Permits the current element to reference a facsimile surface or image zone which
                corresponds to it.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_facsTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@facs">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@facs attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'surface' or local-name() eq 'zone']/@xml:id"
                      >Each value in @facs must correspond to the @xml:id attribute of a surface or
                      zone element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.handident -->
        <classSpec ident="att.handident" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes which identify a document hand.</desc>
          <attList>
            <attDef ident="hand" usage="opt">
              <desc>Signifies the hand responsible for an action. The value must be the ID of a
                &lt;hand&gt; element declared in the header.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_handTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@hand">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@hand attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
                      >Each value in @hand must correspond to the @xml:id attribute of a hand
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.harm.log -->
        <classSpec ident="att.harm.log" module="MEI.harmony" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
          <attList>
            <attDef ident="chordref" usage="opt">
              <desc>Contains a reference to a &lt;chordDef&gt; element elsewhere in the
                document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_chordrefTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@chordref">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@chordref
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:chordDef/@xml:id"
                      >The value in @chordref must correspond to the @xml:id attribute of a chordDef
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.instrumentident -->
        <classSpec ident="att.instrumentident" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes which identify a MIDI instrument.</desc>
          <attList>
            <attDef ident="instr" usage="opt">
              <desc>Provides a way of pointing to a MIDI instrument definition. It must contain the
                ID of an &lt;instrDef&gt; element elsewhere in the document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_instrTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@instr">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@instr attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:instrDef/@xml:id"
                      >The value in @instr must correspond to the @xml:id attribute of an instrDef
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.joined -->
        <classSpec ident="att.joined" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes indicating that elements are semantically linked; that is, while the
            parts are encoded separately, together they may be thought of as a single intellectual
            object.</desc>
          <attList>
            <attDef ident="join" usage="opt">
              <desc>Used for linking visually separate entities that form a single logical entity,
                for example, multiple slurs broken across a system break that form a single musical
                phrase. Also used to indicate a measure which metrically completes the current one.
                Record the identifiers of the separately encoded components, excluding the one
                carrying the attribute.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_joinTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@join">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@join attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @join must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.layer.log -->
        <classSpec ident="att.layer.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.meterconformance"/>
          </classes>
          <attList>
            <attDef ident="def" usage="opt">
              <desc>Provides a mechanism for linking the layer to a layerDef element.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_defTarget_layer" scheme="isoschematron">
                <constraint>
                  <sch:rule context="layer/@def">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@def attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:layerDef/@xml:id"
                      >The value in @def must correspond to the @xml:id attribute of a layerDef
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.plist -->
        <classSpec ident="att.plist" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes listing the participants in a user-defined collection.</desc>
          <attList>
            <attDef ident="plist" usage="opt">
              <desc>Contains a space separated list of references that identify logical events that
                participate in a collection, such as notes under a phrase mark.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_plistTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@plist">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@plist attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >Each value in @plist must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="evaluate" usage="opt">
              <desc>Specifies the intended meaning when the target of a pointer is itself a
                pointer.</desc>
              <valList type="closed">
                <valItem ident="all">
                  <desc>If the element pointed to is itself a pointer, then the target of that
                    pointer will be taken, and so on, until an element is found which is not a
                    pointer.</desc>
                </valItem>
                <valItem ident="one">
                  <desc>If the element pointed to is itself a pointer, then its target (whether a
                    pointer or not) is taken as the target of this pointer.</desc>
                </valItem>
                <valItem ident="none">
                  <desc>No further evaluation of targets is carried out beyond that needed to find
                    the element specified in the pointer's target.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>If no value is given, the application program is responsible for deciding
                  (possibly on the basis of user input) how far to trace a chain of pointers.</p>
              </remarks>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.source -->
        <classSpec ident="att.source" module="MEI.critapp" type="atts" mode="replace">
          <desc>Attributes common to elements that may refer to a source.</desc>
          <attList>
            <attDef ident="source" usage="opt">
              <desc>Contains a list of one or more pointers indicating the sources which attest to a
                given reading. Each value should correspond to the ID of a &lt;source&gt; element
                located in the document header.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_sourceTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@source">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@source
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:source/@xml:id"
                      >Each value in @source must correspond to the @xml:id attribute of a source
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.staff.log -->
        <classSpec ident="att.staff.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.meterconformance"/>
          </classes>
          <attList>
            <attDef ident="def" usage="opt">
              <desc>Provides a mechanism for linking the staff to a staffDef element.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_defTarget_staff" scheme="isoschematron">
                <constraint>
                  <sch:rule context="staff/@def">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@def attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:staffDef/@xml:id"
                      >The value in @def must correspond to the @xml:id attribute of a staffDef
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.startendid -->
        <classSpec ident="att.startendid" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes recording the identifiers of the first and last elements of a sequence of
            elements to which the current element is associated.</desc>
          <classes>
            <memberOf key="att.startid"/>
          </classes>
          <attList>
            <attDef ident="endid" usage="opt">
              <desc>Indicates the final element in a sequence of events to which the feature
                applies.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_endidTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@endid">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@endid attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >The value in @endid must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec in att.start -->
        <classSpec ident="att.startid" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that identify a relative starting point.</desc>
          <attList>
            <attDef ident="startid" usage="opt">
              <desc>Holds a reference to the first element in a sequence of events to which the
                feature applies.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_startidTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@startid">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@startid
                      attribute has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
                      >The value in @startid must correspond to the @xml:id attribute of an
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec to att.responsibility -->
        <classSpec ident="att.responsibility" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes capturing information regarding responsibility for some aspect of the
            text's creation, transcription, editing, or encoding.</desc>
          <constraintSpec ident="check_respTarget" scheme="isoschematron">
            <constraint>
              <sch:rule context="@resp">
                <sch:assert role="warning" test="not(normalize-space(.) eq '')">@resp attribute has
                  no content.</sch:assert>
                <sch:assert role="warning"
                  test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
                  >The value in @resp must correspond to the @xml:id attribute of an element within
                  the metadata header.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="resp" usage="opt">
              <desc>Captures information regarding responsibility for some aspect of the text's
                creation, transcription, editing, or encoding. Its value must point to one or more
                identifiers declared in the document header.</desc>
              <datatype>
                <rng:ref name="data.URIS"/>
              </datatype>
              <constraintSpec ident="check_respTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@resp">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@resp attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
                      >The value in @resp must correspond to the @xml:id attribute of an element
                      within the metadata header.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add constraintSpec to handShift -->
        <elementSpec ident="handShift" module="MEI.edittrans" mode="replace">
          <desc>Marks the beginning of a passage written in a new hand, or of a change in the
            scribe, writing style, ink or character of the document hand.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.medium"/>
            <memberOf key="model.transcriptionLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <attList>
            <attDef ident="character" usage="opt">
              <desc>Describes the character of the new hand.</desc>
              <datatype>
                <rng:text/>
              </datatype>
            </attDef>
            <attDef ident="new" usage="opt">
              <desc>Identifies the new hand. The value must contain the ID of a hand element given
                elsewhere in the document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_newTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@new">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@new attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
                      >The value in @new must correspond to the @xml:id attribute of a hand
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
            <attDef ident="old" usage="opt">
              <desc>Identifies the old hand. The value must contain the ID of a hand element given
                elsewhere in the document.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
              <constraintSpec ident="check_oldTarget" scheme="isoschematron">
                <constraint>
                  <sch:rule context="@old">
                    <sch:assert role="warning" test="not(normalize-space(.) eq '')">@old attribute
                      has no content.</sch:assert>
                    <sch:assert role="warning"
                      test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
                      >The value in @old must correspond to the @xml:id attribute of a hand
                      element.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>character</att> attribute describes characteristics of the hand,
              particularly those related to the quality of the writing, e.g., 'shaky', 'thick',
              regular'. A description of the tint or type of ink, e.g. 'brown' or the writing
              medium, e.g. 'pencil', may be placed in the <att>medium</att> attribute. The new hand
              may be identified using the <att>new</att> attribute, while the previous hand may be
              recorded in the <att>old</att> attribute. The <att>resp</att> attribute contains an ID
              reference to an element containing the name of the editor or transcriber responsible
              for identifying the change of hand. The <att>cert</att> attribute signifies the degree
              of certainty ascribed to the identification of the new hand.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>

        <elementSpec ident="expression" module="MEI.frbr" mode="replace">
          <desc>Intellectual or artistic realization of a work.</desc>
          <classes>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="model.expressionLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.identifierLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="titleStmt"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="model.workIdent"/>
            </rng:zeroOrMore>
            <!-- Allow otherChar to be repeatable -->
            <rng:zeroOrMore>
              <rng:ref name="otherChar"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="history"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="langUsage"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="perfMedium"/>
            </rng:optional>
            <!-- Allow extent to be repeatable -->
            <rng:zeroOrMore>
              <rng:ref name="extent"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="scoreFormat"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="contents"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="context"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="biblList"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="notesStmt"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="classification"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="componentGrp"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="relationList"/>
            </rng:optional>
          </content>
        </elementSpec>
        <!-- Do some re-ordering to better align with work and expression content. -->
        <!-- THIS CHANGE BREAKS BACKWARD COMPATIBILITY! -->
        <elementSpec ident="source" module="MEI.header" mode="replace">
          <desc>A bibliographic description of a source used in the creation of the electronic
            file.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.pointing"/>
            <memberOf key="model.manifestationLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.identifierLike"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="titleStmt"/>
            </rng:optional>
            <rng:ref name="macro.bibldescPart"/>
            <rng:optional>
              <rng:ref name="langUsage"/>
            </rng:optional>
            <!-- Allow repeatable <perfMedium> within <source>? -->
            <!--<rng:zeroOrMore>
              <rng:ref name="perfMedium"/>
            </rng:zeroOrMore>-->
            <rng:optional>
              <rng:ref name="contents"/>
            </rng:optional>
            <rng:zeroOrMore>
              <rng:ref name="biblList"/>
            </rng:zeroOrMore>
            <rng:optional>
              <rng:ref name="notesStmt"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="classification"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="itemList"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="componentGrp"/>
            </rng:optional>
            <rng:optional>
              <rng:ref name="relationList"/>
            </rng:optional>
          </content>
          <remarks>
            <p>Multiple <gi scheme="MEI">physDesc</gi> sub-elements may be used to describe the
              physically separate parts of a single source. The <att>data</att> attribute may be
              used to reference one or more features that occur in this particular source. A URI
              referencing a description of the related item may be placed in the <att>target</att>
              attribute.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Text Encoding Initiative (TEI) and
              Encoded Archival Description (EAD) standards.</p>
          </remarks>
        </elementSpec>
        <!-- Make <scoreFormat> a member of model.physDescPart -->
        <elementSpec ident="scoreFormat" module="MEI.header" mode="replace">
          <desc>Describes the type of score used to represent a musical composition (e.g., short
            score, full score, condensed score, close score, etc.).</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.authorized"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="model.physDescPart"/>
          </classes>
          <content>
            <rng:text/>
          </content>
        </elementSpec>

        <!-- Allow app within verse, issue #228 -->
        <elementSpec ident="verse" module="MEI.lyrics" mode="replace">
          <desc>Lyric verse.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.verse.log"/>
            <memberOf key="att.verse.vis"/>
            <memberOf key="att.verse.ges"/>
            <memberOf key="att.verse.anl"/>
            <memberOf key="model.verseLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="dir"/>
                <rng:ref name="dynam"/>
                <rng:ref name="tempo"/>
                <rng:ref name="space"/>
              </rng:choice>
            </rng:zeroOrMore>
            <rng:oneOrMore>
              <rng:choice>
                <rng:ref name="model.sylLike"/>
                <rng:ref name="model.appLike"/>
              </rng:choice>
            </rng:oneOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.lbLike"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <gi scheme="MEI">lb</gi> element is allowed here in order to facilitate karaoke
              applications. The <att>func</att> attribute on <gi scheme="MEI">lb</gi> may be used to
              distinguish true line endings from those of line groups for these applications.</p>
          </remarks>
        </elementSpec>

        <!-- Allow staffDef to specify the type [and subtype] of notation that occurs on it, issue #229 -->
        <!-- Add datatype -->
        <macroSpec ident="data.NOTATIONTYPE" module="MEI" type="dt" mode="add">
          <desc>Notation type and subtype</desc>
          <content>
            <valList type="closed">
              <valItem ident="cmn">
                <desc>Common Music Notation.</desc>
              </valItem>
              <valItem ident="mensural">
                <desc>Mensural notation.</desc>
              </valItem>
              <valItem ident="mensural.black">
                <desc>Black mensural notation.</desc>
              </valItem>
              <valItem ident="mensural.white">
                <desc>White mensural notation.</desc>
              </valItem>
              <valItem ident="neume">
                <desc>Neumatic notation.</desc>
              </valItem>
              <!--<valItem ident="neume.heighted"><desc>Heighted neumatic notation</desc></valItem>
              <valItem ident="neume.unheighted"><desc>Unheighted neumatic notation</desc></valItem>-->
              <valItem ident="tab">
                <desc>Tablature notation.</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>
        <!-- Add notationtype attribute class -->
        <classSpec ident="att.notationtype" module="MEI" type="atts" mode="add">
          <desc>Attributes that provide for classification of notation.</desc>
          <attList>
            <attDef ident="notationtype" usage="opt">
              <desc>Contains classification of the notation contained or described by the element
                bearing this attribute.</desc>
              <datatype>
                <rng:ref name="data.NOTATIONTYPE"/>
              </datatype>
            </attDef>
            <attDef ident="notationsubtype" usage="opt">
              <desc>Provides any sub-classification of the notation contained or described by the
                element, additional to that given by its notationtype attribute.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <constraintSpec ident="When_notationsubtype" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:*[@notationsubtype]">
                    <sch:assert test="@notationtype">An element with a notationsubtype attribute
                      must have a notationtype attribute.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make att.staffDef.log a member of att.notationtype -->
        <classSpec ident="att.staffDef.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes for staffDef.</desc>
          <classes>
            <memberOf key="att.cleffing.log"/>
            <memberOf key="att.duration.default"/>
            <memberOf key="att.keySigDefault.log"/>
            <memberOf key="att.meterSigDefault.log"/>
            <memberOf key="att.notationtype"/>
            <memberOf key="att.octavedefault"/>
            <memberOf key="att.transposition"/>
            <memberOf key="att.staffDef.log.cmn"/>
            <memberOf key="att.staffDef.log.mensural"/>
          </classes>
        </classSpec>

        <!-- Restrict @n to positive integer values, issue #248  -->
        <elementSpec ident="staff" module="MEI.shared" mode="replace">
          <desc>A group of equidistant horizontal lines on which notes are placed in order to
            represent pitch or a grouping element for individual 'strands' of notes, rests, etc.
            that may or may not actually be rendered on staff lines; that is, both diastematic and
            non-diastematic signs.</desc>
          <classes>
            <memberOf key="att.commonPart"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.staff.log"/>
            <memberOf key="att.staff.vis"/>
            <memberOf key="att.staff.ges"/>
            <memberOf key="att.staff.anl"/>
            <memberOf key="model.staffLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.appLike"/>
                <rng:ref name="model.divLike"/>
                <rng:ref name="model.milestoneLike.music"/>
                <rng:ref name="model.annotLike"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.staffPart"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="n" usage="opt">
              <desc>A non-negative integer value functioning as a "name".</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The <att>def</att> attribute may be used to create a connection with a <gi
                scheme="MEI">staffDef</gi> element where logical and visual information about the
              staff is recorded. Alternatively, the <att>n</att> attribute may be used as a
              reference to a <gi scheme="MEI">staffDef</gi> element with the same value in its
                <att>n</att> attribute. If neither <att>def</att> nor <att>n</att> attributes are
              present, then the encoding order of the staves is presumed to match the encoding order
              of the staff defintions.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="staffDef" module="MEI.shared" mode="replace">
          <desc>(staff definition) – Container for staff meta-information.</desc>
          <classes>
            <memberOf key="att.commonPart"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.staffDef.log"/>
            <memberOf key="att.staffDef.vis"/>
            <memberOf key="att.staffDef.ges"/>
            <memberOf key="att.staffDef.anl"/>
            <memberOf key="model.staffDefLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.labelLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.instrDefLike"/>
                <rng:ref name="model.layerDefLike"/>
                <rng:ref name="model.staffDefPart"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="Check_staffDefn" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef">
                <sch:let name="thisstaff" value="@n"/>
                <sch:assert test="@n">A staffDef must have an n attribute.</sch:assert>
                <sch:assert test="@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]">The
                  first occurrence of a staff must declare the number of staff lines.</sch:assert>
                <sch:assert test="count(mei:clef) + count(mei:clefGrp) &lt; 2">Only one clef or
                  clefGrp is permitted.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_ancestor_staff" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef[ancestor::mei:staff]">
                <sch:let name="thisstaff" value="@n"/>
                <sch:assert test="ancestor::mei:staff/@n eq $thisstaff">If a staffDef appears in a
                  staff, it must bear the same @n than this staff.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_clef_position_staffDef" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef[@clef.line and @lines]">
                <sch:assert test="number(@clef.line) &lt;= number(@lines)">The clef position must be
                  less than or equal to the number of lines on the staff.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_clef_position_staffDef_nolines" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef[@clef.line and not(@lines)]">
                <sch:let name="thisstaff" value="@n"/>
                <sch:let name="stafflines"
                  value="preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"/>
                <sch:assert test="number(@clef.line) &lt;= number($stafflines)">The clef position
                  must be less than or equal to the number of lines on the staff.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_tab_strings_lines" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef[@tab.strings and @lines]">
                <sch:let name="countTokens"
                  value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
                <sch:assert test="$countTokens = 1 or $countTokens = @lines">The tab.strings
                  attribute must have the same number of values as there are staff
                  lines.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_tab_strings_nolines" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:staffDef[@tab.strings and not(@lines)]">
                <sch:let name="countTokens"
                  value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
                <sch:let name="thisStaff" value="@n"/>
                <sch:assert
                  test="$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisStaff and @lines][1]/@lines"
                  >The tab.strings attribute must have the same number of values as there are staff
                  lines.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_lines_color" scheme="isoschematron">
            <constraint>
              <sch:pattern>
                <sch:rule context="mei:staffDef[@lines.color and @lines]">
                  <sch:let name="countTokens"
                    value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
                  <sch:assert test="$countTokens = 1 or $countTokens = @lines">The lines.color
                    attribute must have either 1) a single value or 2) the same number of values as
                    there are staff lines.</sch:assert>
                </sch:rule>
                <sch:rule context="mei:staffDef[@lines.color and not(@lines)]">
                  <sch:let name="countTokens"
                    value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
                  <sch:let name="thisStaff" value="@n"/>
                  <sch:assert
                    test="$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisStaff and @lines][1]/@lines"
                    >The lines.color attribute must have either 1) a single value or 2) the same
                    number of values as there are staff lines.</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_staff_ppq_ancestor" scheme="isoschematron">
            <constraint>
              <sch:pattern>
                <sch:rule context="mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]">
                  <sch:let name="staffPPQ" value="@ppq"/>
                  <sch:let name="scorePPQ" value="ancestor::mei:scoreDef[@ppq][1]/@ppq"/>
                  <sch:assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor
                    of the value of ppq on an ancestor scoreDef.</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="Check_staff_ppq_preceding" scheme="isoschematron">
            <constraint>
              <sch:pattern>
                <sch:rule context="mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]">
                  <sch:let name="staffPPQ" value="@ppq"/>
                  <sch:let name="scorePPQ" value="preceding::mei:scoreDef[@ppq][1]/@ppq"/>
                  <sch:assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor
                    of the value of ppq on a preceding scoreDef.</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="n" usage="opt">
              <desc>A non-negative integer value functioning as a "name".</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="layer" module="MEI.shared" mode="replace">
          <desc>An independent stream of events on a staff.</desc>
          <classes>
            <memberOf key="att.commonPart"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.layer.log"/>
            <memberOf key="att.layer.vis"/>
            <memberOf key="att.layer.ges"/>
            <memberOf key="att.layer.anl"/>
            <memberOf key="model.layerLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.appLike"/>
                <rng:ref name="model.divLike"/>
                <rng:ref name="model.milestoneLike.music"/>
                <rng:ref name="model.annotLike"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.layerPart"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="n" usage="opt">
              <desc>A non-negative integer value functioning as a "name".</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>The term 'layer' is used instead of 'voice' in order to avoid confusion between
              'voice' and 'voice leading' and 'voicing'. The <att>def</att> attribute may be used to
              create a connection with a <gi scheme="MEI">layerDef</gi> element where logical and
              visual information about the layer is recorded. Alternatively, the <att>n</att>
              attribute may be used as a reference to a <gi scheme="MEI">layerDef</gi> element with
              the same value in its <att>n</att> attribute. If neither <att>def</att> nor
                <att>n</att> attributes are present, then encoding order of the layers is presumed
              to match the encoding order of the layer definitions.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="layerDef" module="MEI.shared" mode="replace">
          <desc>(layer definition) – Container for layer meta-information.</desc>
          <classes>
            <memberOf key="att.commonPart"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.layerDef.log"/>
            <memberOf key="att.layerDef.vis"/>
            <memberOf key="att.layerDef.ges"/>
            <memberOf key="att.layerDef.anl"/>
            <memberOf key="model.layerDefLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.labelLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.instrDefLike"/>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="n" usage="opt">
              <desc>A non-negative integer value functioning as a "name".</desc>
              <datatype>
                <rng:data type="nonNegativeInteger"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>

        <!-- Make more elements members of att.typed, issue #166 -->
        <elementSpec ident="bibl" module="MEI.shared" mode="replace">
          <desc>(bibliographic reference) – Provides a loosely-structured bibliographic citation in
            which the sub-components may or may not be explicitly marked.</desc>
          <classes>
            <memberOf key="att.common"/>
            <!-- Make member of att.bibl -->
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.biblLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.biblPart"/>
                <rng:ref name="model.imprintPart"/>
                <rng:ref name="model.textphraseLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <!-- To produce a more strict bibliographic citation, the following content model may be used: -->
          <!-- <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.titleLike"/>
                <rng:ref name="model.identifierLike"/>
                <rng:ref name="model.annotLike"/>
                <rng:ref name="model.biblPart"/>
                <rng:ref name="imprint"/>
                <rng:ref name="creation"/>
                <rng:ref name="genre"/>
                <rng:ref name="relatedItem"/>
              </rng:choice>
            </rng:zeroOrMore>
           </content> -->
          <remarks>
            <p>
              <gi scheme="MEI">bibl</gi> may contain a mix of text and more specific elements such
              as <gi scheme="MEI">title</gi>, <gi scheme="MEI">edition</gi>, <gi scheme="MEI"
                >persName</gi>, and <gi scheme="MEI">corpName</gi>. This element may also function
              as a hypertext reference to an external electronic resource. Do not confuse this
              element with <gi scheme="MEI">ref</gi>, which does not provide special bibliographic
              sub-elements.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Text Encoding Initiative (TEI) and
              Encoded Archival Description (EAD) standards.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="change" module="MEI.header" mode="replace">
          <desc>Individual change within the revision description.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.datable"/>
            <memberOf key="att.responsibility"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:optional>
              <rng:ref name="respStmt"/>
            </rng:optional>
            <rng:ref name="changeDesc"/>
            <rng:optional>
              <rng:ref name="model.dateLike"/>
            </rng:optional>
          </content>
          <constraintSpec ident="change_requirements" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:change">
                <sch:assert test="@isodate or mei:date">The date of the change must be recorded in
                  an isodate attribute or date element.</sch:assert>
                <sch:assert test="@resp or mei:respStmt">The person responsible for the change must
                  be recorded in a resp attribute or respStmt element.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Additions, deletions, and significant recoding should be noted, but not correction of
              minor typographical errors. It is recommended that revisions should be entered in
              reverse chronological order, with the most recent <gi scheme="MEI">change</gi> first.
              The <att>resp</att> attribute contains a pointer to an element containing info about
              the person/entity responsible for change. The <gi scheme="MEI">edition</gi> element
              can be used to designate an MEI encoding that has been so substantively changed that
              it constitutes a new version that supersedes earlier versions.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Encoded Archival Description (EAD)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="corr" module="MEI.edittrans" mode="replace">
          <desc>(correction) – Contains the correct form of an apparent erroneous passage.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.trans"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.choicePart"/>
            <memberOf key="model.substPart"/>
            <memberOf key="model.transcriptionLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.eventLike"/>
                <rng:ref name="model.eventLike.neumes"/>
                <rng:ref name="model.controleventLike"/>
                <rng:ref name="model.lyricsLike"/>
                <rng:ref name="model.midiLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.eventLike.measureFilling"/>
                <rng:ref name="model.noteModifierLike"/>
                <rng:ref name="model.sectionLike"/>
                <rng:ref name="model.measureLike"/>
                <rng:ref name="model.staffLike"/>
                <rng:ref name="model.layerLike"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.fLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <att>cert</att> attribute signifies the degree of certainty ascribed to
              correction. The <att>resp</att> attribute contains an ID reference to an element
              containing the name of the editor or transcriber responsible for suggesting the
              correction held as the content of the <gi scheme="MEI">corr</gi> element. If the
              correction was made in the source, resp should be used to identify the hand of the
              corrector. The value of resp must point to one or more identifiers declared in the
              document header.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="date" module="MEI.shared" mode="replace">
          <desc>A string identifying a point in time or the time period between two such
            points.</desc>
          <classes>
            <memberOf key="att.bibl"/>
            <memberOf key="att.calendared"/>
            <memberOf key="att.common"/>
            <memberOf key="att.datable"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.dateLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is modelled on elements in the Text Encoding Initiative (TEI) and
              Encoded Archival Description (EAD) standards.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="fig" module="MEI.figtable" mode="replace">
          <desc>(figure) – Groups elements representing or containing graphic information such as an
            illustration or figure.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.figureLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.captionLike"/>
                <rng:ref name="figDesc"/>
                <rng:ref name="model.graphicLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>This element is modelled on the figure element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <classSpec ident="att.pb.log" module="MEI.shared" type="atts" mode="replace">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.typed"/>
          </classes>
        </classSpec>
        <elementSpec ident="ptr" module="MEI.ptrref" mode="replace">
          <desc>(pointer) – Defines a pointer to another location, using only attributes to describe
            the destination.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.internetmedia"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.locrefLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <remarks>
            <p>Unlike the <gi scheme="MEI">ref</gi> element, <gi scheme="MEI">ptr</gi> cannot
              contain text or sub-elements to describe the referenced object.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Encoded Archival Description (EAD) and
              Text Encoding Initiative (TEI) standards.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="quote" module="MEI.text" mode="replace">
          <desc>(block quote) – A formatting element that designates an extended quotation; that is,
            a passage attributed to a source external to the text and normally set off from the text
            by spacing or other typographic distinction.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.xy"/>
            <memberOf key="model.quoteLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.paracontentPart"/>
                <rng:ref name="p"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The source for the quote may be included in the optional <gi scheme="MEI">bibl</gi>
              sub-element. Use <gi scheme="MEI">rend</gi> for words that are enclosed in quotation
              marks for emphasis or for a short quoted phrase that occurs within a line of text.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements found in HTML, TEI, and EAD standards.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="ref" module="MEI.ptrref" mode="replace">
          <desc>(reference) – Defines a reference to another location that may contain text and
            sub-elements to describe the destination.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.internetmedia"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.locrefLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>Unlike the <gi scheme="MEI">ptr</gi> element, <gi scheme="MEI">ref</gi> may contain
              text and sub-elements to describe the destination.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Encoded Archival Description (EAD) and
              TEI standards.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="relatedItem" module="MEI.shared" mode="replace">
          <desc>(related item) – Contains or references another bibliographic item which is related
            to the present one.</desc>
          <classes>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.biblPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.biblLike"/>
                <!-- ptr/ref children aren't necessary as relatedItem is a member of att.pointing. -->
                <!--<rng:ref name="model.locrefLike"/>-->
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="rel" usage="req">
              <desc>Describes the relationship between the &lt;relatedItem&gt; and the resource
                described in the parent element, i.e., &lt;bibl&gt;, &lt;source&gt; or
                &lt;relatedItem&gt;. The values are based on MODS version 3.4. The subject of these
                relations is always the &lt;relatedItem&gt;, and the object is always the parent of
                the &lt;relatedItem&gt;. "preceding" and "succeeding" indicate temporal
                order.</desc>
              <valList type="closed">
                <valItem ident="preceding">
                  <desc>Predecessor of the resource.</desc>
                </valItem>
                <valItem ident="succeeding">
                  <desc>Successor to the resource.</desc>
                </valItem>
                <valItem ident="original">
                  <desc>Original form of the resource.</desc>
                </valItem>
                <valItem ident="host">
                  <desc>Parent containing the resource.</desc>
                </valItem>
                <valItem ident="constituent">
                  <desc>Intellectual or physical component of the resource.</desc>
                </valItem>
                <valItem ident="otherVersion">
                  <desc>Version of the resource's intellectual content not changed enough to be a
                    different work.</desc>
                </valItem>
                <valItem ident="otherFormat">
                  <desc>Version of the resource in a different physical format.</desc>
                </valItem>
                <valItem ident="isReferencedBy">
                  <desc>Published bibliographic description, review, abstract, or index of the
                    resource's content.</desc>
                </valItem>
                <valItem ident="references">
                  <desc>Cited or referred to in the resource.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="surface" module="MEI.facsimile" mode="replace">
          <desc>Defines a writing surface in terms of a rectangular coordinate space, optionally
            grouping one or more graphic representations of that space, and rectangular zones of
            interest within it.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.coordinated"/>
            <memberOf key="att.datapointing"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.startid"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="model.figDescLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="model.graphicLike"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
              <rng:ref name="zone"/>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The <att>startid</att> attribute may be used to hold a reference to the first feature
              occurring on this surface.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Text Encoding Initiative (TEI)
              standard.</p>
          </remarks>
        </elementSpec>
        <classSpec ident="att.typed" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes which can be used to classify or sub-classify features.</desc>
          <attList>
            <attDef ident="type" usage="opt">
              <desc>Characterizes the element in some sense, using any convenient classification
                scheme or typology.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
            <attDef ident="subtype" usage="opt">
              <desc>Provide any sub-classification for the element, additional to that given by its
                type attribute.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <constraintSpec ident="When_subtype" scheme="isoschematron">
                <constraint>
                  <sch:rule context="mei:*[@subtype]">
                    <sch:assert test="@type">An element with a subtype attribute must have a type
                      attribute.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>When appropriate, values from an established typology should be used. Alternatively,
              a typology may be defined in the associated MEI header using the <gi scheme="MEI"
                >classification</gi> element. If values are to be taken from a project-specific
              list, this should be defined using the <gi scheme="MEI">valList</gi> element in a
              project-specific schema description.</p>
          </remarks>
        </classSpec>
        <elementSpec ident="avFile" module="MEI.performance" mode="replace">
          <desc>(audio/video file) – References an external digital audio or video file.</desc>
          <classes>
            <memberOf key="att.common"/>
            <!-- Make member of att.bibl -->
            <memberOf key="att.declaring"/>
            <memberOf key="att.internetmedia"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:ref name="clip"/>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="avFile_child_of_clip" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:clip/mei:avFile">
                <sch:assert test="count(mei:*) = 0">An avFile child of clip cannot have
                  children</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>This element is analogous to the <gi scheme="MEI">graphic</gi> element in the
              figtable module.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="barLine" module="MEI.shared" mode="replace">
          <desc>Vertical line drawn through one or more staves that divides musical notation into
            metrical units.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.barLine.log"/>
            <memberOf key="att.barLine.vis"/>
            <memberOf key="att.barLine.ges"/>
            <memberOf key="att.barLine.anl"/>
            <memberOf key="model.eventLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <constraintSpec ident="Check_barLinetaktplace" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:barLine[@taktplace]">
                <sch:let name="staff" value="ancestor::mei:staff/@n"/>
                <sch:let name="staffpos"
                  value="count(ancestor::mei:staff/preceding-sibling::mei:staff) + 1"/>
                <sch:assert
                  test="number(@taktplace) &lt;= number(2 * preceding::mei:staffDef[@n=$staff and @lines][1]/@lines)"
                />
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>barLine is provided for repertoires, such as mensural notation, that lack measures.
              Because the <gi scheme="MEI">barLine</gi> element's attributes, from which the logical
              and visual characteristics of the bar line can be discerned, largely duplicate those
              of measure, the use of barLine is not necessary within <gi scheme="MEI">measure</gi>
              elements in CMN. On <gi scheme="MEI">barLine</gi> the <att>width</att> attribute
              captures the width of the preceding measure for interchange with music printing
              systems that utilize this information for printing.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="measure" module="MEI.cmn" mode="replace">
          <desc>Unit of musical time consisting of a fixed number of note-values of a given type, as
            determined by the prevailing meter, and delimited in musical notation by bar
            lines.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.declaring"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.pointing"/>
            <memberOf key="att.measure.log"/>
            <memberOf key="att.measure.vis"/>
            <memberOf key="att.measure.ges"/>
            <memberOf key="att.measure.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.measureLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.appLike"/>
                <rng:ref name="model.divLike"/>
                <rng:ref name="model.milestoneLike.music"/>
                <rng:ref name="model.staffDefLike"/>
                <rng:ref name="model.annotLike"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
                <rng:ref name="model.measurePart"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>In MEI, the <gi scheme="MEI">measure</gi> element is a grouping mechanism for events
              and control events. Pointing attributes make it possible to connect this element to
              other internal or external entities, such as media objects or annotations. The
                <att>width</att> attribute may be used to capture the width of the measure for
              interchange with music printing systems that utilize this information for
              printing.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="persName" module="MEI.shared" mode="replace">
          <desc>Proper noun or noun phrase.</desc>
          <classes>
            <memberOf key="att.bibl"/>
            <memberOf key="att.common"/>
            <memberOf key="att.datable"/>
            <memberOf key="att.edit"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.name"/>
            <!-- <memberOf key="att.typed"/> -->
            <!-- Expand att.typed/@type to provide suggested values -->
            <memberOf key="model.nameLike.agent"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <attList>
            <attDef ident="type" usage="opt">
              <desc>Characterizes the element in some sense, using any convenient classification
                scheme or typology.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
              <valList type="semi">
                <valItem ident="forename">
                  <desc>Contains a forename, given or baptismal name.</desc>
                </valItem>
                <valItem ident="surname">
                  <desc>A family (inherited) name, as opposed to a given, baptismal, or nick
                    name.</desc>
                </valItem>
                <valItem ident="rolename">
                  <desc>Contains a name component which indicates that the referent has a particular
                    role or position in society, such as an official title or rank.</desc>
                </valItem>
                <valItem ident="addname">
                  <desc>Contains an additional name component, such as a nickname, epithet, or
                    alias, or any other descriptive phrase used within a personal name.</desc>
                </valItem>
                <valItem ident="namelink">
                  <desc>Contains a connecting phrase or link used within a name but not regarded as
                    part of it, such as "van der" or "of".</desc>
                </valItem>
                <valItem ident="genname">
                  <desc>Contains a name component used to distinguish otherwise similar names on the
                    basis of the relative ages or generations of the persons named.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" usage="opt">
              <desc>Provide any sub-classification for the element, additional to that given by its
                type attribute.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>Name sub-parts may be recorded in <gi scheme="MEI">persName</gi> sub-elements. The
              name of the list from which a controlled value is taken may be recorded using the
                <att>authority</att> attribute.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on an element in the Encoded Archival Description (EAD)
              standard.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="dir" module="MEI.shared" mode="replace">
          <desc>(directive) – An instruction expressed as a combination of text and symbols — such
            as segno and coda symbols, fermatas over a bar line, etc., typically above, below, or
            between staves, but not on the staff — that is not encoded elsewhere in more specific
            elements, like &lt;tempo&gt; or &lt;dynam&gt;.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.dir.log"/>
            <memberOf key="att.dir.vis"/>
            <memberOf key="att.dir.ges"/>
            <memberOf key="att.dir.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.graphicprimitiveLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="dir_start-type_attributes_required" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:dir[not(ancestor::mei:syllable)]">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Examples include text strings, such as 'affettuoso', and music symbols, such as segno
              and coda symbols, fermatas over a bar line, etc. Directives can be control elements.
              That is, they can linked via their attributes to other events. The starting point of
              the directive may be indicated by either a <att>startid</att>, <att>tstamp</att>,
                <att>tstamp.ges</att>, or <att>tstamp.real</att> attribute, while the ending point
              may be recorded by either a <att>dur</att>, <att>dur.ges</att>, <att>endid</att>, or
                <att>tstamp2</att> attribute. It is a semantic error not to specify a starting point
              attribute.</p>
          </remarks>
        </elementSpec>

        <!-- Fix problem with string *courses* -->
        <classSpec ident="att.staffDef.ges.tablature" module="MEI.tablature" type="atts"
          mode="replace">
          <desc>Gestural domain attributes for staffDef in tablature.</desc>
          <attList>
            <attDef ident="tab.strings" usage="opt">
              <desc>Provides a *written* pitch and octave for each open string or course of
                strings.</desc>
              <datatype>
                <rng:list>
                  <rng:oneOrMore>
                    <rng:data type="token">
                      <rng:param name="pattern"
                        >[a-g][0-9](s|f|ss|x|ff|xs|ts|tf|n|nf|ns|su|sd|fu|fd|nu|nd|1qf|3qf|1qs|3qs)?([a-g][0-9](s|f|ss|x|ff|xs|ts|tf|n|nf|ns|su|sd|fu|fd|nu|nd|1qf|3qf|1qs|3qs)?)*</rng:param>
                    </rng:data>
                  </rng:oneOrMore>
                </rng:list>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- create att.evidence class -->
        <classSpec ident="att.evidence" module="MEI.edittrans" type="atts" mode="add">
          <desc>Attributes describing the support for and the certainty of an assertion.</desc>
          <attList>
            <attDef ident="cert" usage="opt">
              <desc>Signifies the degree of certainty or precision associated with a feature.</desc>
              <datatype>
                <rng:ref name="data.CERTAINTY"/>
              </datatype>
            </attDef>
            <attDef ident="evidence" usage="opt">
              <desc>Indicates the nature of the evidence supporting the reliability or accuracy of
                the intervention or interpretation. Suggested values include: 'internal',
                'external', 'conjecture'.</desc>
              <datatype>
                <rng:data type="NMTOKEN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- revise att.edit class -->
        <classSpec ident="att.edit" module="MEI.edittrans" type="atts" mode="replace">
          <desc>Attributes describing the nature of an encoded scholarly intervention or
            interpretation.</desc>
          <classes>
            <memberOf key="att.responsibility"/>
            <memberOf key="att.source"/>
            <memberOf key="att.evidence"/>
          </classes>
        </classSpec>

        <!-- create att.quantity class -->
        <classSpec ident="att.quantity" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that specify a measurement in numerical terms.</desc>
          <attList>
            <attDef ident="quantity" usage="opt">
              <desc>Numeric value capturing a measurement or count. Can only be interpreted in
                combination with the unit attribute.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make num and price members of att.quantity -->
        <elementSpec ident="num" module="MEI.shared" mode="replace">
          <desc>(number) – Numeric information in any form.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.measurement"/>
            <memberOf key="att.quantity"/>
            <memberOf key="model.numLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>Use this element only when it is necessary to display a number in a special way or to
              identify it with a <att>type</att> attribute.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="price" module="MEI.header" mode="replace">
          <desc>The cost of access to a bibliographic item.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.measurement"/>
            <memberOf key="att.quantity"/>
            <memberOf key="model.availabilityPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>

        <classSpec ident="model.dimLike" module="MEI.shared" type="model" mode="add">
          <desc>Groups elements which describe a measurement forming part of the physical dimensions
            of an object.</desc>
        </classSpec>

        <!-- add height, width, and depth elements for use as children of dimensions element -->
        <elementSpec ident="height" module="MEI.shared" mode="add">
          <desc>Description of the vertical size of an object.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.quantity"/>
            <memberOf key="att.measurement"/>
            <memberOf key="model.dimLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <elementSpec ident="width" module="MEI.shared" mode="add">
          <desc>Description of the horizontal size of an object.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.quantity"/>
            <memberOf key="att.measurement"/>
            <memberOf key="model.dimLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <elementSpec ident="depth" module="MEI.shared" mode="add">
          <desc>Description of a measurement taken through a three-dimensional object.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.quantity"/>
            <memberOf key="att.measurement"/>
            <memberOf key="model.dimLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <!-- revise content model and remarks -->
        <elementSpec ident="dimensions" module="MEI.header" mode="replace">
          <desc>Information about the physical size of a bibliographic source; usually includes
            numerical data.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.bibl"/>
            <memberOf key="att.lang"/>
            <memberOf key="att.measurement"/>
            <memberOf key="model.physDescPart"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.dimLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <remarks>
            <p>The elements <gi scheme="MEI">height</gi>, <gi scheme="MEI">width</gi>, and <gi
                scheme="MEI">depth</gi> are available for circumstances that require the capture of
              the individual dimensions of an object. Do not confuse this element with the <gi
                scheme="MEI">extent</gi> element, which is used to indicate the quantity of
              described materials.</p>
          </remarks>
          <remarks>
            <p>This element is modelled on elements in the Text Encoding Initiative (TEI) and
              Encoded Archival Description (EAD) standards.</p>
          </remarks>
        </elementSpec>

        <!-- add commonPart class for the truly common part of att.common -->
        <classSpec ident="att.commonPart" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that form the basis of the att.common class.</desc>
          <classes>
            <memberOf key="att.id"/>
          </classes>
          <attList>
            <attDef ident="label" usage="opt">
              <desc>Provides a name or label for an element. The value may be any string.</desc>
              <datatype>
                <rng:data type="string"/>
              </datatype>
            </attDef>
            <!--<attDef ident="base" ns="http://www.w3.org/XML/1998/namespace" usage="opt">-->
            <attDef ident="xml:base" usage="opt">
              <desc>Provides a base URI reference with which applications can resolve relative URI
                references into absolute URI references.</desc>
              <datatype>
                <rng:ref name="data.URI"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- revise description of @n; elements that require a true numeric value must re-define @n. -->
        <classSpec ident="att.common" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes common to many elements.</desc>
          <classes>
            <memberOf key="att.commonPart"/>
          </classes>
          <attList>
            <attDef ident="n" usage="opt">
              <desc>Provides a number-like designation for an element.</desc>
              <datatype>
                <rng:ref name="token"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise documentation of curve -->
        <elementSpec ident="curve" module="MEI.usersymbols" mode="replace">
          <desc>A curved line that cannot be represented by a more specific element, such as a <gi
              scheme="MEI">slur</gi>.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
            <memberOf key="att.color"/>
            <memberOf key="att.common"/>
            <memberOf key="att.curvature"/>
            <memberOf key="att.curverend"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.xy2"/>
            <memberOf key="model.graphicprimitiveLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <remarks>
            <p>The starting point of the curve may be identified in absolute output coordinate terms
              using the <att>x</att> and <att>y</att> attributes or relative to the location of
              another element using the <att>startid</att> attribute. The attributes in the
              att.visualoffset class may be used to record horizontal, vertical, or time offsets
              from the absolute coordinates or from the location of the referenced element.
              Similarly, the terminal point of the curve may be recorded using either the
                <att>x2</att> and <att>y2</att> coordinates or in relation to the location of
              another element using the <att>endid</att> attribute. Attributes in the
              att.visualoffset2 class maybe used to record the offsets of the ending point. The
                <att>bulge</att> attribute or, alternatively, the <att>bezier</att> attribute,
              describe the shape of the curve and the <att>lform</att> and <att>lwidth</att>
              attributes capture its appearance.</p>
          </remarks>
        </elementSpec>

        <!-- Require @bezier and @bulge to be expressed as pairs of values and add "mixed" as value
          for @curvedir. -->
        <classSpec ident="att.curvature" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes that describe curvature.</desc>
          <attList>
            <attDef ident="bezier" usage="opt">
              <desc>Records the placement of Bezier control points as a series of pairs of
                space-separated values; e.g., 19 45 -32 118.</desc>
              <datatype>
                <rng:list>
                  <rng:oneOrMore>
                    <rng:data type="decimal"/>
                    <rng:data type="decimal"/>
                  </rng:oneOrMore>
                </rng:list>
              </datatype>
            </attDef>
            <attDef ident="bulge" usage="opt">
              <desc>Describes a curve as one or more pairs of values with respect to an imaginary
                line connecting the starting and ending points of the curve. The first value of each
                pair represents a point along the line, expressed as a percentage of the line's
                length. The second value captures a distance to the left (positive value) or right
                (negative value) of the line, expressed in virtual units. N.B. An MEI virtual unit
                (VU) is half the distance between adjacent staff lines.</desc>
              <datatype>
                <rng:list>
                  <rng:oneOrMore>
                    <rng:data type="decimal"/>
                    <rng:ref name="data.PERCENT"/>
                  </rng:oneOrMore>
                </rng:list>
              </datatype>
            </attDef>
            <attDef ident="curvedir" usage="opt">
              <desc>Describes a curve with a generic term indicating the direction of
                curvature.</desc>
              <valList type="closed">
                <valItem ident="above">
                  <desc>Upward curve.</desc>
                </valItem>
                <valItem ident="below">
                  <desc>Downward curve.</desc>
                </valItem>
                <valItem ident="mixed">
                  <desc>A "meandering" curve, both above and below the items it pertains to.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise color datatype names -->
        <macroSpec ident="data.COLORLIST" module="MEI" type="dt" mode="delete"/>
        <macroSpec ident="data.COLORNAMES" module="MEI" type="dt" mode="add">
          <desc>List of HTML 4.01 color names.</desc>
          <valList type="closed">
            <valItem ident="aqua"/>
            <valItem ident="black"/>
            <valItem ident="blue"/>
            <valItem ident="fuchsia"/>
            <valItem ident="gray"/>
            <valItem ident="green"/>
            <valItem ident="lime"/>
            <valItem ident="maroon"/>
            <valItem ident="navy"/>
            <valItem ident="olive"/>
            <valItem ident="purple"/>
            <valItem ident="red"/>
            <valItem ident="silver"/>
            <valItem ident="teal"/>
            <valItem ident="white"/>
            <valItem ident="yellow"/>
          </valList>
        </macroSpec>
        <macroSpec ident="data.COLORPAR" module="MEI" type="dt" mode="delete"/>
        <macroSpec ident="data.COLORVALUES" module="MEI" type="dt" mode="add">
          <desc>Parameterized color values</desc>
          <content>
            <rng:choice>
              <!-- hex values -->
              <rng:data type="token">
                <rng:param name="pattern">#[0-9A-Fa-f]{6,6}</rng:param>
              </rng:data>
              <!-- AARRGGBB values -->
              <rng:data type="token">
                <rng:param name="pattern">#[0-9A-Fa-f]{8,8}</rng:param>
              </rng:data>
              <!-- RGB values -->
              <rng:data type="token">
                <rng:param name="pattern"
                  >rgb\((\s*(([01]?[0-9]?[0-9])|2[0-4][0-9]|25[0-5])\s*,\s*){2}([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*\)</rng:param>
              </rng:data>
              <!-- RGBA values -->
              <rng:data type="token">
                <rng:param name="pattern"
                  >rgba\(\s*(([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,\s*){3}(0(\.\d+)?|1(\.0+)?)\s*\)|rgba\(\s*(((\d{1,2})?%|100%)\s*,\s*){2}(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)</rng:param>
              </rng:data>
              <!-- HSL values -->
              <rng:data type="token">
                <rng:param name="pattern"
                  >hsl\(\s*((\d{1,2})|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*\)</rng:param>
              </rng:data>
              <!-- HSLA values -->
              <rng:data type="token">
                <rng:param name="pattern"
                  >hsla\(\s*(\d{1,2}|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)</rng:param>
              </rng:data>
            </rng:choice>
          </content>
        </macroSpec>
        <macroSpec ident="data.COLOR" module="MEI" type="dt" mode="replace">
          <desc>A value in one of the following forms is expected: 1) hexadecimal RRGGBB, 2)
            hexadecimal AARRGGBB, 3) CSS RGB, 4) CSS RGBA, 5) HSL, 6) HSLA, or 7) HTML 4.01 color
            name.</desc>
          <content>
            <alternate>
              <macroRef key="data.COLORNAMES"/>
              <macroRef key="data.COLORVALUES"/>
            </alternate>
          </content>
        </macroSpec>

        <!-- Make att.["musical" element].vis members of att.altsym and att.typography -->
        <classSpec ident="att.accid.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.visualoffset.vo"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.accid.vis.mensural"/>
          </classes>
        </classSpec>
        <classSpec ident="att.artic.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.arpeg.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="arrow" usage="opt">
              <desc>Indicates if an arrowhead is to be drawn as part of the arpeggiation
                symbol.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.clef.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.custos.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.dot.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.visualoffset.vo"/>
            <memberOf key="att.xy"/>
            <memberOf key="att.dot.vis.mensural"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fermata.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Describes the visual appearance of the fermata; that is, whether it occurs as
                upright or inverted.</desc>
              <valList type="closed">
                <valItem ident="inv">
                  <desc>Inverted, i.e., curve or bracket below the dot.</desc>
                </valItem>
                <valItem ident="norm">
                  <desc>Upright; i.e., curve or bracket above the dot.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="shape" usage="opt">
              <desc>Describes the visual appearance of the fermata; that is, whether it has a
                curved, square, or angular shape.</desc>
              <valList type="closed">
                <valItem ident="curved">
                  <desc>A curve above or below the dot.</desc>
                </valItem>
                <valItem ident="square">
                  <desc>A bracket above or below the dot.</desc>
                </valItem>
                <valItem ident="angular">
                  <desc>A triangle above or below the dot.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.grpSym.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.halfmRpt.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.expandable"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
          </classes>
        </classSpec>
        <classSpec ident="att.harpPedal.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.ineume.vis" module="MEI.neumes" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.keyAccid.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.enclosingchars"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.mensur.vis" module="MEI.mensural" type="atts" mode="replace">
          <desc>Visual domain attributes. These attributes describe the physical appearance of the
            mensuration sign/time signature of mensural notation.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <desc>Indicates whether the base symbol is written vertically or horizontally.</desc>
              <valList type="closed">
                <valItem ident="horizontal"/>
                <valItem ident="vertical"/>
              </valList>
            </attDef>
            <attDef ident="orient" usage="opt">
              <desc>Describes the rotation or reflection of the base symbol.</desc>
              <datatype>
                <rng:ref name="data.ORIENTATION"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.mordent.vis" module="MEI.cmnOrnaments" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
          </classes>
        </classSpec>
        <classSpec ident="att.mRest.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.cutout"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.staffloc.pitched"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visibility"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.mRpt.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.expandable"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.mRpt2.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <memberOf key="att.expandable"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.multiRest.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.staffloc.pitched"/>
            <memberOf key="att.typography"/>
          </classes>
          <attList>
            <attDef ident="block" usage="opt">
              <desc>When the block attribute is used, combinations of the 1, 2, and 4 measure rest
                forms (Read, p. 104) should be rendered instead of the modern form or an alternative
                symbol.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.multiRpt.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.expandable"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
          </classes>
        </classSpec>
        <classSpec ident="att.trill.vis" module="MEI.cmnOrnaments" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Make att.trill.vis member of att.extender -->
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2.ho"/>
            <memberOf key="att.visualoffset2.to"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.turn.vis" module="MEI.cmnOrnaments" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.uneume.vis" module="MEI.neumes" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.color"/>
            <!-- Support SMuFL, issue #213 -->
            <!-- Make member of att.extsym -->
            <memberOf key="att.extsym"/>
            <memberOf key="att.relativesize"/>
            <memberOf key="att.staffloc"/>
            <memberOf key="att.typography"/>
            <memberOf key="att.visibility"/>
            <memberOf key="att.visualoffset.ho"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <!-- Remove reference to att.typography in accid and artic; this should've been done 
          using att.(accid|artic).vis anyway -->
        <elementSpec ident="accid" module="MEI.shared" mode="replace">
          <desc>(accidental) – Records a temporary alteration to the pitch of a note.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.accid.log"/>
            <memberOf key="att.accid.vis"/>
            <memberOf key="att.accid.ges"/>
            <memberOf key="att.accid.anl"/>
            <memberOf key="model.noteModifierLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <remarks>
            <p>An accidental may raise a pitch by one or two semitones or it may cancel a previous
              accidental or part of a key signature. This element provides an alternative to the
                <att>accid</att> and <att>accid.ges</att> attributes on the <gi scheme="MEI"
                >note</gi> element. The element may be used when specific display info, such as size
              or color, needs to be recorded for the accidental or when multiple accidentals occur
              on a single note. The <att>func</att> attribute can be used to differentiate between
              the accidental's functions, such as 'cautionary' or 'editorial'.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="artic" module="MEI.shared" mode="replace">
          <desc>(articulation) – An indication of how to play a note or chord.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.artic.log"/>
            <memberOf key="att.artic.vis"/>
            <memberOf key="att.artic.ges"/>
            <memberOf key="att.artic.anl"/>
            <memberOf key="model.noteModifierLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <remarks>
            <p>Articulations typically affect duration, such as staccato marks, or the force of
              attack, such as accents. This element provides an alternative to the <att>artic</att>
              attribute on the <gi scheme="MEI">note</gi> and <gi scheme="MEI">chord</gi> elements.
              It may be used when specific display info, such as size or color, needs to be recorded
              for the articulation or when multiple articulation marks occur on a single note or
              chord.</p>
          </remarks>
        </elementSpec>

        <!--  data.HEADSTYLE needs an overhaul, issue #202 -->
        <macroSpec ident="data.FILL" module="MEI" type="dt" mode="add">
          <desc>Describes how a graphical object, such as a note head, should be filled. The
            relative values — top, bottom, left, and right — indicate these locations *after*
            rotation is applied.</desc>
          <content>
            <rng:choice>
              <rng:value>void</rng:value>
              <rng:value>solid</rng:value>
              <rng:value>top</rng:value>
              <rng:value>bottom</rng:value>
              <rng:value>left</rng:value>
              <rng:value>right</rng:value>
            </rng:choice>
          </content>
        </macroSpec>
        <macroSpec ident="data.HEADSHAPE" module="MEI" type="dt" mode="replace">
          <desc>Note head shapes.</desc>
          <content>
            <valList type="open">
              <valItem ident="quarter">
                <desc>Filled, rotated oval (Unicode 1D158).</desc>
              </valItem>
              <valItem ident="half">
                <desc>Unfilled, rotated oval (Unicode 1D157).</desc>
              </valItem>
              <valItem ident="whole">
                <desc>Unfilled, rotated oval (Unicode 1D15D).</desc>
              </valItem>
              <valItem ident="backslash">
                <desc>Unfilled backslash.</desc>
              </valItem>
              <valItem ident="circle">
                <desc>Unfilled circle.</desc>
              </valItem>
              <valItem ident="+">
                <desc>Plus sign (Unicode 1D144).</desc>
              </valItem>
              <valItem ident="diamond">
                <desc>Unfilled diamond (Unicode 1D1B9).</desc>
              </valItem>
              <valItem ident="isotriangle">
                <desc>Unfilled isosceles triangle (Unicode 1D148).</desc>
              </valItem>
              <valItem ident="oval">
                <desc>Unfilled, unrotated oval.</desc>
              </valItem>
              <valItem ident="piewedge">
                <desc>Unfilled downward-pointing wedge (Unicode 1D154).</desc>
              </valItem>
              <valItem ident="rectangle">
                <desc>Unfilled rectangle (Unicode 1D146).</desc>
              </valItem>
              <valItem ident="rtriangle">
                <desc>Unfilled right triangle (Unicode 1D14A).</desc>
              </valItem>
              <valItem ident="semicircle">
                <desc>Unfilled semi-circle (Unicode 1D152).</desc>
              </valItem>
              <valItem ident="slash">
                <desc>Unfilled slash.</desc>
              </valItem>
              <valItem ident="square">
                <desc>Unfilled square.</desc>
              </valItem>
              <valItem ident="x">
                <desc>X (Unicode 1D143).</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>
        <macroSpec ident="data.NOTEHEADMODIFIER" module="MEI" type="dt" mode="add">
          <desc>Captures any notehead "modifiers"; that is, symbols added to the notehead, such as
            slashes, lines, text, and enclosures, etc.</desc>
          <content>
            <alternate>
              <macroRef key="data.NOTEHEADMODIFIER.list"/>
              <macroRef key="data.NOTEHEADMODIFIER.pat"/>
            </alternate>
          </content>
        </macroSpec>
        <macroSpec ident="data.NOTEHEADMODIFIER.list" module="MEI" type="dt" mode="add">
          <desc>Captures any notehead "modifiers"; that is, symbols added to the notehead, such as
            slashes, lines, text, enclosures, etc.</desc>
          <content>
            <valList type="closed">
              <valItem ident="slash">
                <desc>Slash (upper right to lower left).</desc>
              </valItem>
              <valItem ident="backslash">
                <desc>Backslash (upper left to lower right).</desc>
              </valItem>
              <valItem ident="vline">
                <desc>Vertical line.</desc>
              </valItem>
              <valItem ident="hline">
                <desc>Horizontal line.</desc>
              </valItem>
              <valItem ident="centerdot">
                <desc>Center dot.</desc>
              </valItem>
              <valItem ident="paren">
                <desc>Enclosing parentheses.</desc>
              </valItem>
              <valItem ident="brack">
                <desc>Enclosing square brackets.</desc>
              </valItem>
              <valItem ident="box">
                <desc>Enclosing box.</desc>
              </valItem>
              <valItem ident="circle">
                <desc>Enclosing circle.</desc>
              </valItem>
              <valItem ident="dblwhole">
                <desc>Enclosing "fences".</desc>
              </valItem>
            </valList>
          </content>
        </macroSpec>
        <macroSpec ident="data.NOTEHEADMODIFIER.pat" module="MEI" type="dt" mode="add">
          <desc>Captures text rendered in the center of the notehead.</desc>
          <content>
            <rng:choice>
              <rng:data type="string">
                <rng:param name="pattern">centertext\((A|B|C|D|E|F|G)(f|♭|n|♮|s|♯)?\)</rng:param>
              </rng:data>
              <rng:data type="string">
                <rng:param name="pattern">centertext\(H(s|♯)?\)</rng:param>
              </rng:data>
            </rng:choice>
          </content>
        </macroSpec>
        <macroSpec ident="data.ROTATION" module="MEI" type="dt" mode="add">
          <desc>Rotation.</desc>
          <content>
            <alternate>
              <macroRef key="data.DEGREES"/>
              <macroRef key="data.ROTATIONDIRECTION"/>
            </alternate>
          </content>
        </macroSpec>
        <macroSpec ident="data.ROTATIONDIRECTION" module="MEI" type="dt" mode="add">
          <desc>Rotation term.</desc>
          <valList type="closed">
            <valItem ident="none">
              <desc>No rotation.</desc>
            </valItem>
            <valItem ident="down">
              <desc>Rotated 180 degrees.</desc>
            </valItem>
            <valItem ident="left">
              <desc>Rotated 270 degrees clockwise.</desc>
            </valItem>
            <valItem ident="ne">
              <desc>Rotated 45 degrees clockwise.</desc>
            </valItem>
            <valItem ident="nw">
              <desc>Rotated 315 degrees clockwise.</desc>
            </valItem>
            <valItem ident="se">
              <desc>Rotated 135 degrees clockwise.</desc>
            </valItem>
            <valItem ident="sw">
              <desc>Rotated 225 degrees clockwise.</desc>
            </valItem>
          </valList>
        </macroSpec>
        <classSpec ident="att.noteheads" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes pertaining to the notehead part of a note.</desc>
          <attList>
            <attDef ident="head.color" usage="opt">
              <desc>Captures the overall color of a notehead.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="head.fill" usage="opt">
              <desc>Describes how/if the notehead is filled.</desc>
              <datatype>
                <rng:ref name="data.FILL"/>
              </datatype>
            </attDef>
            <attDef ident="head.fillcolor" usage="opt">
              <desc>Captures the fill color of a notehead if different from the overall note
                color.</desc>
              <datatype>
                <rng:ref name="data.COLOR"/>
              </datatype>
            </attDef>
            <attDef ident="head.mod" usage="opt">
              <desc>Records any additional symbols applied to the notehead.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.NOTEHEADMODIFIER"/>
              </datatype>
            </attDef>
            <attDef ident="head.rotation" usage="opt">
              <desc>Describes rotation applied to the basic notehead shape. A positive value rotates
                the notehead in a counter-clockwise fashion, while negative values produce clockwise
                rotation.</desc>
              <datatype>
                <rng:ref name="data.ROTATION"/>
              </datatype>
            </attDef>
            <attDef ident="head.shape" usage="opt">
              <desc>Used to override the head shape normally used for the given duration.</desc>
              <datatype>
                <rng:ref name="data.HEADSHAPE"/>
              </datatype>
            </attDef>
            <attDef ident="head.visible" usage="opt">
              <desc>Indicates if a feature should be rendered when the notation is presented
                graphically or sounded when it is presented in an aural form.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Revise handling of stem-related attributes -->
        <!-- Revise datatypes related to stems -->
        <macroSpec ident="data.STEMDIRECTION.basic" module="MEI" type="dt" mode="add">
          <desc>Common stem directions.</desc>
          <valList type="closed">
            <valItem ident="up">
              <desc>Stem points upwards.</desc>
            </valItem>
            <valItem ident="down">
              <desc>Stem points downwards.</desc>
            </valItem>
          </valList>
        </macroSpec>
        <macroSpec ident="data.STEMDIRECTION.extended" module="MEI" type="dt" mode="add">
          <desc>Additional stem directions.</desc>
          <valList type="closed">
            <valItem ident="left">
              <desc>Stem points left.</desc>
            </valItem>
            <valItem ident="right">
              <desc>Stem points right.</desc>
            </valItem>
            <valItem ident="ne">
              <desc>Stem points up and right.</desc>
            </valItem>
            <valItem ident="se">
              <desc>Stem points down and right.</desc>
            </valItem>
            <valItem ident="nw">
              <desc>Stem points up and left.</desc>
            </valItem>
            <valItem ident="sw">
              <desc>Stem points down and left.</desc>
            </valItem>
          </valList>
        </macroSpec>
        <macroSpec ident="data.STEMDIRECTION" module="MEI" type="dt" mode="replace">
          <desc>Stem direction.</desc>
          <content>
            <alternate>
              <macroRef key="data.STEMDIRECTION.basic"/>
              <macroRef key="data.STEMDIRECTION.extended"/>
            </alternate>
          </content>
        </macroSpec>
        <!-- Add value of "none" to data.STEMMODIFIER -->
        <macroSpec ident="data.STEMMODIFIER" module="MEI" type="dt" mode="replace">
          <desc>Stem modification.</desc>
          <valList type="closed">
            <valItem ident="none">
              <desc>No modifications to stem.</desc>
            </valItem>
            <valItem ident="1slash">
              <desc>1 slash through stem.</desc>
            </valItem>
            <valItem ident="2slash">
              <desc>2 slashes through stem.</desc>
            </valItem>
            <valItem ident="3slash">
              <desc>3 slashes through stem.</desc>
            </valItem>
            <valItem ident="4slash">
              <desc>4 slashes through stem.</desc>
            </valItem>
            <valItem ident="5slash">
              <desc>5 slashes through stem.</desc>
            </valItem>
            <valItem ident="6slash">
              <desc>6 slashes through stem.</desc>
            </valItem>
            <valItem ident="sprech">
              <desc>X placed on stem.</desc>
            </valItem>
            <valItem ident="z">
              <desc>Z placed on stem.</desc>
            </valItem>
          </valList>
        </macroSpec>
        <!-- rename att.stemmed and att.stemmed.cmn to att.stems and att.stems.cmn, respectively. -->
        <classSpec ident="att.stemmed" module="MEI.shared" type="atts" mode="delete"/>
        <classSpec ident="att.stemmed.cmn" module="MEI.shared" type="atts" mode="delete"/>
        <classSpec ident="att.stems" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that describe the properties of stemmed features; that is, chords and
            notes.</desc>
          <classes>
            <memberOf key="att.stems.cmn"/>
          </classes>
          <attList>
            <attDef ident="stem.dir" usage="opt">
              <desc>Describes the direction of a stem.</desc>
              <datatype>
                <rng:ref name="data.STEMDIRECTION"/>
              </datatype>
            </attDef>
            <attDef ident="stem.len" usage="opt">
              <desc>Encodes the stem length.</desc>
              <datatype>
                <rng:ref name="data.MEASUREMENT"/>
              </datatype>
            </attDef>
            <attDef ident="stem.mod" usage="opt">
              <desc>Encodes any stem "modifiers"; that is, symbols rendered on the stem, such as
                tremolo or Sprechstimme indicators.</desc>
              <datatype>
                <rng:ref name="data.STEMMODIFIER"/>
              </datatype>
            </attDef>
            <attDef ident="stem.pos" usage="opt">
              <desc>Records the position of the stem in relation to the note head(s).</desc>
              <datatype>
                <rng:ref name="data.STEMPOSITION"/>
              </datatype>
            </attDef>
            <attDef ident="stem.x" usage="opt">
              <desc>Records the output x coordinate of the stem's attachment point.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
            <attDef ident="stem.y" usage="opt">
              <desc>Records the output y coordinate of the stem's attachment point.</desc>
              <datatype>
                <rng:data type="decimal"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.stems.cmn" module="MEI.cmn" type="atts" mode="add">
          <desc>Attributes that describe the properties of stemmed features; that is, chords and
            notes.</desc>
          <attList>
            <attDef ident="stem.with" usage="opt">
              <desc>Contains an indication of which staff a note or chord that logically belongs to
                the current staff should be visually placed on; that is, the one above or the one
                below.</desc>
              <datatype>
                <rng:ref name="data.OTHERSTAFF"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>

        <!-- Add a generic ornam element, issue #253 -->
        <classSpec ident="att.ornam.log" module="MEI.shared" type="atts" mode="add">
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.ornamentaccid"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
        </classSpec>
        <classSpec ident="att.ornam.vis" module="MEI.shared" type="atts" mode="add">
          <classes>
            <memberOf key="att.color"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2.ho"/>
            <memberOf key="att.visualoffset2.to"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <classSpec ident="att.ornam.ges" module="MEI.shared" type="atts" mode="add">
          <classes>
            <memberOf key="att.duration.performed"/>
          </classes>
        </classSpec>
        <classSpec ident="att.ornam.anl" module="MEI.shared" type="atts" mode="add">
          <classes>
            <memberOf key="att.common.anl"/>
          </classes>
        </classSpec>
        <elementSpec ident="ornam" module="MEI.shared" mode="add">
          <desc>A generic ornament not encoded elsewhere using more specific elements, such as
            &lt;mordent&gt;, &lt;turn&gt;, or &lt;trill&gt;.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.ornam.log"/>
            <memberOf key="att.ornam.vis"/>
            <memberOf key="att.ornam.ges"/>
            <memberOf key="att.ornam.anl"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.controleventLike"/>
          </classes>
          <content>
            <rng:empty/>
          </content>
          <constraintSpec ident="ornam_start-type_attributes_required" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:ornam">
                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one
                  of the attributes: startid, tstamp, tstamp.ges or tstamp.real</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>

        <!-- Add a generic fingering element, issue #224 -->
        <!-- Revise documentation of att.articulation class -->
        <classSpec ident="att.articulation" module="MEI.shared" type="atts" mode="replace">
          <desc>Attributes for capturing the written signs that describe the method of
            performance.</desc>
          <attList>
            <attDef ident="artic" usage="opt">
              <desc>Encodes the written articulation(s). Articulations are normally encoded in order
                from the note head outward; that is, away from the stem. See additional notes at
                att.vis.note. Only articulations should be encoded in the artic attribute; for
                example, fingerings should be encoded using the &lt;fingering&gt; element.</desc>
              <datatype maxOccurs="unbounded">
                <rng:ref name="data.ARTICULATION"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add att.extender attribute class -->
        <classSpec ident="att.extender" module="MEI.shared" type="atts" mode="add">
          <desc>Attributes that describe extension symbols, typically lines. Members of this class
            are also typically members of the att.linerend class.</desc>
          <classes>
            <memberOf key="att.linerend"/>
          </classes>
          <attList>
            <attDef ident="extender" usage="opt">
              <desc>Indicates the presence of an extension symbol, typically a line.</desc>
              <datatype>
                <rng:ref name="data.BOOLEAN"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        <!-- Add model.fingeringLike class; since it is a member of model.controleventLike,
          its members will be allowed to appear wherever model.controleventLike can occur. -->
        <classSpec ident="model.fingeringLike" module="MEI.fingering" type="model" mode="add">
          <desc>Groups elements that capture performance instructions regarding the use of the
            fingers of the hand (or a subset of them).</desc>
          <classes>
            <memberOf key="model.controleventLike"/>
          </classes>
        </classSpec>
        <!-- Add single finger element -->
        <classSpec ident="att.fing.anl" module="MEI.fingering" type="atts" mode="add">
          <desc>Analytical domain attributes.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fing.ges" module="MEI.fingering" type="atts" mode="add">
          <desc>Gestural domain attributes.</desc>
          <classes>
            <memberOf key="att.duration.performed"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fing.log" module="MEI.fingering" type="atts" mode="add">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fing.vis" module="MEI.fingering" type="atts" mode="add">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <remarks>
            <p>If @tstamp2 is not provided, then the extender should be drawn based on the value of
              @tstamp2 on a fingering ancestor.</p>
          </remarks>
        </classSpec>
        <elementSpec ident="fing" module="MEI.fingering" mode="add">
          <desc>finger – An individual finger in a fingering indication.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.fing.anl"/>
            <memberOf key="att.fing.ges"/>
            <memberOf key="att.fing.log"/>
            <memberOf key="att.fing.vis"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.fingeringLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="stack_exclusion" scheme="isoschematron">
            <!-- Exclusion implemented using Schematron -->
            <constraint>
              <sch:rule context="mei:fing">
                <sch:assert test="not(descendant::mei:stack)">The stack element is not allowed
                  anywhere in fing.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <!-- Add fingGrp element -->
        <classSpec ident="att.fingGrp.anl" module="MEI.fingering" type="atts" mode="add">
          <desc>Analytical domain attributes.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fingGrp.ges" module="MEI.fingering" type="atts" mode="add">
          <desc>Gestural domain attributes.</desc>
          <classes>
            <memberOf key="att.duration.performed"/>
          </classes>
        </classSpec>
        <classSpec ident="att.fingGrp.log" module="MEI.fingering" type="atts" mode="add">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
          <attList>
            <attDef ident="form" usage="opt">
              <valList type="closed">
                <valItem ident="alter">
                  <desc>alternation of fingers.</desc>
                </valItem>
                <valItem ident="combi">
                  <desc>combination of fingers.</desc>
                </valItem>
                <valItem ident="subst">
                  <desc>substitution of fingers.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.fingGrp.vis" module="MEI.fingering" type="atts" mode="add">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="orient" usage="opt">
              <valList type="closed">
                <valItem ident="horiz">
                  <desc>Combination expressed horizontally, as for brass instruments.</desc>
                </valItem>
                <valItem ident="vert">
                  <desc>Combination expressed vertically, as for woodwind instruments or
                    piano.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec ident="fingGrp" module="MEI.fingering" mode="add">
          <desc>(finger group)– A group of individual fingers in a fingering indication.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.fingGrp.anl"/>
            <memberOf key="att.fingGrp.ges"/>
            <memberOf key="att.fingGrp.log"/>
            <memberOf key="att.fingGrp.vis"/>
            <memberOf key="att.typed"/>
            <memberOf key="model.fingeringLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:ref name="model.fingeringLike"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
          <constraintSpec ident="require_fingeringLike_children" scheme="isoschematron">
            <constraint>
              <sch:rule context="mei:fingGrp">
                <sch:assert test="count(mei:fing) + count(mei:fingGrp) &gt; 1">At least 2 fing or
                  fingGrp elements are required.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec ident="check_fingGrp_start-type_attributes" scheme="isoschematron">
            <constraint>
              <sch:pattern>
                <sch:rule context="mei:fingGrp[not(ancestor::mei:fingGrp)][@tstamp or @startid]">
                  <sch:assert test="not(child::mei:*[@tstamp or @startid])">When @tstamp or @startid
                    is present on fingGrp, its child elements cannot have a @tstamp or @startid
                    attribute.</sch:assert>
                </sch:rule>
                <sch:rule
                  context="mei:fingGrp[not(ancestor::mei:fingGrp)][not(@tstamp or @startid)]">
                  <sch:assert
                    test="count(descendant::mei:*[@tstamp or @startid]) = count(child::mei:*[local-name()='fing' or local-name()='fingGrp'])"
                    >When @tstamp or @startid is not present on fingGrp, each of its child elements
                    must have a @tstamp or @startid attribute.</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <!-- Now that att.extender class has been added, some existing elements can take advantage of it too. -->
        <!-- Place attributes for the f element in domain-based groups -->
        <classSpec ident="att.f.anl" module="MEI.shared" type="atts" mode="add">
          <desc>Analytical domain attributes.</desc>
          <classes>
            <memberOf key="att.common.anl"/>
          </classes>
        </classSpec>
        <classSpec ident="att.f.ges" module="MEI.shared" type="atts" mode="add">
          <desc>Gestural domain attributes.</desc>
          <classes>
            <memberOf key="att.duration.performed"/>
          </classes>
        </classSpec>
        <!-- Make att.f.log element a member of att.timestamp2.musical and att.visualoffset. -->
        <classSpec ident="att.f.log" module="MEI.shared" type="atts" mode="add">
          <desc>Logical domain attributes.</desc>
          <classes>
            <memberOf key="att.controlevent"/>
            <memberOf key="att.augmentdots"/>
            <memberOf key="att.duration.additive"/>
            <memberOf key="att.startendid"/>
            <memberOf key="att.timestamp2.musical"/>
          </classes>
        </classSpec>
        <!-- Make att.f.vis member of att.extender -->
        <!-- This change makes it possible for a separate extender to be captured for each f element within 
          the figured bass indication. See the description of @extender for details. -->
        <classSpec ident="att.f.vis" module="MEI.shared" type="atts" mode="add">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.altsym"/>
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.xy"/>
          </classes>
          <remarks>
            <p>If @tstamp2 is not provided, then the extender should be drawn based on the value of
              @tstamp2 on the harm ancestor.</p>
          </remarks>
        </classSpec>
        <elementSpec ident="f" module="MEI.harmony" mode="replace">
          <desc>(figure) – Single element of a figured bass indication.</desc>
          <classes>
            <memberOf key="att.common"/>
            <memberOf key="att.facsimile"/>
            <memberOf key="att.f.anl"/>
            <memberOf key="att.f.ges"/>
            <memberOf key="att.f.log"/>
            <memberOf key="att.f.vis"/>
            <memberOf key="model.fLike"/>
          </classes>
          <content>
            <rng:zeroOrMore>
              <rng:choice>
                <rng:text/>
                <rng:ref name="model.textphraseLike.limited"/>
                <rng:ref name="model.editLike"/>
                <rng:ref name="model.transcriptionLike"/>
              </rng:choice>
            </rng:zeroOrMore>
          </content>
        </elementSpec>
        <!-- Make att.harm.vis member of att.extender -->
        <classSpec ident="att.harm.vis" module="MEI.harmony" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2.ho"/>
            <memberOf key="att.visualoffset2.to"/>
            <memberOf key="att.xy"/>
          </classes>
          <attList>
            <attDef ident="rendgrid" usage="opt">
              <desc>Describes how the harmonic indication should be rendered.</desc>
              <valList type="closed">
                <valItem ident="grid">
                  <desc>Chord tablature grid.</desc>
                </valItem>
                <valItem ident="gridtext">
                  <desc>Chord tablature grid and the element's textual content.</desc>
                </valItem>
                <valItem ident="text">
                  <desc>Textual content of the element.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <!-- Make dir member of att.extender -->
        <classSpec ident="att.dir.vis" module="MEI.shared" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.extender"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2.ho"/>
            <memberOf key="att.visualoffset2.to"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>
        <!-- Make att.octave.vis member of att.extender -->
        <classSpec ident="att.octave.vis" module="MEI.cmn" type="atts" mode="replace">
          <desc>Visual domain attributes.</desc>
          <classes>
            <memberOf key="att.color"/>
            <memberOf key="att.extender"/>
            <memberOf key="att.visualoffset"/>
            <memberOf key="att.visualoffset2.ho"/>
            <memberOf key="att.visualoffset2.to"/>
            <memberOf key="att.xy"/>
          </classes>
        </classSpec>

        <!-- =============================== BUG FIXES =============================== -->



        <!-- =============================== NEW FEATURES =============================== -->



      </schemaSpec>
    </body>
  </text>
</TEI>
