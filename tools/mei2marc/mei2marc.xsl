<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
  xmlns="http://www.loc.gov/MARC21/slim" xmlns:mei="http://www.music-encoding.org/ns/mei"
  exclude-result-prefixes="mei">
  <xsl:output method="xml" encoding="UTF-8" indent="yes" media-type="text/xml"/>
  <xsl:strip-space elements="*"/>

  <!-- PARAM:mode
      This parameter determines which entity the generated MARC record is for:
        'file': the MEI file,
        'source': the source(s) of the MEI file.
  -->
  <xsl:param name="mode">file</xsl:param>
  <xsl:param name="model_path"
    >http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd</xsl:param>

  <!-- version -->
  <xsl:variable name="version">
    <xsl:text>1.0 ALPHA</xsl:text>
  </xsl:variable>

  <xsl:template match="/">
    <xsl:apply-templates select="//mei:meiHead"/>
  </xsl:template>

  <xsl:template match="mei:meiHead">
    <xsl:if test="$model_path != ''">
      <xsl:processing-instruction name="xml-model">
        <xsl:value-of select="concat('&#32;href=&quot;', $model_path, '&quot;')"/>
      </xsl:processing-instruction>
    </xsl:if>
    <xsl:comment>
      <xsl:text>MARC record generated by mei2marc.xsl version </xsl:text>
      <xsl:value-of select="$version"/>
    </xsl:comment>
    <record>
      <xsl:choose>
        <xsl:when test="$mode = 'file'">
          <xsl:apply-templates select="mei:fileDesc"/>
        </xsl:when>
      </xsl:choose>
    </record>
  </xsl:template>

  <xsl:template name="leader">
    <xsl:variable name="leaderComment">The leader value is *bogus*, just here to get the output to
      validate!</xsl:variable>
    <xsl:comment>
      <xsl:value-of select="normalize-space($leaderComment)"/>
    </xsl:comment>
    <leader>01044ccm a2200301Ia 4500</leader>
  </xsl:template>

  <xsl:template name="controlField">
    <xsl:param name="tag"/>
    <xsl:param name="value"/>
    <controlfield tag="{$tag}">
      <xsl:value-of select="$value"/>
    </controlfield>
  </xsl:template>

  <xsl:template name="subfield">
    <xsl:param name="code"/>
    <xsl:param name="value"/>
    <xsl:param name="delimiter"/>
    <subfield code="{$code}">
      <xsl:value-of select="$value"/>
      <xsl:value-of select="$delimiter"/>
    </subfield>
  </xsl:template>

  <xsl:template match="mei:fileDesc">
    <!-- LEADER -->
    <xsl:call-template name="leader"/>

    <!-- CONTROL FIELDS -->
    <xsl:if test="../mei:altId">
      <xsl:apply-templates select="../mei:altId"/>
    </xsl:if>

    <!-- DATA FIELDS -->
    <!-- Call Number(s) -->
    <xsl:apply-templates select="//mei:classification//mei:term[contains(@analog, 'marc:090') or
      contains(@analog, 'marc:050') or contains(@analog, 'marc:082')]"/>

    <!-- Main Entry -->
    <xsl:apply-templates select="mei:titleStmt/mei:respStmt/mei:persName[contains(@analog,
      'marc:100') or contains(@role, 'creator') or contains(@role, 'composer')] |
      mei:titleStmt/mei:respStmt/mei:corpName[contains(@analog, 'marc:110') or contains(@role,
      'creator') or contains(@role, 'composer')]"/>

    <!-- Titles -->
    <!-- Uniform Title -->
    <xsl:choose>
      <xsl:when test="mei:titleStmt/mei:title[contains(@analog, 'marc:240') or contains(@type,
        'uniform')]">
        <xsl:apply-templates select="mei:titleStmt/mei:title[contains(@analog, 'marc:240') or
          contains(@type, 'uniform')]"/>
      </xsl:when>
      <xsl:when
        test="ancestor::mei:meiHead/mei:workDesc/mei:work/mei:titleStmt/mei:title[contains(@analog,
        'marc:240') or contains(@type, 'uniform')]">
        <xsl:apply-templates
          select="ancestor::mei:meiHead/mei:workDesc/mei:work/mei:titleStmt/mei:title[contains(@analog,
          'marc:240') or contains(@type, 'uniform')]"/>
      </xsl:when>
    </xsl:choose>

    <!-- Title Proper -->
    <xsl:choose>
      <xsl:when test="mei:titleStmt/mei:title[contains(@analog, 'marc:245') or contains(@type,
        'proper')]">
        <xsl:apply-templates select="mei:titleStmt/mei:title[contains(@analog, 'marc:245') or
          contains(@type, 'proper')]"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="mei:titleStmt/mei:title[not(contains(@type,
          'subtitle')) and not(contains(@type, 'uniform')) and not(contains(@analog,
          'marc:240'))][1]"/>
      </xsl:otherwise>
    </xsl:choose>

    <!-- Publication -->
    <xsl:apply-templates select="mei:pubStmt"/>

    <!-- Physical Description -->

    <!-- Subject classification -->
    <xsl:apply-templates select="//mei:classification//mei:term[contains(@analog, 'marc:650')]"/>

    <!-- Added Entries -->
    <xsl:apply-templates select="mei:titleStmt/mei:respStmt/mei:persName[contains(@analog,
      'marc:700')]"/>
    <xsl:apply-templates select="mei:titleStmt/mei:respStmt/mei:corpName[contains(@analog,
      'marc:710')]"/>
    <xsl:apply-templates select="mei:titleStmt/mei:respStmt/mei:persName[not(@analog) and
      not(contains(@role, 'creator') or contains(@role, 'composer'))]"/>
    <xsl:apply-templates select="mei:titleStmt/mei:respStmt/mei:corpName[not(@analog) and
      not(contains(@role, 'creator') or contains(@role, 'composer'))]"/>
  </xsl:template>

  <xsl:template match="mei:term">
    <datafield>
      <xsl:variable name="tag">
        <xsl:value-of select="substring-after(@analog, ':')"/>
      </xsl:variable>
      <xsl:attribute name="tag">
        <xsl:value-of select="$tag"/>
      </xsl:attribute>
      <xsl:call-template name="indicators"/>
      <xsl:call-template name="subfield">
        <xsl:with-param name="code">a</xsl:with-param>
        <xsl:with-param name="value">
          <xsl:value-of select="."/>
        </xsl:with-param>
      </xsl:call-template>
    </datafield>
  </xsl:template>

  <xsl:template match="mei:altId | mei:*[contains(@analog, 'marc:001')]">
    <xsl:call-template name="controlField">
      <xsl:with-param name="tag">001</xsl:with-param>
      <xsl:with-param name="value">
        <xsl:value-of select="."/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>

  <xsl:template match="mei:fileDesc/mei:pubStmt">
    <datafield>
      <xsl:attribute name="tag">
        <xsl:text>260</xsl:text>
      </xsl:attribute>
      <xsl:call-template name="indicators"/>
      <xsl:call-template name="subfield">
        <xsl:with-param name="code">a</xsl:with-param>
        <xsl:with-param name="value">
          <xsl:variable name="pubPlace">
            <xsl:choose>
              <xsl:when test="mei:pubPlace">
                <xsl:value-of select="mei:pubPlace"/>
              </xsl:when>
              <xsl:when test="mei:address">
                <xsl:for-each select="mei:address[1]">
                  <xsl:for-each select="mei:addrLine">
                    <xsl:value-of select="."/>
                    <xsl:if test="position() != last()">
                      <xsl:text>, &#32;</xsl:text>
                    </xsl:if>
                  </xsl:for-each>
                </xsl:for-each>
              </xsl:when>
            </xsl:choose>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not($pubPlace = '')">
              <xsl:value-of select="normalize-space($pubPlace)"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>[s.l.]</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
        <!--<xsl:with-param name="delimiter">: </xsl:with-param>-->
      </xsl:call-template>
      <xsl:call-template name="subfield">
        <xsl:with-param name="code">b</xsl:with-param>
        <xsl:with-param name="value">
          <xsl:variable name="publisher">
            <xsl:choose>
              <xsl:when test="mei:publisher">
                <xsl:value-of select="mei:publisher"/>
              </xsl:when>
              <xsl:when test="mei:respStmt/mei:corpName">
                <xsl:value-of select="mei:respStmt/mei:corpName"/>
              </xsl:when>
            </xsl:choose>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not($publisher = '')">
              <xsl:value-of select="normalize-space($publisher)"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>[s.n.]</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
        <!--<xsl:with-param name="delimiter">, </xsl:with-param>-->
      </xsl:call-template>
      <xsl:call-template name="subfield">
        <xsl:with-param name="code">c</xsl:with-param>
        <xsl:with-param name="value">
          <xsl:variable name="date">
            <xsl:choose>
              <xsl:when test="contains(mei:date, '-')">
                <xsl:value-of select="substring-before(mei:date, '-')"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="mei:date"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not($date = '')">
              <xsl:value-of select="$date"/>
            </xsl:when>
            <xsl:otherwise>[n.d.]</xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
      </xsl:call-template>
    </datafield>
  </xsl:template>

  <xsl:template name="indicators">
    <xsl:param name="ind1" xml:space="preserve">&#32;</xsl:param>
    <xsl:param name="ind2" xml:space="preserve">&#32;</xsl:param>
    <xsl:attribute name="ind1">
      <xsl:value-of select="$ind1"/>
    </xsl:attribute>
    <xsl:attribute name="ind2">
      <xsl:value-of select="$ind2"/>
    </xsl:attribute>
  </xsl:template>

  <xsl:template match="mei:persName">
    <datafield>
      <xsl:attribute name="tag">
        <xsl:choose>
          <xsl:when test="@analog">
            <xsl:value-of select="substring-after(@analog, ':')"/>
          </xsl:when>
          <xsl:when test="contains(@role, 'composer') or contains(@role, 'creator')">
            <xsl:text>100</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>700</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:call-template name="indicators"/>
      <xsl:choose>
        <!-- Only text; subfield |a only -->
        <xsl:when test="count(mei:*) = 0">
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">a</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="."/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <!-- Mixed content; split into multiple subfields -->
        <xsl:otherwise>
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">a</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:variable name="name">
                <xsl:value-of select="text()"/>
              </xsl:variable>
              <xsl:value-of select="normalize-space($name)"/>
            </xsl:with-param>
          </xsl:call-template>
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">d</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="mei:date"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="@dbkey">
        <xsl:call-template name="subfield">
          <xsl:with-param name="code">0</xsl:with-param>
          <xsl:with-param name="value">
            <xsl:value-of select="@dbkey"/>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:if>
      <xsl:if test="ancestor::mei:respStmt/mei:resp or @role">
        <xsl:variable name="role">
          <xsl:choose>
            <xsl:when test="ancestor::mei:respStmt/mei:resp">
              <xsl:value-of select="ancestor::mei:respStmt/mei:resp"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@role"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="relatorCode">
          <xsl:choose>
            <xsl:when test="$role = 'arranger'">arr</xsl:when>
            <xsl:when test="$role = 'artist'">art</xsl:when>
            <xsl:when test="$role = 'associated name'">asn</xsl:when>
            <xsl:when test="$role = 'author'">aut</xsl:when>
            <xsl:when test="$role = 'binder'">bnd</xsl:when>
            <xsl:when test="$role = 'bookseller'">bsl</xsl:when>
            <xsl:when test="$role = 'conceptor'">ccp</xsl:when>
            <xsl:when test="$role = 'choreographer'">chr</xsl:when>
            <xsl:when test="$role = 'collaborator'">clb</xsl:when>
            <xsl:when test="$role = 'composer'">cmp</xsl:when>
            <xsl:when test="$role = 'conductor'">cnd</xsl:when>
            <xsl:when test="$role = 'censor'">cns</xsl:when>
            <xsl:when test="$role = 'compiler'">com</xsl:when>
            <xsl:when test="$role = 'costume designer'">cst</xsl:when>
            <xsl:when test="$role = 'dancer'">dnc</xsl:when>
            <xsl:when test="$role = 'donor'">dnr</xsl:when>
            <xsl:when test="$role = 'dedicatee'">dte</xsl:when>
            <xsl:when test="$role = 'dubious'">dub</xsl:when>
            <xsl:when test="$role = 'editor'">edt</xsl:when>
            <xsl:when test="$role = 'encoder'">mrk</xsl:when>
            <xsl:when test="$role = 'engraver'">egr</xsl:when>
            <xsl:when test="$role = 'former owner'">fmo</xsl:when>
            <xsl:when test="$role = 'illustrator'">ill</xsl:when>
            <xsl:when test="$role = 'instrumentalist'">itr</xsl:when>
            <xsl:when test="$role = 'librettist'">lbt</xsl:when>
            <xsl:when test="$role = 'lithograph'">ltg</xsl:when>
            <xsl:when test="$role = 'lyricist'">lyr</xsl:when>
            <xsl:when test="$role = 'event organizer'">otm</xsl:when>
            <xsl:when test="$role = 'patron'">pat</xsl:when>
            <xsl:when test="$role = 'publisher'">pbl</xsl:when>
            <xsl:when test="$role = 'paper maker'">ppm</xsl:when>
            <xsl:when test="$role = 'production personnel'">prd</xsl:when>
            <xsl:when test="$role = 'performer'">prf</xsl:when>
            <xsl:when test="$role = 'printer'">prt</xsl:when>
            <xsl:when test="$role = 'scribe'">scr</xsl:when>
            <xsl:when test="$role = 'translator'">trl</xsl:when>
            <xsl:when test="$role = 'vocalist'">voc</xsl:when>
          </xsl:choose>
        </xsl:variable>
        <xsl:if test="not($relatorCode = '')">
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">4</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="$relatorCode"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:if>
      </xsl:if>
    </datafield>
  </xsl:template>

  <xsl:template match="mei:corpName">
    <datafield>
      <xsl:attribute name="tag">
        <xsl:choose>
          <xsl:when test="@analog">
            <xsl:value-of select="substring-after(@analog, ':')"/>
          </xsl:when>
          <xsl:otherwise>710</xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:call-template name="indicators"/>
      <xsl:choose>
        <!-- Only text; subfield |a only -->
        <xsl:when test="count(mei:*) = 0">
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">a</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="."/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <!-- Mixed content; split into multiple subfields -->
        <xsl:otherwise>
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">a</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="text()"/>
            </xsl:with-param>
          </xsl:call-template>
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">d</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="mei:date"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="@dbkey">
        <xsl:call-template name="subfield">
          <xsl:with-param name="code">0</xsl:with-param>
          <xsl:with-param name="value">
            <xsl:value-of select="@dbkey"/>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:if>
    </datafield>
  </xsl:template>

  <xsl:template match="mei:title[@type='uniform' or @analog='marc:240']">
    <xsl:variable name="tag">
      <xsl:text>240</xsl:text>
    </xsl:variable>
    <datafield>
      <xsl:attribute name="tag" select="$tag"/>
      <xsl:call-template name="indicators"/>
      <xsl:choose>
        <xsl:when test="mei:title[matches(@analog, 'marc:\d\d\d[a-z]')]">
          <xsl:for-each select="mei:title[matches(@analog, 'marc:\d\d\d[a-z]')]">
            <xsl:variable name="code">
              <xsl:value-of select="substring(@analog, string-length(@analog), 1)"/>
            </xsl:variable>
            <xsl:call-template name="subfield">
              <xsl:with-param name="code">
                <xsl:value-of select="$code"/>
              </xsl:with-param>
              <xsl:with-param name="value">
                <xsl:value-of select="."/>
              </xsl:with-param>
            </xsl:call-template>
          </xsl:for-each>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="subfield">
            <xsl:with-param name="code">a</xsl:with-param>
            <xsl:with-param name="value">
              <xsl:value-of select="."/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </datafield>
  </xsl:template>

  <xsl:template match="mei:title[@type='proper' or @analog='marc:245'] | mei:title">
    <xsl:variable name="tag" select="'245'"/>
    <datafield>
      <xsl:attribute name="tag" select="$tag"/>
      <xsl:call-template name="indicators"/>
      <xsl:call-template name="subfield">
        <xsl:with-param name="code">a</xsl:with-param>
        <xsl:with-param name="value">
          <xsl:value-of select="."/>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:if test="$tag='245' and ../mei:title[contains(@type, 'subtitle')]">
        <xsl:call-template name="subfield">
          <xsl:with-param name="code">b</xsl:with-param>
          <xsl:with-param name="value">
            <xsl:value-of select="../mei:title[contains(@type, 'subtitle')]"/>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:if>
    </datafield>
  </xsl:template>

</xsl:stylesheet>
