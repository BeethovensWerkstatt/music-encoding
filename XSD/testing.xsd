<?xml version="1.0" encoding="UTF-8"?>
<!-- ************************************************************** -->
<!--
  NAME:     Music Encoding Initiative (MEI) DTD
            File      = mei19b.dtd (version 1.9b) **DRAFT**
                        **DO NOT REDISTRIBUTE**
            Vers Date = 2009/05/01
  
  NOTICE:   Copyright (c) 2009 Perry Roland and the Rector and Visitors
            of the University of Virginia.
  
            Licensed under the Educational Community License version 1.0.
  
            This Original Work, including software, source code,
            documents, or other related items, is being provided by the
            copyright holder(s) subject to the terms of the Educational
            Community License. By obtaining, using and/or copying this
            Original Work, you agree that you have read, understand, and
            will comply with the following terms and conditions of the
            Educational Community License:
  
            Permission to use, copy, modify, merge, publish, distribute,
            and sublicense this Original Work and its documentation, with
            or without modification, for any purpose, and without fee or
            royalty to the copyright holder(s) is hereby granted, provided
            that you include the following on ALL copies of the Original
            Work or portions thereof, including modifications or
            derivatives, that you make:
  
            The full text of the Educational Community License in a
            location viewable to users of the redistributed or derivative
            work. 
  
            Any pre-existing intellectual property disclaimers, notices,
            or terms and conditions. 
  
            Notice of any changes or modifications to the Original Work,
            including the date the changes were made. 
  
            Any modifications of the Original Work must be distributed in
            such a manner as to avoid any confusion with the Original Work
            of the copyright holders.
  
            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
            KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
            WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
            PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
            COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
            SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
            The name and trademarks of copyright holder(s) may NOT be used
            in advertising or publicity pertaining to the Original or
            Derivative Works without specific, written prior permission.
            Title to copyright in the Original Work and any associated
            documentation will at all times remain with the copyright
            holders.
  
  PURPOSE:  This XML DTD is intended for the representation and exchange
            of mensural, neume, and common music notation (CMN).
  
            The semantic information contained in the MEI file may be
            related to, and/or synchronized with, external digital image,
            audio, or MIDI files.
  
            In addition to music notation, this DTD provides the means to
            transcribe the additional text typically found in a critical
            or historical music edition. The DTD also facilitates the
            encoding of multiple versions of a musical work in a single
            file.        
  
  AUTHOR:   Perry Roland
            pdr4h@virginia.edu
            University of Virginia
            Charlottesville, VA 22903
  
  NOTE:     This is a beta version XML DTD. Comments and suggestions
            are welcome.
-->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- * Default parameter entity values                            * -->
<!-- ************************************************************** -->
<!-- Module inclusion -->
<!--
  The meiShared, meiHeader, and meiStructure modules should always
  be included
-->
<!-- ************************************************************** -->
<!-- * Generic Identifiers (By Module)                            * -->
<!-- ************************************************************** -->
<!-- Basic text elements -->
<!-- Notation Elements in Multiple Repertoires -->
<!-- Neume, mensural, and CMN: -->
<!-- Structure/definition -->
<!-- Events -->
<!-- Control Events -->
<!-- Neume and mensural: -->
<!-- Structure/definition -->
<!-- Events -->
<!-- Control Events -->
<!--
  There are no control events currently defined for the
  neume and mensural combination.
-->
<!-- Neume and CMN: -->
<!-- Structure/definition -->
<!--
  There are no structure/definition elements currently defined for
  the neume and CMN combination.
-->
<!-- Events -->
<!--
  There are no events currently defined for the neume and CMN
  combination.
-->
<!-- Control Events -->
<!--
  There are no control events currently defined for the neume and
  CMN combination.
-->
<!-- Mensural and CMN: -->
<!-- Structure/definition -->
<!-- Events -->
<!--
  The dot element is an event in mensural notation,
  but is a note modifier in CMN.
-->
<!-- Control Events -->
<!--
  There are no control events currently defined for the mensural and CMN
  combination.
-->
<!-- Structural Elements -->
<!-- Header -->
<!-- Neume Notation Elements -->
<!-- Structure/definition -->
<!-- Events -->
<!-- Control Events -->
<!--
  There are currently no control events defined for neume-only
  notation.
-->
<!-- Mensural Notation Elements -->
<!-- Structure/definition -->
<!-- Events -->
<!-- Control Events -->
<!-- Add corona? -->
<!-- CMN Elements -->
<!-- Structure/definition -->
<!-- Measure and measure-like elements; i.e., ossia -->
<!-- Events -->
<!--
  The following elements constitute a special event class:
  these elements are often the only event in a measure.
-->
<!-- Control events -->
<!-- Text Components -->
<!-- Figures -->
<!-- Additional Names and Dates -->
<!-- Pointers and References -->
<!-- Lyrics -->
<!-- CMN Ornaments -->
<!-- Harmony -->
<!-- Graphic Primitives and User-defined Symbols -->
<!-- Critical apparatus -->
<!-- MIDI -->
<!-- Editorial/Transcription -->
<!-- Facsimile -->
<!-- Linking and Alignment -->
<!-- ************************************************************** -->
<!-- * MEI datatypes                                              * -->
<!-- ************************************************************** -->
<!--
  These parameter entities are used as keywords to express rules or
  constraints which cannot be fully expressed in attribute declarations;
  their expansions show the nearest available equivalent.
-->
<!--
  doc: A beat location, i.e., [0-9]+(\.?[0-9]*)? The value must fall
  between 0 and the numerator of the time signature + 1, where 0
  represents the left barline and the upper bound represents the right
  barline.  For example, in 12/8 the value must be in the range from 0 to
  13.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:simpleType name="data.BEAT">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: EITHER a hexadecimal color value, ie., x[0-9A-Fa-f]{6,6} OR a
    descriptive word, i.e., aqua, black, blue, fuchsia, gray, green, lime,
    maroon, navy, olive, purple, red, silver, teal, white, or yellow, for
    colors defined by the HTML 4.01 specification.
  -->
  <xs:simpleType name="data.COLOR">
    <xs:restriction base="xs:NMTOKEN"/>
  </xs:simpleType>
  <!--
    doc: 360th-unit measure of a cirle's circumference; optionally signed
    decimal number, i.e., [+-]?[0-9]+(\.?[0-9]*)?
  -->
  <xs:simpleType name="data.DEGREES">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: if not supplied, the value is inherited from an ancestor node -->
  <!-- doc: unsigned positive integer values including '0', i.e., [0-9]+ -->
  <xs:simpleType name="data.INTEGERNONNEGATIVE">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: unsigned positive integer values excluding '0', i.e., 1 to
    infinity.
  -->
  <xs:simpleType name="data.INTEGERPOSITIVE">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: ISO date format: YYYYMMDD -->
  <xs:simpleType name="data.ISODATE">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
     doc: ISO 24-hour time format: HH:MM:SS.ss, i.e.,
    [0-9][0-9]:[0-9][0-9]:[0-9][0-9](\.?[0-9]*)?
  -->
  <xs:simpleType name="data.ISOTIME">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: A duration expressed as a count of measures plus a beat location,
    i.e., [0-9]+m *\+ *[0-9]+(\.?[0-9]*)?, e.g., dur="1m + 3.5" indicates a
    duration of 1 measure plus 3 and one half beats or, in other words, on
    the 2nd half of the 3rd beat of the next measure. The measure number
    must be in the range of 0 to the number of remaining measures and the
    beat number must be in the range from 0 to the numerator of the time
    signature plus 1.  For example, for an event starting in the first
    measure of a piece containing 6 measures in 6/8, the measure number must
    be between 0 to 5 and the beat number must be within the range from 0 to
    7, e.g., "4m+3".
  -->
  <xs:simpleType name="data.MEASUREBEAT">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: MIDI quarter notes per minute: positive integer in the range
    10-1000
  -->
  <xs:simpleType name="data.MIDITEMPO">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: optionally signed decimal number, i.e., [+-]?[0-9]+(\.?[0-9]*)? -->
  <xs:simpleType name="data.NUMBER">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: unsigned positive decimal values excluding '0', i.e., 1 to
    infinity.
  -->
  <xs:simpleType name="data.NUMBERPOSITIVE">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: positive decimal number plus '%', i.e., [0-9]+(\.?[0-9]*)?\% -->
  <xs:simpleType name="data.PERCENT">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: if not supplied, the value should be obtained from a previous
    event in the *same measure*
  -->
  <!--
     doc: a ratio, i.e., [0-9]+(\.?[0-9]*)?:[0-9]+(\.?[0-9]*)?  For example,
    "40:7.2319"
  -->
  <!--
    doc: In string tablature, the number of the string to be played, i.e.,
    [1-9]+.
  -->
  <xs:simpleType name="data.STRINGNUMBER">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: Beats (meter signature denominator) per minute, e.g. 120. -->
  <xs:simpleType name="data.TEMPOVALUE">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: A positive or negative offset from the value given in the tstamp
    attribute. The datatype of this attribute must be the same as that of
    the tstamp, tstamp.ges, or tstamp.real attribute.
  -->
  <xs:simpleType name="data.TSTAMPOFFSET">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: a Uniform Resource Identifier, see [RFC2396] -->
  <xs:simpleType name="data.URI">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: an xPath expression -->
  <!-- doc: a fragment identifier in xPointer syntax -->
  <!--
    doc: Accidental attribute values: s = sharp, f = flat, ss = dblsharp,
    x=dblsharp, ff = dblflat, n = natural, nf = naturalflat, ns =
    naturalsharp. ss indicates the use of 2 sharp signs, while x indicates
    the use of a single double sharp. nf and ns are used to cancel dbflats
    and dblsharps, respectively. su = sharp note qtr. tone up, sd = sharp
    note qtr. tone down, fu = flat note qtr. tone up, fd = flat note qtr.
    tone down, nu = natural note qtr. tone up, nd = natural note quarter
    tone down. Quarter-tone accidentals listed in Read, p. 145.
  -->
  <xs:simpleType name="data.ACCIDENTAL.EXPLICIT">
    <xs:restriction base="xs:token">
      <xs:enumeration value="s"/>
      <xs:enumeration value="f"/>
      <xs:enumeration value="ss"/>
      <xs:enumeration value="x"/>
      <xs:enumeration value="ff"/>
      <xs:enumeration value="n"/>
      <xs:enumeration value="nf"/>
      <xs:enumeration value="ns"/>
      <xs:enumeration value="su"/>
      <xs:enumeration value="sd"/>
      <xs:enumeration value="fu"/>
      <xs:enumeration value="fd"/>
      <xs:enumeration value="nu"/>
      <xs:enumeration value="nd"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="data.ACCIDENTAL.IMPLICIT">
    <xs:restriction base="xs:token">
      <xs:enumeration value="s"/>
      <xs:enumeration value="f"/>
      <xs:enumeration value="ss"/>
      <xs:enumeration value="ff"/>
      <xs:enumeration value="n"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: The following list of articulations mostly corresponds to symbols
    1D110-1D111, 1D17B-1D182, 1D185-1D189, 1D1AA-1D1AD, 1D1B3-1D1B5 from
    the Western Musical Symbols portion of the Unicode Standard, v. 3.1.
    The dot and stroke values may be used in cases where interpretation is
    not desirable.
  -->
  <xs:simpleType name="data.ARTICULATION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="acc"/>
      <xs:enumeration value="stacc"/>
      <xs:enumeration value="ten"/>
      <xs:enumeration value="stacciss"/>
      <xs:enumeration value="marc"/>
      <xs:enumeration value="marc-stacc"/>
      <xs:enumeration value="acc-marc"/>
      <xs:enumeration value="loure"/>
      <xs:enumeration value="spicc"/>
      <xs:enumeration value="rip"/>
      <xs:enumeration value="doit"/>
      <xs:enumeration value="plop"/>
      <xs:enumeration value="fall"/>
      <xs:enumeration value="bend"/>
      <xs:enumeration value="flip"/>
      <xs:enumeration value="smear"/>
      <xs:enumeration value="dnbow"/>
      <xs:enumeration value="upbow"/>
      <xs:enumeration value="harm"/>
      <xs:enumeration value="snap"/>
      <xs:enumeration value="fingernail"/>
      <xs:enumeration value="damp"/>
      <xs:enumeration value="dampall"/>
      <xs:enumeration value="open"/>
      <xs:enumeration value="stop"/>
      <xs:enumeration value="dbltongue"/>
      <xs:enumeration value="trpltongue"/>
      <xs:enumeration value="heel"/>
      <xs:enumeration value="toe"/>
      <xs:enumeration value="tap"/>
      <xs:enumeration value="pluck"/>
      <xs:enumeration value="dot"/>
      <xs:enumeration value="stroke"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: 1 or more from the list given in the definition of the
    ARTICULATION entity. Changing this to CDATA, however, would allow the
    use of character entities.
  -->
  <xs:simpleType name="data.ARTICULATIONS">
    <xs:restriction base="xs:NMTOKENS"/>
  </xs:simpleType>
  <!--
    doc: Dots attribute values (number of augmentation dots) (Read,
    113-119, ex. 8-21)
  -->
  <xs:simpleType name="data.AUGMENTDOT">
    <xs:restriction base="xs:token">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Placement of barlines: between staves only, between and across
    staves as necessary, short line above staff or through top line
  -->
  <xs:simpleType name="data.BARPLACE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="mensur"/>
      <xs:enumeration value="staff"/>
      <xs:enumeration value="takt"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Renderings of barlines -->
  <xs:simpleType name="data.BARRENDITION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="dashed"/>
      <xs:enumeration value="dotted"/>
      <xs:enumeration value="dbl"/>
      <xs:enumeration value="dbldashed"/>
      <xs:enumeration value="dbldotted"/>
      <xs:enumeration value="end"/>
      <xs:enumeration value="invis"/>
      <xs:enumeration value="rptstart"/>
      <xs:enumeration value="rptboth"/>
      <xs:enumeration value="rptend"/>
      <xs:enumeration value="single"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Beam attribute values: initial, medial, terminal. Nested beaming
    is permitted.
  -->
  <!-- doc: 1 or more from the list given in the definition of the BEAM entity. -->
  <xs:simpleType name="data.BEAMS">
    <xs:restriction base="xs:NMTOKENS"/>
  </xs:simpleType>
  <!-- doc: Boolean attribute values -->
  <xs:simpleType name="data.BOOLEAN">
    <xs:restriction base="xs:token">
      <xs:enumeration value="true"/>
      <xs:enumeration value="false"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Values for certainty attribute -->
  <xs:simpleType name="data.CERTAINTY">
    <xs:restriction base="xs:token">
      <xs:enumeration value="high"/>
      <xs:enumeration value="medium"/>
      <xs:enumeration value="low"/>
      <xs:enumeration value="unknown"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Clef line attribute values -->
  <xs:simpleType name="data.CLEFLINE">
    <xs:restriction base="data.INTEGERPOSITIVE"/>
  </xs:simpleType>
  <!--
    doc: 1 or more from the list given in the definition of the CLEFLINE
    entity. Changing this to CDATA would allow the use of character
    entities.
  -->
  <!-- doc: Clef shape attribute values (Read, p.53-56) -->
  <xs:simpleType name="data.CLEFSHAPE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="G"/>
      <xs:enumeration value="GG"/>
      <xs:enumeration value="F"/>
      <xs:enumeration value="C"/>
      <xs:enumeration value="perc"/>
      <xs:enumeration value="TAB"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: 1 or more from the list given in the definition of the CLEFSHAPE
    entity. Changing this to CDATA would allow the use of character
    entities.
  -->
  <!-- doc: Clef trans attribute values -->
  <xs:simpleType name="data.CLEFTRAN">
    <xs:restriction base="xs:token">
      <xs:enumeration value="8va"/>
      <xs:enumeration value="8vb"/>
      <xs:enumeration value="15va"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Tone-clusters -->
  <xs:simpleType name="data.CLUSTER">
    <xs:restriction base="xs:token">
      <xs:enumeration value="whbox"/>
      <xs:enumeration value="blbox"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Renderings of curves -->
  <xs:simpleType name="data.CURVERENDITION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="medium"/>
      <xs:enumeration value="wide"/>
      <xs:enumeration value="dashed"/>
      <xs:enumeration value="dotted"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Logical, that is, written, duration attribute values. Whole note
    duration = '1'.
  -->
  <xs:simpleType name="data.DURATION.BASE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="long"/>
      <xs:enumeration value="breve"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="16"/>
      <xs:enumeration value="32"/>
      <xs:enumeration value="64"/>
      <xs:enumeration value="128"/>
      <xs:enumeration value="256"/>
      <xs:enumeration value="512"/>
      <xs:enumeration value="1024"/>
      <xs:enumeration value="2048"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="data.DURATION.MEN">
    <xs:restriction base="xs:token">
      <xs:enumeration value="maxima"/>
      <xs:enumeration value="longa"/>
      <xs:enumeration value="brevis"/>
      <xs:enumeration value="semibrevis"/>
      <xs:enumeration value="minima"/>
      <xs:enumeration value="semiminima"/>
      <xs:enumeration value="fusa"/>
      <xs:enumeration value="semifusa"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="data.DURATION">
    <xs:restriction base="data.DURATION.BASE"/>
  </xs:simpleType>
  <xs:simpleType name="data.DURATION.MENSURAL">
    <xs:restriction base="data.DURATION.MEN"/>
  </xs:simpleType>
  <xs:simpleType name="data.DURATIONS">
    <xs:union memberTypes="data.DURATION.BASE data.DURATION.MEN"/>
  </xs:simpleType>
  <!-- doc: Enclosures for editorial notes and accidentals -->
  <xs:simpleType name="data.ENCLOSURE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="paren"/>
      <xs:enumeration value="brack"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Font family (for text) attribute values
    Mup-acceptable values: <!ENTITY % FONTFAMILY
                         '(avantgarde|bookman|courier|helvetica|
                         newcentury|palatino|times)'>
  -->
  <xs:simpleType name="data.FONTFAMILY">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: Font name (for text) attribute values
    Mup-acceptable values: <!ENTITY % FONTNAME  '(rom|ital|bold|boldital)'>
  -->
  <xs:simpleType name="data.FONTNAME">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!-- doc: Font style (for text) attribute values -->
  <xs:simpleType name="data.FONTSTYLE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="ital"/>
      <xs:enumeration value="normal"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Font weight (for text) attribute values -->
  <xs:simpleType name="data.FONTWEIGHT">
    <xs:restriction base="xs:token">
      <xs:enumeration value="bold"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Fragment referencing method.  Setting this entity to '%data.XPATH;' or
    '%data.XPOINTER;' makes it possible to document the use of these methods.
  -->
  <xs:simpleType name="data.FRAGMENT">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: In string tablature, the fret number, i.e., [0-9]+. The value '0'
    indicates the open string.
  -->
  <xs:simpleType name="data.FRETNUMBER">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: Analytical glissando attribute values: i(nitial), m(edial),
    t(erminal)
  -->
  <xs:simpleType name="data.GLISSANDO">
    <xs:restriction base="xs:token">
      <xs:enumeration value="i"/>
      <xs:enumeration value="m"/>
      <xs:enumeration value="t"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Do grace notes get time from the current (acc) or previous (unacc)
    one?
  -->
  <xs:simpleType name="data.GRACE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="acc"/>
      <xs:enumeration value="unacc"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Allowed notehead shapes -->
  <xs:simpleType name="data.HEADSHAPE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="quarter"/>
      <xs:enumeration value="half"/>
      <xs:enumeration value="whole"/>
      <xs:enumeration value="dblwhole"/>
      <xs:enumeration value="filldiamond"/>
      <xs:enumeration value="diamond"/>
      <xs:enumeration value="dwdiamond"/>
      <xs:enumeration value="fillisotriangle"/>
      <xs:enumeration value="isotriangle"/>
      <xs:enumeration value="dwhisotriangle"/>
      <xs:enumeration value="fillpiewedge"/>
      <xs:enumeration value="piewedge"/>
      <xs:enumeration value="dwhpiewedge"/>
      <xs:enumeration value="fillrectangle"/>
      <xs:enumeration value="rectangle"/>
      <xs:enumeration value="dwhrectangle"/>
      <xs:enumeration value="fillrtriangle"/>
      <xs:enumeration value="rtriangle"/>
      <xs:enumeration value="dwrtriangle"/>
      <xs:enumeration value="fillurtriangle"/>
      <xs:enumeration value="urtriangle"/>
      <xs:enumeration value="dwurtriangle"/>
      <xs:enumeration value="fillsemicircle"/>
      <xs:enumeration value="semicircle"/>
      <xs:enumeration value="dwsemicircle"/>
      <xs:enumeration value="fillslash"/>
      <xs:enumeration value="slash"/>
      <xs:enumeration value="dwslash"/>
      <xs:enumeration value="x"/>
      <xs:enumeration value="blank"/>
      <xs:enumeration value="circlex"/>
      <xs:enumeration value="cross"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Interrupted neume, i.e. neumes written as 2 or more sub-neumes -->
  <xs:simpleType name="data.INEUMENAME">
    <xs:restriction base="xs:token">
      <xs:enumeration value="pessubpunctis"/>
      <xs:enumeration value="climacus"/>
      <xs:enumeration value="scandicus"/>
      <xs:enumeration value="bistropha"/>
      <xs:enumeration value="tristropha"/>
      <xs:enumeration value="pressusminor"/>
      <xs:enumeration value="pressusmaior"/>
      <xs:enumeration value="pressusliquescens"/>
      <xs:enumeration value="virgastrata"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Interrupted neume forms -->
  <xs:simpleType name="data.INEUMEFORM">
    <xs:restriction base="xs:token">
      <xs:enumeration value="liquescent1"/>
      <xs:enumeration value="liquescent2"/>
      <xs:enumeration value="tied"/>
      <xs:enumeration value="tiedliquescent1"/>
      <xs:enumeration value="tiedliquescent2"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Key signature is normally indicated by a value showing where the
    key is in the circle of fifths. Mixed key signatures, e.g. those
    consisting of a mixture of flats and sharps, and key signatures with
    unorthodox placement of the accidentals (Read, p. 143) must be
    indicated by setting the key.sig attribute to 'mixed' and providing
    explicit keysig info in the key.sig.mixed attribute.
  -->
  <xs:simpleType name="data.KEYSIGNATURE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="7f"/>
      <xs:enumeration value="6f"/>
      <xs:enumeration value="5f"/>
      <xs:enumeration value="4f"/>
      <xs:enumeration value="3f"/>
      <xs:enumeration value="2f"/>
      <xs:enumeration value="1f"/>
      <xs:enumeration value="0"/>
      <xs:enumeration value="1s"/>
      <xs:enumeration value="2s"/>
      <xs:enumeration value="3s"/>
      <xs:enumeration value="4s"/>
      <xs:enumeration value="5s"/>
      <xs:enumeration value="6s"/>
      <xs:enumeration value="7s"/>
      <xs:enumeration value="mixed"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Indicates how stems should be drawn when more than one layer is
    present and stem directions are not indicated on the notes/chords
    themselves. '1' indicates that there is only a single layer on a staff.
    '2o' means there are two layers with opposing stems. '2f' indicates
    two 'free' layers; that is, opposing stems will be drawn unless one of
    the layers has 'space'. In that case, stem direction in the remaining
    layer will be determined as if there were only one layer. '3o' and
    '3f' are analogous to '2o' and '2f' with three layers allowed. What
    about more than 3 layers?
  -->
  <xs:simpleType name="data.LAYERSCHEME">
    <xs:restriction base="xs:token">
      <xs:enumeration value="1"/>
      <xs:enumeration value="2o"/>
      <xs:enumeration value="2f"/>
      <xs:enumeration value="3o"/>
      <xs:enumeration value="3f"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Ligature forms -->
  <xs:simpleType name="data.LIGATUREFORM">
    <xs:restriction base="xs:token">
      <xs:enumeration value="recta"/>
      <xs:enumeration value="obliqua"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Renderings of lines -->
  <xs:simpleType name="data.LINERENDITION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="narrow"/>
      <xs:enumeration value="medium"/>
      <xs:enumeration value="wide"/>
      <xs:enumeration value="dashed"/>
      <xs:enumeration value="dotted"/>
      <xs:enumeration value="wavy"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Mensuration attribute values -->
  <xs:simpleType name="data.MENSURATIONSIGN">
    <xs:restriction base="xs:token">
      <xs:enumeration value="C"/>
      <xs:enumeration value="O"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Meter.sym attribute values for common-practice notation: -->
  <xs:simpleType name="data.METERSIGN">
    <xs:restriction base="xs:token">
      <xs:enumeration value="common"/>
      <xs:enumeration value="cut"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: MIDI channels -->
  <xs:simpleType name="data.MIDICHANNEL">
    <xs:restriction base="xs:token">
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="5"/>
      <xs:enumeration value="6"/>
      <xs:enumeration value="7"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="9"/>
      <xs:enumeration value="10"/>
      <xs:enumeration value="11"/>
      <xs:enumeration value="12"/>
      <xs:enumeration value="13"/>
      <xs:enumeration value="14"/>
      <xs:enumeration value="15"/>
      <xs:enumeration value="16"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: MIDI values are in the following range -->
  <xs:simpleType name="data.MIDIVALUE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="5"/>
      <xs:enumeration value="6"/>
      <xs:enumeration value="7"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="9"/>
      <xs:enumeration value="10"/>
      <xs:enumeration value="11"/>
      <xs:enumeration value="12"/>
      <xs:enumeration value="13"/>
      <xs:enumeration value="14"/>
      <xs:enumeration value="15"/>
      <xs:enumeration value="16"/>
      <xs:enumeration value="17"/>
      <xs:enumeration value="18"/>
      <xs:enumeration value="19"/>
      <xs:enumeration value="20"/>
      <xs:enumeration value="21"/>
      <xs:enumeration value="22"/>
      <xs:enumeration value="23"/>
      <xs:enumeration value="24"/>
      <xs:enumeration value="25"/>
      <xs:enumeration value="26"/>
      <xs:enumeration value="27"/>
      <xs:enumeration value="28"/>
      <xs:enumeration value="29"/>
      <xs:enumeration value="30"/>
      <xs:enumeration value="31"/>
      <xs:enumeration value="32"/>
      <xs:enumeration value="33"/>
      <xs:enumeration value="34"/>
      <xs:enumeration value="35"/>
      <xs:enumeration value="36"/>
      <xs:enumeration value="37"/>
      <xs:enumeration value="38"/>
      <xs:enumeration value="39"/>
      <xs:enumeration value="40"/>
      <xs:enumeration value="41"/>
      <xs:enumeration value="42"/>
      <xs:enumeration value="43"/>
      <xs:enumeration value="44"/>
      <xs:enumeration value="45"/>
      <xs:enumeration value="46"/>
      <xs:enumeration value="47"/>
      <xs:enumeration value="48"/>
      <xs:enumeration value="49"/>
      <xs:enumeration value="50"/>
      <xs:enumeration value="51"/>
      <xs:enumeration value="52"/>
      <xs:enumeration value="53"/>
      <xs:enumeration value="54"/>
      <xs:enumeration value="55"/>
      <xs:enumeration value="56"/>
      <xs:enumeration value="57"/>
      <xs:enumeration value="58"/>
      <xs:enumeration value="59"/>
      <xs:enumeration value="60"/>
      <xs:enumeration value="61"/>
      <xs:enumeration value="62"/>
      <xs:enumeration value="63"/>
      <xs:enumeration value="64"/>
      <xs:enumeration value="65"/>
      <xs:enumeration value="66"/>
      <xs:enumeration value="67"/>
      <xs:enumeration value="68"/>
      <xs:enumeration value="69"/>
      <xs:enumeration value="70"/>
      <xs:enumeration value="71"/>
      <xs:enumeration value="72"/>
      <xs:enumeration value="73"/>
      <xs:enumeration value="74"/>
      <xs:enumeration value="75"/>
      <xs:enumeration value="76"/>
      <xs:enumeration value="77"/>
      <xs:enumeration value="78"/>
      <xs:enumeration value="79"/>
      <xs:enumeration value="80"/>
      <xs:enumeration value="81"/>
      <xs:enumeration value="82"/>
      <xs:enumeration value="83"/>
      <xs:enumeration value="84"/>
      <xs:enumeration value="85"/>
      <xs:enumeration value="86"/>
      <xs:enumeration value="87"/>
      <xs:enumeration value="88"/>
      <xs:enumeration value="89"/>
      <xs:enumeration value="90"/>
      <xs:enumeration value="91"/>
      <xs:enumeration value="92"/>
      <xs:enumeration value="93"/>
      <xs:enumeration value="94"/>
      <xs:enumeration value="95"/>
      <xs:enumeration value="96"/>
      <xs:enumeration value="97"/>
      <xs:enumeration value="98"/>
      <xs:enumeration value="99"/>
      <xs:enumeration value="100"/>
      <xs:enumeration value="101"/>
      <xs:enumeration value="102"/>
      <xs:enumeration value="103"/>
      <xs:enumeration value="104"/>
      <xs:enumeration value="105"/>
      <xs:enumeration value="106"/>
      <xs:enumeration value="107"/>
      <xs:enumeration value="108"/>
      <xs:enumeration value="109"/>
      <xs:enumeration value="110"/>
      <xs:enumeration value="111"/>
      <xs:enumeration value="112"/>
      <xs:enumeration value="113"/>
      <xs:enumeration value="114"/>
      <xs:enumeration value="115"/>
      <xs:enumeration value="116"/>
      <xs:enumeration value="117"/>
      <xs:enumeration value="118"/>
      <xs:enumeration value="119"/>
      <xs:enumeration value="120"/>
      <xs:enumeration value="121"/>
      <xs:enumeration value="122"/>
      <xs:enumeration value="123"/>
      <xs:enumeration value="124"/>
      <xs:enumeration value="125"/>
      <xs:enumeration value="126"/>
      <xs:enumeration value="127"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Modes -->
  <xs:simpleType name="data.MODE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="major"/>
      <xs:enumeration value="minor"/>
      <xs:enumeration value="dorian"/>
      <xs:enumeration value="phrygian"/>
      <xs:enumeration value="lydian"/>
      <xs:enumeration value="mixolydian"/>
      <xs:enumeration value="aeolian"/>
      <xs:enumeration value="locrian"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Music font family -->
  <xs:simpleType name="data.MUSICFONT">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <!--
    doc: Oct attribute values. The default values conform to Acoustical
    Society of America representation. Read, p. 44. The entity name is
    plural so as not to conflict with the %octave entity used in the
    definition of the octave element.
  -->
  <xs:simpleType name="data.OCTAVE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="5"/>
      <xs:enumeration value="6"/>
      <xs:enumeration value="7"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="9"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Page scale factor datatype.  Setting this to %data.RATIO; allows
    page.scale attributes to contain a virtual units to real units conversion
    ratio.
  -->
  <xs:simpleType name="data.PGSCALE">
    <xs:restriction base="data.PERCENT"/>
  </xs:simpleType>
  <!-- doc: Unit attribute values -->
  <xs:simpleType name="data.PGUNITS">
    <xs:restriction base="xs:token">
      <xs:enumeration value="in"/>
      <xs:enumeration value="cm"/>
      <xs:enumeration value="mm"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Pclass (pitch class) attribute values -->
  <xs:simpleType name="data.PITCHCLASS">
    <xs:restriction base="xs:token">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="5"/>
      <xs:enumeration value="6"/>
      <xs:enumeration value="7"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="9"/>
      <xs:enumeration value="10"/>
      <xs:enumeration value="11"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: The pitch names (gamut) used within a single octave. The default
    values conform to Acoustical Society of America representation.
  -->
  <xs:simpleType name="data.PITCHNAME">
    <xs:restriction base="xs:token">
      <xs:enumeration value="a"/>
      <xs:enumeration value="b"/>
      <xs:enumeration value="c"/>
      <xs:enumeration value="d"/>
      <xs:enumeration value="e"/>
      <xs:enumeration value="f"/>
      <xs:enumeration value="g"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Gestural pitch names need an additional value for when the notated
    pitch is not to be played.
  -->
  <xs:simpleType name="data.PITCHNAME.GES">
    <xs:restriction base="xs:token">
      <xs:enumeration value="a"/>
      <xs:enumeration value="b"/>
      <xs:enumeration value="c"/>
      <xs:enumeration value="d"/>
      <xs:enumeration value="e"/>
      <xs:enumeration value="f"/>
      <xs:enumeration value="g"/>
      <xs:enumeration value="none"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Pnum (pitch number, e.g. MIDI) attribute values -->
  <xs:simpleType name="data.PITCHNUMBER">
    <xs:restriction base="data.INTEGERNONNEGATIVE"/>
  </xs:simpleType>
  <!--
    doc: Participant list referencing method.  Setting this entity to '%data.XPATH;'
    or '%data.XPOINTER;' makes it possible to document the use of these methods.
  -->
  <xs:simpleType name="data.PLIST">
    <xs:restriction base="xs:IDREFS"/>
  </xs:simpleType>
  <!-- doc: Place, i.e., relative location of musical material -->
  <xs:simpleType name="data.PLACE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="above"/>
      <xs:enumeration value="below"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Size attribute values -->
  <xs:simpleType name="data.SIZE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="normal"/>
      <xs:enumeration value="cue"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: i=initial, t=terminal. Number is used to match endpoints of the
    slur when slurs are nested or overlap, e.g. 
    <note slur='i1 i2'/><note slur='t1'/><note slur='t2'/> encodes the
    fact that two slurs begin on note 1, one which terminates on note 2
    and one which terminates on note 3. % SLUR isn't currently invoked in
    the DTD; it serves as documentation for the tokens that can be used
    where % SLURS is invoked.
  -->
  <!--
    doc: 1 or more from the list given in the definition of the SLUR
    entity.
  -->
  <xs:simpleType name="data.SLURS">
    <xs:restriction base="xs:NMTOKENS"/>
  </xs:simpleType>
  <!-- doc: Slur directions -->
  <xs:simpleType name="data.SLURDIRECTION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="up"/>
      <xs:enumeration value="down"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Staff location. Staff location includes staff lines, spaces, and
    the spaces directly above and below the staff. The value ranges between
    0 (just below the staff) to 2 * number of staff lines (directly above
    the staff).  For example, on a 5-line staff the lines would be numbered
    1,3,5,7, and 9 while the spaces would be numbered 0,2,4,6,8,10.
  -->
  <xs:simpleType name="data.STAFFLOC">
    <xs:restriction base="data.INTEGERNONNEGATIVE"/>
  </xs:simpleType>
  <!-- doc: Stem directions -->
  <xs:simpleType name="data.STEMDIRECTION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="up"/>
      <xs:enumeration value="down"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Stem modifications -->
  <xs:simpleType name="data.STEMMODIFIER">
    <xs:restriction base="xs:token">
      <xs:enumeration value="1slash"/>
      <xs:enumeration value="2slash"/>
      <xs:enumeration value="3slash"/>
      <xs:enumeration value="4slash"/>
      <xs:enumeration value="5slash"/>
      <xs:enumeration value="6slash"/>
      <xs:enumeration value="sprech"/>
      <xs:enumeration value="z"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Which side of stem? -->
  <xs:simpleType name="data.STEMPOSITION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="left"/>
      <xs:enumeration value="right"/>
      <xs:enumeration value="center"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Temperament -->
  <xs:simpleType name="data.TEMPERAMENT">
    <xs:restriction base="xs:token">
      <xs:enumeration value="equal"/>
      <xs:enumeration value="just"/>
      <xs:enumeration value="mean"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Text renditions -->
  <xs:simpleType name="data.TEXTRENDITION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="box"/>
      <xs:enumeration value="circle"/>
      <xs:enumeration value="dblunderline"/>
      <xs:enumeration value="none"/>
      <xs:enumeration value="quoted"/>
      <xs:enumeration value="smcaps"/>
      <xs:enumeration value="strike"/>
      <xs:enumeration value="sub"/>
      <xs:enumeration value="sup"/>
      <xs:enumeration value="underline"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Tie attribute values: initial, medial, terminal. -->
  <xs:simpleType name="data.TIE">
    <xs:restriction base="xs:token">
      <xs:enumeration value="i"/>
      <xs:enumeration value="m"/>
      <xs:enumeration value="t"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="data.TIEDIRECTION">
    <xs:restriction base="xs:token">
      <xs:enumeration value="up"/>
      <xs:enumeration value="down"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Tuplet attribute values: initial, medial, terminal. -->
  <xs:simpleType name="data.TUPLET">
    <xs:restriction base="xs:token">
      <xs:enumeration value="i1"/>
      <xs:enumeration value="i2"/>
      <xs:enumeration value="i3"/>
      <xs:enumeration value="i4"/>
      <xs:enumeration value="i5"/>
      <xs:enumeration value="i6"/>
      <xs:enumeration value="m1"/>
      <xs:enumeration value="m2"/>
      <xs:enumeration value="m3"/>
      <xs:enumeration value="m4"/>
      <xs:enumeration value="m5"/>
      <xs:enumeration value="m6"/>
      <xs:enumeration value="t1"/>
      <xs:enumeration value="t2"/>
      <xs:enumeration value="t3"/>
      <xs:enumeration value="t4"/>
      <xs:enumeration value="t5"/>
      <xs:enumeration value="t6"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- doc: Basic, i.e., single, uninterrupted, neume names. -->
  <xs:simpleType name="data.UNEUMENAME">
    <xs:restriction base="xs:token">
      <xs:enumeration value="punctum"/>
      <xs:enumeration value="virga"/>
      <xs:enumeration value="pes"/>
      <xs:enumeration value="clivis"/>
      <xs:enumeration value="torculus"/>
      <xs:enumeration value="torculusresupinus"/>
      <xs:enumeration value="porrectus"/>
      <xs:enumeration value="porrectusflexus"/>
      <xs:enumeration value="apostropha"/>
      <xs:enumeration value="oriscus"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="data.UNEUMEFORM">
    <xs:restriction base="xs:token">
      <xs:enumeration value="liquescent1"/>
      <xs:enumeration value="liquescent2"/>
      <xs:enumeration value="liquescent3"/>
      <xs:enumeration value="quilismatic"/>
      <xs:enumeration value="rectangular"/>
      <xs:enumeration value="rhombic"/>
      <xs:enumeration value="tied"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    doc: Visual, i.e. ho and vo, offsets are expressed in terms of staff
    interline distance; that is, in "stepsizes", which are half the distance
    between staff lines.
  -->
  <xs:simpleType name="data.VISUALOFFSET">
    <xs:restriction base="data.NUMBER"/>
  </xs:simpleType>
  <!-- ************************************************************** -->
  <!-- * Character Entities                                         * -->
  <!-- ************************************************************** -->
  <!-- ************************************************************** -->
  <!-- * Attribute classes                                          * -->
  <!-- ************************************************************** -->
  <!--
    doc: The when attribute indicates a particular kind of correspondence;
    i.e., temporal correspondence.  It should be used to point to when
    elements within one or more timeline elements.
  -->
  <xs:attributeGroup name="att.alignment">
    <xs:attribute name="when" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Bibliographic attributes: The analog attribute contains a reference
    to a field or element in another descriptive encoding system to which an
    MEI element is comparable. Mapping elements from one system to another
    may help a repository harvest selected data from the MEI file to build a
    basic catalog record. The encoding system from which fields are taken
    must be specified. When possible, subfields as well as fields should be
    specified, e.g., subfields within MARC fields. A display label for an
    element can be supplied using the label attribute when a meaningful
    label cannot be derived by a style sheet from the element name or when a
    head element is not available.
  -->
  <xs:attributeGroup name="att.bibl">
    <xs:attribute name="analog"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.color">
    <xs:attribute name="color" type="data.COLOR"/>
  </xs:attributeGroup>
  <!--
    doc: Common analytical attributes: corresp may be used to point to
    other events or control events that correspond to this event in some
    fashion.
  -->
  <xs:attributeGroup name="att.common.anl">
    <xs:attribute name="corresp" type="xs:IDREFS"/>
    <xs:attributeGroup ref="att.alignment"/>
  </xs:attributeGroup>
  <!--
    doc: Common attributes: Each id within a document must have a unique
    value. The id attribute regularizes the naming of the element and thus
    facilitates building links between it and other resources. The n attribute
    may be used to provide a label (name or number) for the element. This
    need not be unique.
  -->
  <xs:attributeGroup name="att.common">
    <xs:attribute name="id" type="xs:ID"/>
    <xs:attribute name="n" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!--
    doc: Control events rely on other events for their existence. For
    example, a slur/phrase marking must be drawn between or over a group of
    notes. The next attribute may be used to point to the next control
    event(s) in a user-defined collection while the prev attribute may point
    to the previous event(s). The plist (participant list) attribute may
    contain ID references or xPointer fragment identifiers (depending on
    how % PLIST is configured) which identify logical events which
    participate in the control event, e.g., notes under a phrase mark. The
    staff and layer attributes allow the control event to encode its scope
    of influence. The tstamp attribute encodes the onset time of a musical
    feature in terms of musical time, i.e., beats.  The tstamp.ges attribute
    may be used to record the onset time in pulses per quarter note (ppq,
    MusicXML divisions, or MIDI clicks) since the start of the measure, while
    the tstamp.real attribute records the onset time as a real-time offset, i.e.,
    HH:MM:SS.ss, since the beginning of the file.
  -->
  <xs:attributeGroup name="att.controlevent">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="next" type="xs:IDREFS"/>
    <xs:attribute name="plist" type="data.PLIST"/>
    <xs:attribute name="prev" type="xs:IDREFS"/>
    <xs:attribute name="staff" use="required" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tstamp" type="data.BEAT"/>
    <xs:attribute name="tstamp.ges" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="tstamp.real" type="data.ISOTIME"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.coordinated">
    <xs:attribute name="ulx" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="uly" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="lrx" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="lry" type="data.INTEGERNONNEGATIVE"/>
  </xs:attributeGroup>
  <!-- doc: Attributes common to all elements representing variant readings: -->
  <xs:attributeGroup name="att.crit">
    <xs:attribute name="cause" type="xs:NMTOKEN"/>
    <xs:attribute name="hand" type="xs:IDREF"/>
    <xs:attribute name="resp" type="xs:IDREF"/>
    <xs:attribute name="seq" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="source" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes common to dates: calendar indicates the system or
    calendar to which the date belongs, for example, Gregorian, Julian,
    Roman, Mosaic, Revolutionary, Islamic; cert indicates the degree of
    precision to be attributed to the date, e.g. ca., approx, after, before,
    etc.; from contains the starting point of a date range; notafter should
    contain an upper boundary for an uncertain date while notbefore should
    contain a lower boundary, e.g, &lt;date notbefore='1957'
    notafter='1960'>Feb. 5&lt;/date>; reg gives the value of the date in
    standard ISO form; to contains the end point of a date range.
  -->
  <xs:attributeGroup name="att.date">
    <xs:attribute name="calendar" type="xs:NMTOKEN"/>
    <xs:attribute name="cert" type="data.CERTAINTY"/>
    <xs:attribute name="from" type="data.ISODATE"/>
    <xs:attribute name="notafter" type="data.ISODATE"/>
    <xs:attribute name="notbefore" type="data.ISODATE"/>
    <xs:attribute name="reg" type="data.ISODATE"/>
    <xs:attribute name="to" type="data.ISODATE"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes describing the nature of an encoded scholarly
    intervention or interpretation: cert signifies the degree of certainty
    associated with the intervention or interpretation. evidence indicates
    the nature of the evidence supporting the reliability or accuracy of the
    intervention or interpretation. Suggested values include: 'internal',
    'external', 'conjecture'. The resp attribute indicates responsibility
    for the identification or content within the element to which it is
    attached. It must point to one of the identifiers declared in the
    document header, associated with a person asserted as responsible for
    some aspect of the text's creation, transcription, editing, or
    encoding. The source attribute contains a list of one or more pointers
    indicating the sources which support the given reading.
  -->
  <xs:attributeGroup name="att.edit">
    <xs:attribute name="cert" type="data.CERTAINTY"/>
    <xs:attribute name="evidence" type="xs:NMTOKEN"/>
    <xs:attribute name="resp" type="xs:IDREFS"/>
    <xs:attribute name="source" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes that apply to all written events, e.g. beam, beatrpt,
    chord, note, etc. The tstamp attribute encodes the onset time of a musical
    feature in terms of musical time, i.e., beats.  The tstamp.ges attribute
    may be used to record the onset time in pulses per quarter note (ppq,
    MusicXML divisions, or MIDI clicks) since the start of the measure, while
    the tstamp.real attribute records the onset time as a real-time offset, i.e.,
    HH:MM:SS.ss, since the beginning of the file.
  -->
  <xs:attributeGroup name="att.event">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="next" type="xs:IDREFS"/>
    <xs:attribute name="prev" type="xs:IDREFS"/>
    <xs:attribute name="staff" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tstamp" type="data.BEAT"/>
    <xs:attribute name="tstamp.ges" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="tstamp.real" type="data.ISOTIME"/>
  </xs:attributeGroup>
  <!--
    doc: All elements subscribing to this class may include one or more ID
    references to an image or to an image zone which corresponds with the
    element.
  -->
  <xs:attributeGroup name="att.facsimile">
    <xs:attribute name="facs" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes common to all linking elements: actuate defines whether
    a link occurs automatically or must be requested by the user. It is used
    in conjunction with the show attribute to determine link behavior. show
    defines whether a remote resource that is the target of a link appears
    at the point of the link, replaces the existing link, or appears in a
    new window. The targettype attribute allows the target resource to be
    characterized, using any convenient classification scheme or typology.
  -->
  <xs:attributeGroup name="att.link.common">
    <xs:attribute name="actuate">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="onLoad"/>
          <xs:enumeration value="onRequest"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="show">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="new"/>
          <xs:enumeration value="replace"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="targettype" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!--
    doc: Linking attributes for external referencing elements: entityref
    references a previously-declared entity which represents a complete
    document. The href attribute allows the use of an undeclared URI. The
    fragment attribute allows one to identify one or more sub-parts
    within the document being pointed to.
  -->
  <xs:attributeGroup name="att.link.external">
    <xs:attribute name="entityref" type="xs:ENTITY"/>
    <xs:attribute name="fragment" type="data.FRAGMENT"/>
    <xs:attribute name="href" type="data.URI"/>
  </xs:attributeGroup>
  <!-- doc: Linking attributes for internal referencing elements. -->
  <xs:attributeGroup name="att.link.internal">
    <xs:attribute name="plist" type="data.PLIST"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes common to MIDI events. %att.controlevent is expanded
    here in order to allow only the staff, layer, and tstamp attributes from
    this class. 
  -->
  <xs:attributeGroup name="att.midi.event">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="staff" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tstamp" type="data.BEAT"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes shared by names:  The dbkey attribute may be used to
    record a value which serves as a primary key in an external database.
    The reg attribute may be used to record a regularized form of the
    name.
  -->
  <xs:attributeGroup name="att.name">
    <xs:attribute name="key" type="xs:NMTOKEN"/>
    <xs:attribute name="reg"/>
  </xs:attributeGroup>
  <!--
    doc: Start and end attributes record the IDs of other elements to which
    the current element is associated.
  -->
  <xs:attributeGroup name="att.startendid">
    <xs:attribute name="endid" type="xs:IDREF"/>
    <xs:attribute name="startid" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes common to text elements: The lang attribute should be
    used to identify the language of the word or text phrase marked. Its
    value must be the identifier of a <language> element supplied in the
    MEI header of the current document.
  -->
  <xs:attributeGroup name="att.lang">
    <xs:attribute name="lang" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes for elements encoding authorial or scribal intervention
    when transcribing manuscript or similar sources: The hand attribute
    signifies the hand of the agent which made the intervention. Its value
    must be the ID of hand element declared in the header. The seq attribute
    may be used to assign a sequence number related to the order in which
    the encoded features carrying this attribute are believed to have
    occurred.
  -->
  <xs:attributeGroup name="att.trans">
    <xs:attribute name="hand" type="xs:IDREF"/>
    <xs:attribute name="seq" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Attributes which can be used to classify or subclassify elements in
    any way
  -->
  <xs:attributeGroup name="att.typed">
    <xs:attribute name="subtype" type="xs:NMTOKEN"/>
    <xs:attribute name="type" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!-- doc: Typographical attributes -->
  <xs:attributeGroup name="att.typography">
    <xs:attribute name="fontfam" type="data.FONTFAMILY"/>
    <xs:attribute name="fontname" type="data.FONTNAME"/>
    <xs:attribute name="fontsize" type="data.NUMBER"/>
    <xs:attribute name="fontstyle" type="data.FONTSTYLE"/>
    <xs:attribute name="fontweight" type="data.FONTWEIGHT"/>
  </xs:attributeGroup>
  <!--
    doc: Some items may have their location recorded in terms of offsets
    from their programmatically-determined location. The ho attribute
    records the horizontal offset while vo records the vertical. The to
    attribute holds a timestamp offset, the most common use of which is as
    an alternative to ho.
  -->
  <xs:attributeGroup name="att.visualoffset">
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="to" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="vo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!--
    doc: Some elements may have their exact "output" coordinates recorded: x
    and y indicate where to place the rendered output. Recording the
    coordinates of a feature in a facsimile requires the use of the facs
    attribute.
  -->
  <xs:attributeGroup name="att.xy">
    <xs:attribute name="x" type="data.NUMBER"/>
    <xs:attribute name="y" type="data.NUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.xy.required">
    <xs:attribute name="x" use="required" type="data.NUMBER"/>
    <xs:attribute name="y" use="required" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- doc: Some elements need 2 coordinate pairs -->
  <xs:attributeGroup name="att.xy2">
    <xs:attribute name="x2" type="data.NUMBER"/>
    <xs:attribute name="y2" type="data.NUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.xy2.required">
    <xs:attribute name="x2" use="required" type="data.NUMBER"/>
    <xs:attribute name="y2" use="required" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!--
    * Declare attributes in each musical domain, e.g. analytical,
    gestural, and visual, in separate parameter entities. This documents
    which domain an attribute operates in and makes it easier to modify
    the attributes in a given domain independently of the others. Declaring
    these here rather than in the individual tagsets makes them available
    in any new element models.                                        *
  -->
  <!-- ************************************************************** -->
  <!-- ************************************************************** -->
  <!-- * Attributes for barline                                     * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.barline">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.barline">
    <xs:attribute name="tstamp"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.barline">
    <xs:attribute name="complete">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="c"/>
          <xs:enumeration value="i"/>
          <xs:enumeration value="o"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="control" type="data.BOOLEAN"/>
    <xs:attribute name="measref" type="xs:IDREF"/>
    <xs:attribute name="rend" type="data.BARRENDITION"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.barline">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="barplace" type="data.BARPLACE"/>
    <xs:attribute name="taktplace" type="data.STAFFLOC"/>
    <xs:attribute name="width" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for clef                                        * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.clef">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.clef">
    <xs:attribute name="line" use="required" type="data.CLEFLINE"/>
    <xs:attribute name="octave.default" type="data.OCTAVE"/>
    <xs:attribute name="shape" use="required" type="data.CLEFSHAPE"/>
    <xs:attribute name="trans" type="data.CLEFTRAN"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.clef">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for custos                                      * -->
  <!-- doc: Analytical domain attributes: -->
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The pname and oct attributes identify
    the location where the custos appears.  This is usually, but not always,
    the same as the target pitch.  The target pitch may be referenced using
    the target attribute.
  -->
  <xs:attributeGroup name="att.log.custos">
    <xs:attribute name="oct" use="required" type="data.OCTAVE"/>
    <xs:attribute name="pname" use="required" type="data.PITCHNAME"/>
    <xs:attribute name="source" type="xs:IDREF"/>
    <xs:attribute name="target" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The rend attribute indicates whether
    hash marks should be rendered between systems. See Read, p. 436, ex.
    26-3.
  -->
  <xs:attributeGroup name="att.vis.custos">
    <xs:attributeGroup ref="att.color"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for dot                                         * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.dot">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.dot">
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="aug"/>
          <xs:enumeration value="div"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="loc" type="data.STAFFLOC"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.dot">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for ending                                      * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.ending">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for grpsym                                      * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.grpsym">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The staves attribute must be used when
    multiple grpsym elements are present. The label.* attributes should be
    used instead of n.
  -->
  <xs:attributeGroup name="att.log.grpsym">
    <xs:attribute name="barthru" type="data.BOOLEAN"/>
    <xs:attribute name="label.abbr"/>
    <xs:attribute name="label.full"/>
    <xs:attribute name="start" use="required"/>
    <xs:attribute name="end" use="required"/>
    <xs:attribute name="symbol" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="brace"/>
          <xs:enumeration value="bracket"/>
          <xs:enumeration value="line"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.grpsym">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for interruped neume                            * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.ineume">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.ineume">
    <xs:attribute name="form" type="data.INEUMEFORM"/>
    <xs:attribute name="name" type="data.INEUMENAME"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.ineume">
    <xs:attributeGroup ref="att.color"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for layer                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.layer">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.layer">
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for layerdef                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.layerdef">
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="midi.channel" type="data.MIDICHANNEL"/>
    <xs:attribute name="midi.duty" type="data.PERCENT"/>
    <xs:attribute name="midi.instr" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.instrname"/>
    <xs:attribute name="midi.port" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.track" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The n attribute is provided for explicit
    layer numbering.
  -->
  <xs:attributeGroup name="att.log.layerdef.base">
    <xs:attribute name="beam.group"/>
    <xs:attribute name="beam.rests" type="data.BOOLEAN"/>
    <xs:attribute name="dur.default" type="data.DURATIONS"/>
    <xs:attribute name="octave.default" type="data.OCTAVE"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.layerdef">
    <xs:attributeGroup ref="att.log.layerdef.base"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.layerdef.base">
    <xs:attribute name="beam.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="acc"/>
          <xs:enumeration value="rit"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="beam.slope" type="data.NUMBER"/>
    <xs:attribute name="slur.rend" type="data.CURVERENDITION"/>
    <xs:attribute name="text.fam" type="data.FONTFAMILY"/>
    <xs:attribute name="text.name" type="data.FONTNAME"/>
    <xs:attribute name="text.size" type="data.NUMBER"/>
    <xs:attribute name="text.style" type="data.FONTSTYLE"/>
    <xs:attribute name="text.weight" type="data.FONTWEIGHT"/>
    <xs:attribute name="tie.rend" type="data.CURVERENDITION"/>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.vis.layerdef">
    <xs:attributeGroup ref="att.vis.layerdef.base"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for ligature                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.ligature">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.ligature">
    <xs:attribute name="form" type="data.LIGATUREFORM"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for mensur                                      * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.mensur">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.mensur">
    <xs:attribute name="modusmaior">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="modusminor">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="prolatio">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="tempus">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.mensur">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="dot" type="data.BOOLEAN"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="horizontal"/>
          <xs:enumeration value="vertical"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="loc" type="data.STAFFLOC"/>
    <xs:attribute name="orient">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="reversed"/>
          <xs:enumeration value="90CW"/>
          <xs:enumeration value="90CCW"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="sign" type="data.MENSURATIONSIGN"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="slash" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for midi                                        * -->
  <!--
    doc: The corresp attribute may point to logical events, i.e., notes,
    rests, etc., to which the MIDI data is analogous. 
  -->
  <xs:attributeGroup name="att.anl.midi">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The midi element may provide values for
    layer and staff attributes for a group of MIDI events. 
  -->
  <xs:attributeGroup name="att.log.midi">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="staff" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for proport                                     * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.proport">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.proport">
    <xs:attribute name="num" use="required" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" use="required" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for part                                        * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.part">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The n attribute allows explicit
    numbering of parts.
  -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for parts                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.parts">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for rdg                                         * -->
  <!--
    doc: Analytical domain attributes: The priority attribute is available
    so that variant readings may be assigned an order, e.g., for selection
    and/or rendering purposes, other than the encoded order. The resp
    attribute identifies the editor responsible for asserting this reading
    in the source.
  -->
  <xs:attributeGroup name="att.anl.rdg">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The expan attribute contains a list of
    ids of child section, ending or app elements. This 'expansion list'
    indicates how the section should be expanded into its 'through-composed'
    form.
  -->
  <xs:attributeGroup name="att.log.rdg">
    <xs:attribute name="expan" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for sb                                          * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.sb">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Adding the following attributes:
                        leftmar             %data.NUMBER;         #IMPLIED
                        rightmar            %data.NUMBER;         #IMPLIED
                        spacing.staff       %data.NUMBER;         #IMPLIED
    to a.log.sb would make it possible to record layout changes without
    requiring them to be at section boundaries.
  -->
  <xs:attributeGroup name="att.log.sb">
    <xs:attribute name="source" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The rend attribute indicates whether
    hash marks should be rendered between systems. See Read, p. 436, ex.
    26-3.
  -->
  <xs:attributeGroup name="att.vis.sb">
    <xs:attribute name="rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="hash"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for score                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.score">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for scoredef                                    * -->
  <!--
    doc: Analytical domain attributes: Since the score element carries
    analytical attributes for the score, it is unlikely a.anl.scoredef will
    ever be used.
  -->
  <!--
    doc: Gestural domain attributes: 
    Definitions and suggested default values:
    grace              do grace notes get time from the current (acc) or
                       previous (unacc) main note? 'acc'
    midi.channel       '1'
    midi.div           MIDI pulses per quarter note '96'
    midi.duty          specifies the 'on' part of the duty cycle as a
                       percentage. '80'
    midi.instr         General MIDI instrument number '1'
    midi.instrname     General MIDI instrument name 'Acoustic Piano'
    midi.port          MIDI port number '1'
    midi.tempo         quarter notes per minute '120'
    midi.track         MIDI track number '1'
    tempo              beats per minute '120'
    tune.pname         name of tuning reference pitch 'a'
    tune.Hz            frequency of tuning reference pitch '440'
    tune.temper        temperament 'equal'
  -->
  <xs:attributeGroup name="att.ges.scoredef">
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="midi.channel" type="data.MIDICHANNEL"/>
    <xs:attribute name="midi.div" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="midi.duty" type="data.PERCENT"/>
    <xs:attribute name="midi.instr" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.instrname"/>
    <xs:attribute name="midi.port" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.tempo" type="data.MIDITEMPO"/>
    <xs:attribute name="midi.track" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tempo" type="data.TEMPOVALUE"/>
    <xs:attribute name="tune.pname" type="data.PITCHNAME"/>
    <xs:attribute name="tune.Hz" type="data.NUMBER"/>
    <xs:attribute name="tune.temper" type="data.TEMPERAMENT"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes:
    beam.group         an example of how beaming (including secondary
                       beams) is to be done, e.g. (4.,4.,4.) indicates one
                       outer beam per measure with secondary beams broken
                       at each dotted quarter duration, no default
    beam.rests         should beams include rests shorter than a quarter
                       duration?, 'no'
    clef.line          position of the clef, '2'
    clef.shape         clef, 'G'
    clef.trans         octave shift indicated by the clef, '0'
    dur.default        default duration, '4'
    key.accid          tonic accidental, i.e., 's' or 'f', no default
    key.mode           mode, 'major'
    key.pname          tonic pitchname, no default
    key.sig            effective key signature, no default
    key.sig.mixed      key signature contains both sharps and flats, no
                       default
    meter.count        number of beats per measure, top number of the meter
                       sig, no default
    meter.sym          display a symbol, e.g. C, instead of numbers, like
                       4/4, no default
    meter.unit         beat unit, bottom number of the meter sig, no default
    octave.default     default octave when octave isn't specified on the
                       first note of the measure, '4'
    trans.diat         amount of diatonic pitch shift, e.g. C to C# = 0, C
                       to Db = 1, '0'
    trans.semi         amount of pitch shift in semitones, e.g. C to C# =
                       1, C to Db = 1, '0'. (Transposition requires both
                       trans.diat and trans.semi.)
  -->
  <xs:attributeGroup name="att.log.scoredef.mensural">
    <xs:attribute name="mensur" type="data.MENSURATIONSIGN"/>
    <xs:attribute name="mensur.dot" type="data.BOOLEAN"/>
    <xs:attribute name="mensur.slash" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="modusmaior">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="modusminor">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="prolatio">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="proport.num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="proport.numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tempus">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.scoredef.base">
    <xs:attribute name="beam.group"/>
    <xs:attribute name="beam.rests" type="data.BOOLEAN"/>
    <xs:attribute name="clef.line" type="data.CLEFLINE"/>
    <xs:attribute name="clef.shape" type="data.CLEFSHAPE"/>
    <xs:attribute name="clef.trans" type="data.CLEFTRAN"/>
    <xs:attribute name="dur.default" type="data.DURATIONS"/>
    <xs:attribute name="key.accid" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="key.mode" type="data.MODE"/>
    <xs:attribute name="key.pname" type="data.PITCHNAME"/>
    <xs:attribute name="key.sig" type="data.KEYSIGNATURE"/>
    <xs:attribute name="key.sig.mixed"/>
    <xs:attribute name="meter.count" type="data.NUMBER"/>
    <xs:attribute name="meter.sym" type="data.METERSIGN"/>
    <xs:attribute name="meter.unit" type="data.NUMBER"/>
    <xs:attribute name="octave.default" type="data.OCTAVE"/>
    <xs:attribute name="trans.diat" type="data.NUMBER"/>
    <xs:attribute name="trans.semi" type="data.NUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.scoredef">
    <xs:attributeGroup ref="att.log.scoredef.base"/>
    <xs:attributeGroup ref="att.log.scoredef.mensural"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: 
    Definitions and suggested software default values:
    mnum.visible       are measure numbers visible?, 'no'
    bar.place          placement of barlines, 'norm'
    beam.rend          encodes whether a beam is feathered and in which
                       direction, 'norm'
    beam.slope         default beam slope, Mup uses '1.0, 25.0'
    clef.color         hexadecimal RGB/name color value
    clef.visible       are clefs visible?, 'yes'
    dynam.dist         how far from staff to render dynamic marks, '2'
    ending.rend        where to draw ending marks, 'top'
    grid.show          display chord grids?, 'no'
    harm.dist          how far from staff to render harmony, '2'
    key.sig.show       display key signature?, 'yes'
    key.sig.showchange display cautionary key signature change?, 'yes'
    lyric.align        alignment of lyrics beneath notes, Mup uses '0.25'
    lyric.fam          font family for lyrics, 'times'
    lyric.name         font name for lyrics, 'rom'
    lyric.size         point size of lyrics, '12'
    meter.rend         display meter normally (3/4), with symbol as denom,
                       or invis, 'norm'
    meter.sig.showchange display cautionary meter signature change?, 'yes'
    ontheline          governs display of notes on a 1-line staff, 'yes'
    optimize           display only those staves with notes?, 'no'
    ** page.* attributes apply to the entire score/part
    page.height        height of page, '11'
    page.width         width of page, '8.5'
    page.units         real-world measurement (inches, centimeters,
                       millimeters), 'in'
    page.topmar        top page margin, '1'
    page.botmar        bottom page margin, '1'
    page.leftmar       left page margin, '.5'
    page.rightmar      right page margin, '.5'
    page.panels        number of logical pages to place on physical page, '1'
    page.scale         scale printed output by the specified percentage, '100'
    pedal.rend         are piano pedal marks drawn as lines or as terms
                       (e.g. 'Ped.' & '*'), 'term'
    reh.enclose        default look of rehearsal letters/numbers, 'box'
    slur.rend          default look of slurs, 'medium'
    spacing.packexp    note spacing relative to its time value, '0.8'
    spacing.packfact   note spacing of output, '1'
    spacing.staff      minimum amount of space between staves in the same
                       system, '2'
    spacing.system     minimum and maximum amount of space between systems,
                       '12, 20'
    system.leftmar     left system margin relative to page.leftmar, '0'
    system.rightmar    right system margin relative to page.rightmar, '0'
    system.topmar      distance from page's top edge to the first system,
                       used for first page only
    text.dist          how far from staff to render text, '2'
    text.fam           font family for text, 'times'
    text.nam           font name for text, 'rom'
    text.size          point size of text, '12'
    tie.rend           default look of ties, 'medium'
  -->
  <xs:attributeGroup name="att.vis.scoredef.mensural">
    <xs:attribute name="mensur.form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="horizontal"/>
          <xs:enumeration value="vertical"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mensur.loc" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="mensur.orient">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="reversed"/>
          <xs:enumeration value="90CW"/>
          <xs:enumeration value="90CCW"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mensur.size" type="data.SIZE"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.vis.scoredef.base">
    <xs:attribute name="bar.place" type="data.BARPLACE"/>
    <xs:attribute name="beam.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="acc"/>
          <xs:enumeration value="rit"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="beam.slope" type="data.NUMBER"/>
    <xs:attribute name="clef.color" type="data.COLOR"/>
    <xs:attribute name="clef.visible" type="data.BOOLEAN"/>
    <xs:attribute name="dynam.dist" type="data.NUMBER"/>
    <xs:attribute name="ending.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="barred"/>
          <xs:enumeration value="grouped"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="grid.show" type="data.BOOLEAN"/>
    <xs:attribute name="harm.dist" type="data.NUMBER"/>
    <xs:attribute name="key.sig.show" type="data.BOOLEAN"/>
    <xs:attribute name="key.sig.showchange" type="data.BOOLEAN"/>
    <xs:attribute name="lyric.align" type="data.NUMBER"/>
    <xs:attribute name="lyric.fam" type="data.FONTFAMILY"/>
    <xs:attribute name="lyric.name" type="data.FONTNAME"/>
    <xs:attribute name="lyric.size" type="data.NUMBER"/>
    <xs:attribute name="lyric.style" type="data.FONTSTYLE"/>
    <xs:attribute name="lyric.weight" type="data.FONTWEIGHT"/>
    <xs:attribute name="meter.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="denomsym"/>
          <xs:enumeration value="norm"/>
          <xs:enumeration value="invis"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="meter.sig.showchange" type="data.BOOLEAN"/>
    <xs:attribute name="mnum.visible" type="data.BOOLEAN"/>
    <xs:attribute name="multi.number" type="data.BOOLEAN"/>
    <xs:attribute name="music.name" type="data.MUSICFONT"/>
    <xs:attribute name="music.size" type="data.NUMBER"/>
    <xs:attribute name="ontheline" type="data.BOOLEAN"/>
    <xs:attribute name="optimize" type="data.BOOLEAN"/>
    <xs:attribute name="page.height" type="data.NUMBER"/>
    <xs:attribute name="page.width" type="data.NUMBER"/>
    <xs:attribute name="page.units" type="data.PGUNITS"/>
    <xs:attribute name="page.topmar" type="data.NUMBER"/>
    <xs:attribute name="page.botmar" type="data.NUMBER"/>
    <xs:attribute name="page.leftmar" type="data.NUMBER"/>
    <xs:attribute name="page.rightmar" type="data.NUMBER"/>
    <xs:attribute name="page.panels">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="1"/>
          <xs:enumeration value="2"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="page.scale" type="data.PGSCALE"/>
    <xs:attribute name="pedal.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="line"/>
          <xs:enumeration value="term"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="reh.enclose">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="box"/>
          <xs:enumeration value="circle"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="slur.rend" type="data.CURVERENDITION"/>
    <xs:attribute name="spacing.packexp" type="data.NUMBER"/>
    <xs:attribute name="spacing.packfact" type="data.NUMBER"/>
    <xs:attribute name="spacing.staff" type="data.NUMBER"/>
    <xs:attribute name="spacing.system"/>
    <xs:attribute name="system.leftmar" type="data.NUMBER"/>
    <xs:attribute name="system.rightmar" type="data.NUMBER"/>
    <xs:attribute name="system.topmar" type="data.NUMBER"/>
    <xs:attribute name="text.dist" type="data.NUMBER"/>
    <xs:attribute name="text.fam" type="data.FONTFAMILY"/>
    <xs:attribute name="text.name" type="data.FONTNAME"/>
    <xs:attribute name="text.size" type="data.NUMBER"/>
    <xs:attribute name="text.style" type="data.FONTSTYLE"/>
    <xs:attribute name="text.weight" type="data.FONTWEIGHT"/>
    <xs:attribute name="tie.rend" type="data.CURVERENDITION"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.vis.scoredef">
    <xs:attributeGroup ref="att.vis.scoredef.base"/>
    <xs:attributeGroup ref="att.vis.scoredef.mensural"/>
  </xs:attributeGroup>
  <!--
    doc: Score-level encoding strategies for:
    a) alternating meter sig, e.g. 2/4 3/4 in alternating measures (Read,
       p. 164-165) and combined meters (Read, p.166-168): explicitly
       encode meters, make them invisible, display both meter sigs at the
       start of the section
    b) compound meter sig, e.g. 2+3+2/4 (Read, p. 168-170): set
       meter.count=2+3+2
    c) polymeters, e.g. different simultaneous meters (Read, p. 170-173):
       1. where barlines coincide, use beaming to elucidate the polymeter
       2. where barlines sometimes coincide, break into measures
       according to a common unit of time, draw barlines where visually
       required
       3. where barlines never coincide, encode as parts only
    d) mixed meter sig, e.g. 2/4 + 3/16 in the same measure (Read, p.
       173-174): encode in common time base, e.g. 11/16, make meter
       invisible, display both meter sigs at the start of the measure
    e) fractional meter sig, e.g. 3.5/4 (Read, p. 175-177):
       set meter.count=3.5
       The beat count may be displayed as a fraction or as its decimal
       equivalent.
  -->
  <!-- ************************************************************** -->
  <!-- * Attributes for section                                     * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.section">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain attributes: The expan attribute contains a list of
    ids of child section, ending or app elements. This 'expansion list'
    indicates how the section should be expanded into its 'through-composed'
    form. See Read, p. 226 (ex. 12-10), 228-229 (ex. 12-16).
  -->
  <xs:attributeGroup name="att.ges.section">
    <xs:attribute name="expan" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for staff                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.staff">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.staff">
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for staffdef                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <!--
    doc: Gestural domain attributes: Adding tune.pname, tune.Hz, and
    tune.temper attributes here would allow each staff to establish its own
    tuning standard.
  -->
  <xs:attributeGroup name="att.ges.staffdef.tablature">
    <xs:attribute name="tab.strings"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.ges.staffdef.base">
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="midi.channel" type="data.MIDICHANNEL"/>
    <xs:attribute name="midi.div" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="midi.duty" type="data.PERCENT"/>
    <xs:attribute name="midi.instr" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.instrname"/>
    <xs:attribute name="midi.port" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.track" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.ges.staffdef">
    <xs:attributeGroup ref="att.ges.staffdef.base"/>
    <xs:attributeGroup ref="att.ges.staffdef.tablature"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The n attribute is provided for explicit
    staff numbering.
  -->
  <xs:attributeGroup name="att.log.staffdef.mensural">
    <xs:attribute name="mensur.sign" type="data.MENSURATIONSIGN"/>
    <xs:attribute name="mensur.dot" type="data.BOOLEAN"/>
    <xs:attribute name="mensur.slash" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="modusmaior">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="modusminor">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="prolatio">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="proport.num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="proport.numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tempus">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.staffdef.base">
    <xs:attribute name="beam.group"/>
    <xs:attribute name="beam.rests" type="data.BOOLEAN"/>
    <xs:attribute name="clef.line" type="data.CLEFLINE"/>
    <xs:attribute name="clef.shape" type="data.CLEFSHAPE"/>
    <xs:attribute name="clef.trans" type="data.CLEFTRAN"/>
    <xs:attribute name="dur.default" type="data.DURATIONS"/>
    <xs:attribute name="key.accid" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="key.mode" type="data.MODE"/>
    <xs:attribute name="key.pname" type="data.PITCHNAME"/>
    <xs:attribute name="key.sig" type="data.KEYSIGNATURE"/>
    <xs:attribute name="key.sig.mixed"/>
    <xs:attribute name="meter.count" type="data.NUMBER"/>
    <xs:attribute name="meter.sym" type="data.METERSIGN"/>
    <xs:attribute name="meter.unit" type="data.NUMBER"/>
    <xs:attribute name="octave.default" type="data.OCTAVE"/>
    <xs:attribute name="trans.diat" type="data.NUMBER"/>
    <xs:attribute name="trans.semi" type="data.NUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.staffdef">
    <xs:attributeGroup ref="att.log.staffdef.base"/>
    <xs:attributeGroup ref="att.log.staffdef.mensural"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: It is a semantic error if the clef.shape,
    clef.line, key.sig, meter.count, and meter.unit attributes are not
    supplied or are not available from a scoredef ancestor. The layerscheme
    attribute indicates the number of layers and the stem direction. The
    lines attribute indicates the number of stafflines. The lines.color
    attribute is structured; that is, it should have the same number of
    space-separated RGB values as indicated by the lines attribute. A line
    can be made invisible by assigning it the same RGB value as the
    background, usually white. The tab.strings attribute lists a written
    pitch and octave for each open string, e.g. "e3 a3 d4 g4 b4 e5" for
    standard guitar tuning. It should contain the number of tokens indicated
    by the lines attribute. Chromatic alteration may be indicated with '-'
    (flat) and '#' (sharp).  Double sharps and flats are not permitted.  The
    spacing attribute should be used to record the absolute distance (as
    opposed to the relative distances recorded in scoredef elements) between
    this staff and the preceding one in the same system.  This value is
    meaningless for the first staff in a system since the spacing.system
    attribute indicates the spacing between systems.
  -->
  <xs:attributeGroup name="att.vis.staffdef.mensural">
    <xs:attribute name="mensur.form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="horizontal"/>
          <xs:enumeration value="vertical"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mensur.loc" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="mensur.orient">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="reversed"/>
          <xs:enumeration value="90CW"/>
          <xs:enumeration value="90CCW"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mensur.size" type="data.SIZE"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.vis.staffdef.base">
    <xs:attribute name="beam.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="acc"/>
          <xs:enumeration value="rit"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="beam.slope" type="data.NUMBER"/>
    <xs:attribute name="clef.color" type="data.COLOR"/>
    <xs:attribute name="clef.visible" type="data.BOOLEAN"/>
    <xs:attribute name="dynam.dist" type="data.NUMBER"/>
    <xs:attribute name="grid.show" type="data.BOOLEAN"/>
    <xs:attribute name="harm.dist" type="data.NUMBER"/>
    <xs:attribute name="key.sig.show" type="data.BOOLEAN"/>
    <xs:attribute name="key.sig.showchange" type="data.BOOLEAN"/>
    <xs:attribute name="label.full"/>
    <xs:attribute name="label.abbr"/>
    <xs:attribute name="layerscheme" type="data.LAYERSCHEME"/>
    <xs:attribute name="lines" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="lines.color" type="xs:NMTOKENS"/>
    <xs:attribute name="lines.visible" type="data.BOOLEAN"/>
    <xs:attribute name="lyric.align" type="data.NUMBER"/>
    <xs:attribute name="lyric.fam" type="data.FONTFAMILY"/>
    <xs:attribute name="lyric.name" type="data.FONTNAME"/>
    <xs:attribute name="lyric.size" type="data.NUMBER"/>
    <xs:attribute name="lyric.style" type="data.FONTSTYLE"/>
    <xs:attribute name="lyric.weight" type="data.FONTWEIGHT"/>
    <xs:attribute name="meter.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="denomsym"/>
          <xs:enumeration value="norm"/>
          <xs:enumeration value="invis"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="meter.sig.showchange" type="data.BOOLEAN"/>
    <xs:attribute name="multi.number" type="data.BOOLEAN"/>
    <xs:attribute name="ontheline" type="data.BOOLEAN"/>
    <xs:attribute name="pedal.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="line"/>
          <xs:enumeration value="term"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="reh.enclose">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="box"/>
          <xs:enumeration value="circle"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="scale" type="data.NUMBER"/>
    <xs:attribute name="slur.rend" type="data.CURVERENDITION"/>
    <xs:attribute name="spacing" type="data.NUMBER"/>
    <xs:attribute name="text.dist" type="data.NUMBER"/>
    <xs:attribute name="text.fam" type="data.FONTFAMILY"/>
    <xs:attribute name="text.name" type="data.FONTNAME"/>
    <xs:attribute name="text.size" type="data.NUMBER"/>
    <xs:attribute name="text.style" type="data.FONTSTYLE"/>
    <xs:attribute name="text.weight" type="data.FONTWEIGHT"/>
    <xs:attribute name="tie.rend" type="data.CURVERENDITION"/>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.vis.staffdef">
    <xs:attributeGroup ref="att.vis.staffdef.base"/>
    <xs:attributeGroup ref="att.vis.staffdef.mensural"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for staffgrp                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.staffgrp">
    <xs:attribute name="midi.div" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <!--
    doc: Visual domain attributes: barthru indicates whether barlines go
    across the space between staves (yes) or are only drawn across the
    stafflines of each staff (no), label.full is used on the first page
    while label.abbr is used thereafter, symbol indicates the left-hand
    connecting symbol for the group, and the visible attribute indicates
    whether this group is to be printed. The brace and bracket attributes
    may be used (instead of additional staffgrp sub-elements) to indicate
    sub-groupings of staves.
  -->
  <xs:attributeGroup name="att.vis.staffgrp">
    <xs:attribute name="barthru" type="data.BOOLEAN"/>
    <xs:attribute name="brace"/>
    <xs:attribute name="bracket"/>
    <xs:attribute name="label.abbr"/>
    <xs:attribute name="label.full"/>
    <xs:attribute name="symbol">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="brace"/>
          <xs:enumeration value="bracket"/>
          <xs:enumeration value="line"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for uneume                                      * -->
  <!--
    doc: Analytical domain attributes:
    accid.cautionary cautionary accidental
    accid.editorial  editorial accidental or musica ficta
    hfunc            harmonic function, e.g. root, 3rd, 5th
    inth             harmonic interval from pitch in same chord
    intm             melodic interval from previous pitch
    mfunc            melodic function, e.g. appogg., N.T.
    pclass           pitch class 
    psolfa           solfa, e.g. do, re, mi, etc.
  -->
  <xs:attributeGroup name="att.anl.uneume">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="accid.cautionary" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="accid.editorial" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="hfunc"/>
    <xs:attribute name="inth"/>
    <xs:attribute name="intm"/>
    <xs:attribute name="mfunc"/>
    <xs:attribute name="pclass" type="data.PITCHCLASS"/>
    <xs:attribute name="psolfa"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain (performance) attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.uneume">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="form" type="data.UNEUMEFORM"/>
    <xs:attribute name="name" type="data.UNEUMENAME"/>
    <xs:attribute name="syl"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.uneume">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="headshape" type="data.HEADSHAPE"/>
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- ************************************************************** -->
  <!--
    * For the measure tagset, declare attributes in each musical domain,
    e.g. analytical, gestural, and visual, in separate parameter entities.
    This documents which domain an attribute operates in and makes it
    easier to modify the attributes in a given domain independently of the
    others. Declaring these here rather than in the individual tagsets
    makes them available in any element models declared in the
    meiModifications.dtd file.                                        *
  -->
  <!-- ************************************************************** -->
  <!-- ************************************************************** -->
  <!-- * Attributes for accid                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.accid">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: %ACCIDENTAL.EXPLICIT is the super-set.
    The value attribute should really be restricted to the subset given by
    the form attribute.
  -->
  <xs:attributeGroup name="att.log.accid">
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="implicit"/>
          <xs:enumeration value="explicit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="func">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="caution"/>
          <xs:enumeration value="edit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="value" use="required" type="data.ACCIDENTAL.EXPLICIT"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.accid">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="enclose" type="data.ENCLOSURE"/>
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="place">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="above"/>
          <xs:enumeration value="below"/>
          <xs:enumeration value="staff"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="vo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for annot                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.annot">
    <xs:attribute name="dur.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
     doc: Logical domain attributes: % att.controlevent is expanded here in
    order to allow staff to be IMPLIED. Values for the type attribute can be
    taken from any convenient typology of annotation suitable to the work in
    hand; e.g. annotation, gloss, citation, digression, preliminary, temporary,
    etc. The tstamp attribute encodes the onset time of a musical feature in
    terms of musical time, i.e., beats.  The tstamp.ges attribute may be used
    to record the onset time in pulses per quarter note (ppq, MusicXML
    divisions, or MIDI clicks) since the start of the measure, while the
    tstamp.real attribute records the onset time as a real-time offset, i.e.,
    HH:MM:SS.ss, since the beginning of the file.
  -->
  <xs:attributeGroup name="att.log.annot">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="next" type="xs:IDREFS"/>
    <xs:attribute name="prev" type="xs:IDREFS"/>
    <xs:attribute name="staff" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="tstamp" type="data.BEAT"/>
    <xs:attribute name="tstamp.ges" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="tstamp.real" type="data.ISOTIME"/>
    <xs:attributeGroup ref="att.startendid"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for arpeg                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.arpeg">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: dir=nonarp indicates a non-arpeggiated
    chord. Arpeggiation across multiple staves requires 2 values in staff
    attribute; if there's more than 1 layer in either staff, 2 values are
    required in the layer attribute.
  -->
  <xs:attributeGroup name="att.log.arpeg">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attribute name="dir">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="up"/>
          <xs:enumeration value="down"/>
          <xs:enumeration value="nonarp"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.arpeg">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="arrow" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for artic                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.artic">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.artic">
    <xs:attribute name="value" use="required" type="data.ARTICULATION"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.artic">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="enclose" type="data.ENCLOSURE"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for beam                                        * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.beam">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.beam">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="with" type="data.PLACE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: Secondary beams may be broken explicitly
    using the breaksec attribute. Its value should contain a space-separated
    list of rhythmic durations that form a single beat. For example,'8 8'
    indicates a division of the beam into 2 8th-note groups.
  -->
  <xs:attributeGroup name="att.vis.beam">
    <xs:attribute name="breaksec" type="xs:NMTOKENS"/>
    <xs:attribute name="rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="acc"/>
          <xs:enumeration value="rit"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="slope" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for beamspan                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.beamspan">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.beamspan">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="with" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.beamspan">
    <xs:attribute name="breaksec"/>
    <xs:attribute name="rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="acc"/>
          <xs:enumeration value="rit"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="slope" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for beatrpt                                     * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.beatrpt">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.beatrpt">
    <xs:attributeGroup ref="att.event"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The expand attribute indicates whether to
    render the source measures or the usual repeated beat symbol. The rend
    attribute indicates the number of slashes required to render the
    appropriate beat repeat symbol when the beat is divided into even notes
    - 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the beat is
    comprised of mixed duration values, the symbol is always rendered as 2
    slashes and 2 dots. See Read, pg. 223-224.
  -->
  <xs:attributeGroup name="att.vis.beatrpt">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="expand" type="data.BOOLEAN"/>
    <xs:attribute name="rend" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="4"/>
          <xs:enumeration value="8"/>
          <xs:enumeration value="16"/>
          <xs:enumeration value="32"/>
          <xs:enumeration value="64"/>
          <xs:enumeration value="128"/>
          <xs:enumeration value="mixed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for bend                                        * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.bend">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.bend">
    <xs:attribute name="amount">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value=".25"/>
          <xs:enumeration value=".5"/>
          <xs:enumeration value=".75"/>
          <xs:enumeration value="1"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.bend">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The bulge or, alternatively, the bezier
    attribute, describes the shape of the bend.  The bulge attribute
    describes the curve as a set of distance values above or below an
    imaginary line connecting the endpoints of the curve while the bezier
    attribute records the placement of Bezier control points as a series
    of space-separated xy coordinates, eg. 19 45 -32 118.  If the bulge or
    bezier attributes are present, the bend should be rendered as a curve.
    Otherwise, it should be rendered as a line. The bulge attribute must
    contain one or more values of type %NUMBER. The rend attribute records
    the typographical style of the curve or line while the ho and vo
    attributes describe the visual offset of the entire rendered bend. The
    endho, endvo and startho, startvo attribute pairs may be used to
    encode start and end points relative to their programmatic placement.
    For exact placement of the endpoints of the bend use the xy coordinate
    pairs.
  -->
  <xs:attributeGroup name="att.vis.bend">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="bezier" type="xs:NMTOKENS"/>
    <xs:attribute name="bulge" type="xs:NMTOKENS"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="rend" type="data.CURVERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for breath                                      * -->
  <xs:attributeGroup name="att.anl.breath">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: Currently, the dur attribute encodes
    the logical and visual durations of the directive. If cases arise where
    the logical and visual durations differ, it may be necessary to add a
    dur.vis attribute. Please note that the dur attribute is not a true
    duration, but rather a time stamp for the end point of the directive.
  -->
  <xs:attributeGroup name="att.log.breath">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.breath">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for btrem                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.btrem">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The num attribute should be explicitly
    set for measured tremolandi. The stem modifier (slash or z) must also be
    explicity set on the child note or chord element for a complete visual
    representation.
  -->
  <xs:attributeGroup name="att.log.btrem">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="meas"/>
          <xs:enumeration value="unmeas"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.btrem">
    <xs:attribute name="num.place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for chord                                       * -->
  <!--
    doc: Analytical domain attributes: hfunc = harmonic function,
    mfunc = melodic function.
  -->
  <xs:attributeGroup name="att.anl.chord">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="hfunc"/>
    <xs:attribute name="mfunc"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain (performance) attributes: The artic.ges and
    dur.ges attributes record the articulation and duration information
    when the performed values differ from the written values. The dur.ges
    attribute (performed duration) may be expressed in several forms, such
    as measures[s]+beat[s].beatpart, ppq (MIDI clicks), Humdrum *recip
    values, or MusicXML 'divisions', etc. Because dur.ges isn't limited to
    the standard duration values, a dots.ges attribute is unnecessary.
  -->
  <xs:attributeGroup name="att.ges.chord">
    <xs:attribute name="artic.ges" type="data.ARTICULATIONS"/>
    <xs:attribute name="detune"/>
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="grace.time" type="data.PERCENT"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The artic, dots, and dur attributes
    encode the *written* articulations, augmentation dots, and duration
    values.
  -->
  <xs:attributeGroup name="att.log.chord">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="artic" type="data.ARTICULATIONS"/>
    <xs:attribute name="beam" type="data.BEAMS"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
    <xs:attribute name="lv" type="data.BOOLEAN"/>
    <xs:attribute name="slur" type="data.SLURS"/>
    <xs:attribute name="syl"/>
    <xs:attribute name="tie" type="data.TIE"/>
    <xs:attribute name="tuplet" type="data.TUPLET"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:  The altsym attribute indicates that
    the specified alternative visual symbol is to be displayed. The
    headshape attribute may be used to indicate a cluster notehead should
    be displayed instead of individual noteheads.  See Read, p. 320-321
    re: tone clusters. Processing of chords and notes will be easier if a
    distinction is made between articulations, which indicate sound
    quality, and text strings, such as numbers for fingering, etc. Only
    articulations should be encoded in the artic attribute; fingerings
    should be encoded using the <dir> element. Articulations may be
    encoded in order from the notehead outward; that is, away from the
    stem. See additional notes at a.vis.note. The slur, slur.dir,
    slur.rend, tie, tie.dir, and tie.rend attributes here are syntactic
    sugar for these attributes on each of the chord's individual notes.
    The values here apply to all the notes in the chord. If some notes are
    slurred or tied while others aren't, then the individual note
    attributes must be used. The coloration attribute should not be
    confused with visual color. Coloration is when a void notehead is
    displayed filled and vice versa. The dot.ho and dot.vo attributes
    record the offset of the dot from its "normal" position while the
    dot.x and dot.y attributes record the precise position of the dot.
    The %att.visualoffset entity is expanded here in order to disallow a
    vertical offset.
  -->
  <xs:attributeGroup name="att.vis.chord">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="beam.with" type="data.PLACE"/>
    <xs:attribute name="coloration">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inverse"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dot.ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.vo" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.x" type="data.NUMBER"/>
    <xs:attribute name="dot.y" type="data.NUMBER"/>
    <xs:attribute name="headshape" type="data.CLUSTER"/>
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="slur.dir" type="data.SLURDIRECTION"/>
    <xs:attribute name="slur.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="stem.dir" type="data.STEMDIRECTION"/>
    <xs:attribute name="stem.len" type="data.NUMBER"/>
    <xs:attribute name="stem.mod" type="data.STEMMODIFIER"/>
    <xs:attribute name="stem.pos" type="data.STEMPOSITION"/>
    <xs:attribute name="stem.with" type="data.PLACE"/>
    <xs:attribute name="stem.x" type="data.NUMBER"/>
    <xs:attribute name="stem.y" type="data.NUMBER"/>
    <xs:attribute name="tie.dir" type="data.TIEDIRECTION"/>
    <xs:attribute name="tie.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="to" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for clefchange                                  * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.clefchange">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.clefchange.base">
    <xs:attribute name="line" type="data.CLEFLINE"/>
    <xs:attribute name="octave.default" type="data.OCTAVE"/>
    <xs:attribute name="shape" type="data.CLEFSHAPE"/>
    <xs:attribute name="trans" type="data.CLEFTRAN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.log.clefchange">
    <xs:attributeGroup ref="att.log.clefchange.base"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.clefchange">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for dir                                         * -->
  <xs:attributeGroup name="att.anl.dir">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.dir">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: Currently, the dur attribute encodes
    the logical and visual durations of the directive. If cases arise where
    the logical and visual durations differ, it may be necessary to add a
    dur.vis attribute. Please note that the dur attribute is not a true
    duration, but rather a time stamp for the end point of the directive.
  -->
  <xs:attributeGroup name="att.log.dir">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.dir">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for dynam                                       * -->
  <xs:attributeGroup name="att.anl.dynam">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.dynam">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="value" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the dynamic symbol or text while the dur.ges
    attribute encodes the performed duration. If logical and visual
    duration differ, it may be necessary to add a dur.vis attribute.
    Please note that the dur attribute is not a true duration, but rather
    a time stamp for the end point of the dynamic indication.
  -->
  <xs:attributeGroup name="att.log.dynam">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.dynam">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for fermata                                     * -->
  <xs:attributeGroup name="att.anl.fermata">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.fermata">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.fermata">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.fermata">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inv"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for ftrem                                       * -->
  <xs:attributeGroup name="att.anl.ftrem">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.ftrem">
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="meas"/>
          <xs:enumeration value="unmeas"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.ftrem">
    <xs:attributeGroup ref="att.event"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The rend attribute indicates the number
    of slashes required - 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4,
    128ths=5.
  -->
  <xs:attributeGroup name="att.vis.ftrem">
    <xs:attribute name="slash" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="1"/>
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
          <xs:enumeration value="4"/>
          <xs:enumeration value="5"/>
          <xs:enumeration value="6"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for gliss                                       * -->
  <xs:attributeGroup name="att.anl.gliss">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.gliss">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The text attribute may be used to record
    any text, such as 'gliss.' that accompanies the glissando mark.
  -->
  <xs:attributeGroup name="att.vis.gliss">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="rend" type="data.LINERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="text"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for hairpin                                     * -->
  <xs:attributeGroup name="att.anl.hairpin">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain attributes: dur.ges represents the performed
    duration.
  -->
  <xs:attributeGroup name="att.ges.hairpin">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the hairpin while the dur.ges attribute, if it
    is available, encodes the performed duration. If logical and visual
    duration differ, it may be necessary to add a dur.vis attribute.
    Please note that the dur attribute is not a true duration, but rather
    a time stamp for the end point of the hairpin.
  -->
  <xs:attributeGroup name="att.log.hairpin">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
    <xs:attribute name="form" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="cres"/>
          <xs:enumeration value="dim"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The startho and startvo attributes record
    the horizontal and vertical offsets of the left end, endho and endvo
    record the horizontal and vertical offsets of the right end, and the
    width attribute records the width of the opening on the open end in
    staff inter-line units. The x1 and y1 attributes give the absolute
    coordinates of the left side of the hairpin while x2 and y2 record the
    coordinates of the right side.
  -->
  <xs:attributeGroup name="att.vis.hairpin">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="place" use="required" type="data.PLACE"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="width" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for halfmrpt                                    * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.halfmrpt">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.halfmrpt">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="dur" type="data.DURATION"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The expand attribute indicates whether or
    not to render the source material. How can it be pointed to?
  -->
  <xs:attributeGroup name="att.vis.halfmrpt">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="expand" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for harm                                        * -->
  <xs:attributeGroup name="att.anl.harm">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.harm">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the harmony while the dur.ges attribute, if it
    is available, encodes the performed duration. If logical and visual
    duration differ, it may be necessary to add a dur.vis attribute.
    Please note that the dur attribute here is not a true duration, but
    rather a time stamp for the end point of the directive.
  -->
  <xs:attributeGroup name="att.log.harm">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="chordref" type="xs:IDREF"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: If the rendgrid attribute is set to 'grid',
    then the chord tablature grid defined in the chordtable should be rendered
    instead of the text contents of the harm element; if rendgrid equals
    'gridname', both the harm element's text and the grid should be
    displayed; otherwise, only the 'name' of the chord, i.e., the text content
    of the harm element, e.g. 'Cmaj' or 'V7/III', should be rendered.
  -->
  <xs:attributeGroup name="att.vis.harm">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="extender" type="data.BOOLEAN"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="rendgrid">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="grid"/>
          <xs:enumeration value="gridname"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for harppedal                                   * -->
  <xs:attributeGroup name="att.anl.harppedal">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.harppedal">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.harppedal">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="c" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="d" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="e" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="f" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="g" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="a" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="b" default="n">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="f"/>
          <xs:enumeration value="n"/>
          <xs:enumeration value="s"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.harppedal">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for lyrics                                      * -->
  <xs:attributeGroup name="att.anl.lyrics">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: %att.controlevent is expanded here in
    order to allow only the staff and layer attributes from this class.
  -->
  <xs:attributeGroup name="att.log.lyrics">
    <xs:attribute name="layer" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="staff" use="required" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.lyrics">
    <xs:attributeGroup ref="att.typography"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for measure                                     * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.measure">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The complete attribute allows the
    encoding of whether a measure matches the prevailing meter: a value of
    'c' indicates a metrically complete measure, 'i' indicates a measure
    with not enough beats, while 'o' is for measures with too many beats.
    The control attribute indicates whether or not the barline is
    "controlling", that is, indicates a point of alignment across all the
    parts. Barlines within a score are always 'controlling'; that is, they
    must 'line up'. Barlines within parts may or may not be 'controlling'.
    The left attribute indicates the function of the left barline. It is
    present here only for facilitation of translation from legacy encodings
    which use it. Usually, it can be safely ignored.  The right attribute,
    on the other hand, indicates the function of the right barline and is
    structurally important.  The n attribute may contain a name/name (label)
    for the measure (Read, p. 445).  Often, this is an integer, but not always.
    For example, some measures, especially incomplete measures or those
    under an ending mark, may have labels that contain an integer plus a
    suffix, such as '12a'.  Measures may even have labels, especially in
    editorial or analytical uses of MEI, that are entirely non-numeric
    strings. Measure numbers may be machine-generated.  However, an explicit
    measure number will restart numbering with the given value.
  -->
  <xs:attributeGroup name="att.log.measure">
    <xs:attribute name="complete">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="c"/>
          <xs:enumeration value="i"/>
          <xs:enumeration value="o"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="control" type="data.BOOLEAN"/>
    <xs:attribute name="left" type="data.BARRENDITION"/>
    <xs:attribute name="measref" type="xs:IDREF"/>
    <xs:attribute name="right" type="data.BARRENDITION"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The taktplace attribute value must be a
    number between 1 and the number of stafflines. For example, a value of
    '5' puts the barline through the top line of a 5-line staff. The width
    attribute records a fixed width for the measure.
  -->
  <xs:attributeGroup name="att.vis.measure">
    <xs:attribute name="barplace" type="data.BARPLACE"/>
    <xs:attribute name="taktplace" type="data.STAFFLOC"/>
    <xs:attribute name="width" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for mordent                                     * -->
  <xs:attributeGroup name="att.anl.mordent">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: In the form attribute, 'norm' signals
    the normal form, that is, the written note, followed by its lower
    neighbor, with a return to the written note, while 'inv' indicates the
    inverted form, that is, the principal note, followed by its upper
    neighbor, with a return to the principal note. When the long attribute
    is set to 'yes', a double or long mordent, consisting of 5 notes, is
    indicated. Traditionally, the 'normal' mordent is written as a short
    wavy line with a vertical line through it and the inverted mordent is
    written without the vertical line. However, the meaning of these signs
    is sometimes reversed. See Read, p. 245-246. Another attribute in the
    visual domain would be necessary in order to be completely explicit
    about which visual symbol is actually to be rendered.
  -->
  <xs:attributeGroup name="att.log.mordent">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="accidupper" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="accidlower" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inv"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="long" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.mordent">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for mrest                                       * -->
  <!--
    doc: Analytical domain attributes: The n attribute is used to
    explicitly encode this measure's position in a string of measures
    containing only mrest elements.
  -->
  <xs:attributeGroup name="att.anl.mrest">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.mrest">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.mrest">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The altsym attribute indicates that the
    specified alternative visual symbol is to be displayed. When set to
    'rest' the cutout attribute indicates that the staff lines are to be
    displayed but not the rest itself. When set to 'staff' even the staff
    lines should not be drawn for this measure. See _56 Songs You Like to
    Sing_, p. 32. The dur.vis attribute should be used to record the
    durational symbol used in the source.
  -->
  <xs:attributeGroup name="att.vis.mrest">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="cutout">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="rest"/>
          <xs:enumeration value="staff"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dur.vis" type="data.DURATION"/>
    <xs:attribute name="size" type="data.SIZE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for mrpt                                        * -->
  <!--
    doc: Analytical domain attributes: The measref attribute is provided to
    explicitly indicate the measure whose contents are to be repeated here.
    The n attribute is used to explicitly encode this measure's position in
    a string of measures containing only mrpt elements.
  -->
  <xs:attributeGroup name="att.anl.mrpt">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="measref" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.mrpt">
    <xs:attributeGroup ref="att.event"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The expand attribute indicates whether or
    not to render the source measure.
  -->
  <xs:attributeGroup name="att.vis.mrpt">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="expand" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for mrpt2                                       * -->
  <!--
    doc: Analytical domain attributes: The measref attribute is provided to
    explicitly indicate the measures whose contents are to be repeated here.
  -->
  <xs:attributeGroup name="att.anl.mrpt2">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="measref" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.mrpt2">
    <xs:attributeGroup ref="att.event"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The expand attribute indicates whether or
    not to render the source measures.
  -->
  <xs:attributeGroup name="att.vis.mrpt2">
    <xs:attributeGroup ref="att.color"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="expand" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for mspace                                      * -->
  <!--
    doc: Analytical domain attributes: The n attribute is used to
    explicitly encode this measure's position in a string of measures
    containing only mrest elements.
  -->
  <xs:attributeGroup name="att.anl.mspace">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.mspace">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.mspace">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The altsym attribute indicates that the
    specified alternative visual symbol is to be displayed. When set to
    'rest' the cutout attribute indicates that the staff lines are to be
    displayed but not the rest itself. When set to 'staff' even the staff
    lines should not be drawn for this measure. See _56 Songs You Like to
    Sing_, p. 32. The dur.vis attribute should be used to record the
    durational symbol used in the source.
  -->
  <xs:attributeGroup name="att.vis.mspace">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="cutout">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="rest"/>
          <xs:enumeration value="staff"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dur.vis" type="data.DURATION"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for multirest                                   * -->
  <xs:attributeGroup name="att.anl.multirest">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.multirest">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The num attribute contains the number of
    measures of rest.
  -->
  <xs:attributeGroup name="att.log.multirest">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="num" use="required" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: When the block attribute is used,
    combinations of the 1, 2, & 4 measure rest forms (Read, p. 104) should
    be rendered instead of the modern form.
  -->
  <xs:attributeGroup name="att.vis.multirest">
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="block" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for multirpt                                    * -->
  <!--
    doc: Analytical domain attributes: The meas attribute is provided to
    explicitly reference the measures where the source content exists.
  -->
  <xs:attributeGroup name="att.anl.multirpt">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes:  The num attribute contains the number of
    measures to be repeated.
  -->
  <xs:attributeGroup name="att.log.multirpt">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="measref" type="xs:IDREFS"/>
    <xs:attribute name="num" use="required" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The expand attribute indicates whether or
    not to render the source measures.
  -->
  <xs:attributeGroup name="att.vis.multirpt">
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="expand" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for nota                                        * -->
  <!--
    doc: Analytical domain attributes:
    accid.cautionary cautionary accidental
    accid.editorial  editorial accidental or musica ficta
    hfunc            harmonic function, e.g. root, 3rd, 5th
    inth             harmonic interval from pitch in same chord
    intm             melodic interval from previous pitch
    mfunc            melodic function, e.g. appogg., N.T.
    pclass           pitch class 
    psolfa           solfa, e.g. do, re, mi, etc.
  -->
  <xs:attributeGroup name="att.anl.nota">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="accid.cautionary" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="accid.editorial" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="hfunc"/>
    <xs:attribute name="inth"/>
    <xs:attribute name="intm"/>
    <xs:attribute name="mfunc"/>
    <xs:attribute name="pclass" type="data.PITCHCLASS"/>
    <xs:attribute name="psolfa"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain (performance) attributes: The artic.ges, dur.ges,
    oct.ges, pname.ges attributes record the articulation, duration,
    octave, and pitch name when the performed value differs from the
    written value. The accid.ges attribute may be used to record the
    implicit accidental, that is, the pitch alteration required by the key
    signature, for use in conversion to sound and for harmonic analysis.
    Therefore, only the flat, double flat, sharp and double sharp values
    are permitted. Unlike dur attributes elsewhere, the dur.ges attribute
    (performed duration) type is CDATA. This allows the expression of
    performance duration in user-defined terms, such as
    measures[s]:beat[s].beatpart, MIDI clicks, Humdrum *recip values, etc.
    Because dur.ges isn't limited to the standard duration values, a
    dots.ges attribute is unnecessary. See Read, p. 238-241, for a
    discussion of grace notes. The pnum attribute holds a pitch-to-number
    mapping, a base-40 or MIDI note number, for example.
  -->
  <xs:attributeGroup name="att.ges.nota.tablature">
    <xs:attribute name="tab.fret" type="data.FRETNUMBER"/>
    <xs:attribute name="tab.string" type="data.STRINGNUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.ges.nota.base">
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="accid.ges" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="artic.ges" type="data.ARTICULATIONS"/>
    <xs:attribute name="detune"/>
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="gliss" type="data.GLISSANDO"/>
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="grace.time" type="data.PERCENT"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
    <xs:attribute name="oct.ges" type="data.OCTAVE"/>
    <xs:attribute name="pname.ges" type="data.PITCHNAME.GES"/>
    <xs:attribute name="pnum" type="data.PITCHNUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.ges.nota">
    <xs:attributeGroup ref="att.ges.nota.base"/>
    <xs:attributeGroup ref="att.ges.nota.tablature"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The pname, accid, oct, dur, dots, and
    artic attributes encode the *written* note name, accidental, octave,
    duration, articulations, augmentation dots, and articulations. The acci
    attribute records the notated accidental for the note, e.g. flat, sharp,
    natural, double flat, double sharp (both forms), natural+flat,
    natural+sharp, and the quarter tone accidentals. The beam attribute
    records the presence of a beam in which this note participates. Software
    may use this attribute or beam elements for rendering. The dots
    attribute records the number of augmentation dots required by a dotted
    duration. The slur, tie, lv (laissez vibrer), and tuplet attributes encode
    the presence of a slur, tie, lv, or tuplet in which this note participates.
    Software may render slur, tie, lv or tuplet indications based on these
    attributes or require separate slur, tie, generic curve, or tuplet elements
    for visual rendition. Tablature information can be recorded in the tab.fret
    and tab.string attributes. fermata = corona in the mensural repertoire.
  -->
  <xs:attributeGroup name="att.log.nota">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="accid" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="corona" type="data.PLACE"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION.MENSURAL"/>
    <xs:attribute name="lig">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="recta"/>
          <xs:enumeration value="obliqua"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="oct" type="data.OCTAVE"/>
    <xs:attribute name="pname" type="data.PITCHNAME"/>
    <xs:attribute name="syl"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:  The distance between the accidental
    and the note it modifies should be recorded in the accid.ho attribute.
    The headshape attribute may be used to override the headshape normally
    used for the given duration. The enclose.accid and enclose.note attributes
    record the symbol to be used around the accidental and the entire note,
    respectively. For an example of cautionary accidentals enclosed in
    parentheses or brackets see Read, p. 131, ex. 9-14. The coloration
    attribute may be used to indicate a reverse coloration, i.e., black
    instead of white or white instead of black. The dot.ho and dot.vo
    attributes record the offset of the dot from its "normal" position while
    the dot.x and dot.y attributes record the precise position of the dot.
    The %att.visualoffset entity is expanded here in order to disallow
    a vertical offset.
  -->
  <xs:attributeGroup name="att.vis.nota">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="accid.ho" type="data.NUMBER"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="beam.with" type="data.PLACE"/>
    <xs:attribute name="coloration">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inverse"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="colored" type="data.BOOLEAN"/>
    <xs:attribute name="dot.ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.vo" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.x" type="data.NUMBER"/>
    <xs:attribute name="dot.y" type="data.NUMBER"/>
    <xs:attribute name="enclose.accid" type="data.ENCLOSURE"/>
    <xs:attribute name="enclose.note" type="data.ENCLOSURE"/>
    <xs:attribute name="headshape" type="data.HEADSHAPE"/>
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="slur.dir" type="data.SLURDIRECTION"/>
    <xs:attribute name="slur.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="stem.dir" type="data.STEMDIRECTION"/>
    <xs:attribute name="stem.len" type="data.NUMBER"/>
    <xs:attribute name="stem.mod" type="data.STEMMODIFIER"/>
    <xs:attribute name="stem.pos" type="data.STEMPOSITION"/>
    <xs:attribute name="stem.with" type="data.PLACE"/>
    <xs:attribute name="stem.x" type="data.NUMBER"/>
    <xs:attribute name="stem.y" type="data.NUMBER"/>
    <xs:attribute name="tie.dir" type="data.TIEDIRECTION"/>
    <xs:attribute name="tie.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="to" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for note                                        * -->
  <!--
    doc: Analytical domain attributes:
    accid.cautionary cautionary accidental
    accid.editorial  editorial accidental or musica ficta
    hfunc            harmonic function, e.g. root, 3rd, 5th
    inth             harmonic interval from pitch in same chord
    intm             melodic interval from previous pitch
    mfunc            melodic function, e.g. appogg., N.T.
    pclass           pitch class 
    psolfa           solfa, e.g. do, re, mi, etc.
  -->
  <xs:attributeGroup name="att.anl.note">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="accid.cautionary" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="accid.editorial" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="hfunc"/>
    <xs:attribute name="inth"/>
    <xs:attribute name="intm"/>
    <xs:attribute name="mfunc"/>
    <xs:attribute name="pclass" type="data.PITCHCLASS"/>
    <xs:attribute name="psolfa"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain (performance) attributes: The artic.ges, dur.ges,
    oct.ges, pname.ges attributes record the articulation, duration,
    octave, and pitch name when the performed value differs from the
    written value. The accid.ges attribute may be used to record the
    implicit accidental, that is, the pitch alteration required by the key
    signature, for use in conversion to sound and for harmonic analysis.
    Therefore, only the flat, double flat, sharp and double sharp values
    are permitted. Unlike dur attributes elsewhere, the dur.ges attribute
    (performed duration) type is CDATA. This allows the expression of
    performance duration in user-defined terms, such as
    measures[s]:beat[s].beatpart, MIDI clicks, Humdrum *recip values, etc.
    Because dur.ges isn't limited to the standard duration values, a
    dots.ges attribute is unnecessary. See Read, p. 238-241, for a
    discussion of grace notes. The pnum attribute holds a pitch-to-number
    mapping, a base-40 or MIDI note number, for example.  Tablature
    information can be recorded in the tab.fret and tab.string attributes.
  -->
  <xs:attributeGroup name="att.ges.note.base">
    <xs:attribute name="accid.ges" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="artic.ges" type="data.ARTICULATIONS"/>
    <xs:attribute name="detune"/>
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="gliss" type="data.GLISSANDO"/>
    <xs:attribute name="grace" type="data.GRACE"/>
    <xs:attribute name="grace.time" type="data.PERCENT"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
    <xs:attribute name="oct.ges" type="data.OCTAVE"/>
    <xs:attribute name="pname.ges" type="data.PITCHNAME.GES"/>
    <xs:attribute name="pnum" type="data.PITCHNUMBER"/>
    <xs:attribute name="tab.fret" type="data.FRETNUMBER"/>
    <xs:attribute name="tab.string" type="data.STRINGNUMBER"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="att.ges.note">
    <xs:attributeGroup ref="att.ges.note.base"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The pname, accid, oct, dur, dots, and
    artic attributes encode the *written* note name, accidental, octave,
    duration, articulations, augmentation dots, and articulations. The acci
    attribute records the notated accidental for the note, e.g. flat, sharp,
    natural, double flat, double sharp (both forms), natural+flat,
    natural+sharp, and the quarter tone accidentals. The beam attribute
    records the presence of a beam in which this note participates. Software
    may use this attribute or beam elements for rendering. The dots
    attribute records the number of augmentation dots required by a dotted
    duration. The slur, tie, lv (laissez vibrer), and tuplet attributes encode
    the presence of a slur, tie, lv, or tuplet in which this note participates.
    Software may render slur, tie, lv or tuplet indications based on these
    attributes or require separate slur, tie, generic curve, or tuplet elements
    for visual rendition.
  -->
  <xs:attributeGroup name="att.log.note">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="accid" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="artic" type="data.ARTICULATIONS"/>
    <xs:attribute name="beam" type="data.BEAMS"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
    <xs:attribute name="lv" type="data.BOOLEAN"/>
    <xs:attribute name="oct" type="data.OCTAVE"/>
    <xs:attribute name="pname" type="data.PITCHNAME"/>
    <xs:attribute name="slur" type="data.SLURS"/>
    <xs:attribute name="syl"/>
    <xs:attribute name="tie" type="data.TIE"/>
    <xs:attribute name="tuplet" type="data.TUPLET"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:  The distance between the accidental
    and the note it modifies should be recorded in the accid.ho attribute.
    The headshape attribute may be used to override the headshape normally
    used for the given duration. The enclose.accid and enclose.note attributes
    record the symbol to be used around the accidental and the entire note,
    respectively. For an example of cautionary accidentals enclosed in
    parentheses or brackets see Read, p. 131, ex. 9-14. The coloration
    attribute may be used to indicate a reverse coloration, i.e., black
    instead of white or white instead of black. The dot.ho and dot.vo
    attributes record the offset of the dot from its "normal" position while
    the dot.x and dot.y attributes record the precise position of the dot.
    The %att.visualoffset entity is expanded here in order to disallow
    a vertical offset.
  -->
  <xs:attributeGroup name="att.vis.note">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="accid.ho" type="data.NUMBER"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="beam.with" type="data.PLACE"/>
    <xs:attribute name="coloration">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inverse"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dot.ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.vo" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.x" type="data.NUMBER"/>
    <xs:attribute name="dot.y" type="data.NUMBER"/>
    <xs:attribute name="enclose.accid" type="data.ENCLOSURE"/>
    <xs:attribute name="enclose.note" type="data.ENCLOSURE"/>
    <xs:attribute name="headshape" type="data.HEADSHAPE"/>
    <xs:attribute name="ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="slur.dir" type="data.SLURDIRECTION"/>
    <xs:attribute name="slur.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="stem.dir" type="data.STEMDIRECTION"/>
    <xs:attribute name="stem.len" type="data.NUMBER"/>
    <xs:attribute name="stem.mod" type="data.STEMMODIFIER"/>
    <xs:attribute name="stem.pos" type="data.STEMPOSITION"/>
    <xs:attribute name="stem.with" type="data.PLACE"/>
    <xs:attribute name="stem.x" type="data.NUMBER"/>
    <xs:attribute name="stem.y" type="data.NUMBER"/>
    <xs:attribute name="tie.dir" type="data.TIEDIRECTION"/>
    <xs:attribute name="tie.rend">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="dotted"/>
          <xs:enumeration value="dashed"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="to" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for octave                                      * -->
  <xs:attributeGroup name="att.anl.octave">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.octave">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the octave displacement while the dur.ges
    attribute, if it is available, encodes the performed duration. If
    logical and visual duration differ, it may be necessary to add a
    dur.vis attribute. Please note that the dur attribute here is
    not a true duration, but rather a time stamp for the end point of the
    octave displacement. The dur attribute is NOT REQUIRED because the
    octave displacement can be visually instantaneous. The place
    attribute indicates direction of displacement and display location and
    therefore is REQUIRED. The dis attribute states the amount of
    displacement while coll (Read, p. 47-48) encodes whether the octave
    displacement should be performed simultaneously with the written
    notes.
  -->
  <xs:attributeGroup name="att.log.octave">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="coll">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="coll"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dis" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="8"/>
          <xs:enumeration value="15"/>
          <xs:enumeration value="22"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
    <xs:attribute name="place" use="required" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.octave">
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="rend" type="data.LINERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for ossia                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.ossia">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for pad                                         * -->
  <!-- doc: Analytical domain attributes: -->
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The num attribute is the amount of
    horizontal space to be added, expressed in inter-line staff units.
  -->
  <xs:attributeGroup name="att.log.pad">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="num" use="required" type="data.NUMBER"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <!-- ************************************************************** -->
  <!-- * Attributes for pedal (piano damper pedal)                  * -->
  <xs:attributeGroup name="att.anl.pedal">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.pedal">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dir" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="down"/>
          <xs:enumeration value="up"/>
          <xs:enumeration value="half"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: When style is set to 'line', the pedal
    mark is rendered with a continuous line. When it's set to pedstar, a
    pedal down is rendered with "Ped.", a pedal up is rendered as "*", and a
    pedal "bounce" is rendered with "Ped. *".  When set to altpedstar pedal
    up and down indications are the same as with pedstar but a bounce is
    rendered with "Ped." only.
  -->
  <xs:attributeGroup name="att.vis.pedal">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attribute name="place">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="below"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="style">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="line"/>
          <xs:enumeration value="pedstar"/>
          <xs:enumeration value="altpedstar"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for phrase                                      * -->
  <!--
    doc: Analytical domain attributes:
    The join attribute should be used for linking visually separate phrase
    marks, sometimes necessary due to system breaks, that form a single
    musical phrase.
  -->
  <xs:attributeGroup name="att.anl.phrase">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="join" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: Phrase may either use tstamp and
    duration or startid and endid attributes. It is a semantic error not
    to specify one of these attribute combinations.
  -->
  <xs:attributeGroup name="att.log.phrase">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The place attribute records general,
    relative placement only. The bulge or, alternatively, the bezier
    attribute, describes the shape of the phrase mark.  The bulge attribute
    describes the curve as a set of distance values above or below an
    imaginary line connecting the endpoints of the curve while the bezier
    attribute records the placement of Bezier control points as a series
    of space-separated xy coordinates, eg. 19 45 -32 118. The bulge
    attribute must contain one or more values of type %NUMBER. The vo
    attribute is the vertical offset (from its normal position) of the
    entire rendered phrase mark.
  -->
  <xs:attributeGroup name="att.vis.phrase">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="bezier" type="xs:NMTOKENS"/>
    <xs:attribute name="bulge" type="xs:NMTOKENS"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="rend" type="data.CURVERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for reh                                         * -->
  <xs:attributeGroup name="att.anl.reh">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: %att.controlevent is expanded here in
    order to disallow the plist and layer attributes. reh may use either a
    tstamp or start attribute.  It is a semantic error not to include one of
    these attributes. The a.startendid entity is expanded here in order to
    disallow the end attribute.
  -->
  <xs:attributeGroup name="att.log.reh">
    <xs:attribute name="next" type="xs:IDREFS"/>
    <xs:attribute name="prev" type="xs:IDREFS"/>
    <xs:attribute name="staff" use="required" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="start" type="xs:IDREF"/>
    <xs:attribute name="tstamp" type="data.BEAT"/>
    <xs:attribute name="tstamp.ges" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="tstamp.real" type="data.ISOTIME"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.reh">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.typography"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="enclose">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="box"/>
          <xs:enumeration value="circle"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="place">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="above"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for rest                                        * -->
  <xs:attributeGroup name="att.anl.rest">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain (performance) attributes:  The dur.ges attribute
    records the performed duration of the rest when it differs from the
    written duration.
  -->
  <xs:attributeGroup name="att.ges.rest">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.rest">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="beam" type="data.BEAMS"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
    <xs:attribute name="tuplet" type="data.TUPLET"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:  The altsym attribute indicates that the
    specified alternative visual symbol is to be displayed. See Read, ex.
    7-14 for vertical offset example. The line attribute must contain a 
    value from 1 to the number of stafflines.  The value indicates the line
    upon which the rest stands.  The spaces attribute states how many spaces
    are covered by the rest.
  -->
  <xs:attributeGroup name="att.vis.rest">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="beam.with" type="data.PLACE"/>
    <xs:attribute name="dot.ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.vo" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.x" type="data.NUMBER"/>
    <xs:attribute name="dot.y" type="data.NUMBER"/>
    <xs:attribute name="size" type="data.SIZE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for pausa                                       * -->
  <xs:attributeGroup name="att.anl.pausa">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain (performance) attributes:  The dur.ges attribute
    records the performed duration of the rest when it differs from the
    written duration.
  -->
  <xs:attributeGroup name="att.ges.pausa">
    <xs:attribute name="dur.ges"/>
    <xs:attribute name="instr" type="xs:IDREF"/>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: fermata = corona in the mensural repertoire. -->
  <xs:attributeGroup name="att.log.pausa">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="beam" type="data.BEAMS"/>
    <xs:attribute name="corona" type="data.PLACE"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION.MENSURAL"/>
    <xs:attribute name="tuplet" type="data.TUPLET"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:  The altsym attribute indicates that the
    specified alternative visual symbol is to be displayed. See Read, ex.
    7-14 for vertical offset example. The line attribute must contain a 
    value from 1 to the number of stafflines.  The value indicates the line
    upon which the rest stands.  The spaces attribute states how many spaces
    are covered by the rest.
  -->
  <xs:attributeGroup name="att.vis.pausa">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="altsym" type="xs:IDREF"/>
    <xs:attribute name="beam.with" type="data.PLACE"/>
    <xs:attribute name="colored" type="data.BOOLEAN"/>
    <xs:attribute name="dot.ho" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.vo" type="data.VISUALOFFSET"/>
    <xs:attribute name="dot.x" type="data.NUMBER"/>
    <xs:attribute name="dot.y" type="data.NUMBER"/>
    <xs:attribute name="line" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="size" type="data.SIZE"/>
    <xs:attribute name="spaces" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for slur                                        * -->
  <!--
    doc: Analytical domain attributes:
    The join attribute should be used for linking visually separate phrase
    marks, sometimes necessary due to system breaks, that form a single
    musical phrase.
  -->
  <xs:attributeGroup name="att.anl.slur">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attribute name="join" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the slur. If logical and visual duration differ,
    it may be necessary to add a dur.vis attribute. Please note that the
    dur attribute is not a true duration, but rather a time stamp for the end
    point of the slur. Durations of longer than one measure may give the
    number of measures followed by the timestamp, e.g. "1m+3". Values
    within the current measure may be expressed as "0m+3" or as simply "3".
    Slur may either use tstamp and dur or startid and endid attributes. It is
    a semantic error not to specify one of these attribute combinations.
  -->
  <xs:attributeGroup name="att.log.slur">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The bulge or, alternatively, the bezier
    attribute, describes the shape of the slur/phrase mark.  The bulge
    attribute describes the curve as a set of distance values above or
    below an imaginary line connecting the endpoints of the curve while
    the bezier attribute records the placement of Bezier control points as
    a series of space-separated xy coordinates, eg. 19 45 -32 118. The
    bulge attribute must contain one or more values of type %NUMBER. The
    vo attribute is the vertical offset (from its normal position) of the
    entire rendered slur/phrase mark.
  -->
  <xs:attributeGroup name="att.vis.slur">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="bezier" type="xs:NMTOKENS"/>
    <xs:attribute name="bulge" type="xs:NMTOKENS"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="rend" type="data.CURVERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for space                                       * -->
  <xs:attributeGroup name="att.anl.space">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <xs:attributeGroup name="att.ges.space">
    <xs:attribute name="dur.ges"/>
  </xs:attributeGroup>
  <!-- doc: Logical domain attributes: -->
  <xs:attributeGroup name="att.log.space">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="beam" type="data.BEAMS"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="fermata" type="data.PLACE"/>
    <xs:attribute name="tuplet" type="data.TUPLET"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.space">
    <xs:attribute name="compressable" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for syl                                         * -->
  <xs:attributeGroup name="att.anl.syl">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes:
    Lyric syllable connectors:
      s (_s_pace) = word separator
      d (_d_ash)  = syllable separator
      u (_u_nderscore) = syllable extension
      t (_t_ilde) = syllable elision
    wordpos attribute records the position of the syllable in a word
  -->
  <xs:attributeGroup name="att.log.syl">
    <xs:attribute name="con">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="s"/>
          <xs:enumeration value="d"/>
          <xs:enumeration value="u"/>
          <xs:enumeration value="t"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="wordpos">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="i"/>
          <xs:enumeration value="m"/>
          <xs:enumeration value="t"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The ho attribute allows any lyric
    syllable to be horizontally offset from its normal (centered below the
    note) position.
  -->
  <xs:attributeGroup name="att.vis.syl">
    <xs:attributeGroup ref="att.typography"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="halign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="justify"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="rend" type="data.TEXTRENDITION"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for tempo                                       * -->
  <xs:attributeGroup name="att.anl.tempo">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain attributes: The midi attribute must contain the
    number of quarter notes per minute in the range from 10 to 1000. The
    value attribute is for a beats-per-minute value.
  -->
  <xs:attributeGroup name="att.ges.tempo">
    <xs:attribute name="midi" type="data.MIDITEMPO"/>
    <xs:attribute name="value" type="data.TEMPOVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Logical domain attributes: The dur.vis attribute encodes visual
    duration. (Read, p. 276-281) If logical and visual durations differ,
    it may be necessary to add a dur attribute. Please note that the dur
    attribute here is expressed in musical time, i.e. beats or other time
    stamp. Therefore, it is not a true duration, but rather a time stamp
    for the end point of the directive. The a.startendid entity is
    expanded here in order to disallow the end attribute.
  -->
  <xs:attributeGroup name="att.log.tempo">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attribute name="start" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.tempo">
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="dur.vis"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for tie                                         * -->
  <xs:attributeGroup name="att.anl.tie">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The a.startendid entity is expanded here
    in order to make startid and endid attributes required.
  -->
  <xs:attributeGroup name="att.log.tie">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attribute name="endid" use="required" type="xs:IDREF"/>
    <xs:attribute name="startid" use="required" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The bulge or, alternatively, the bezier
    attribute, describes the shape of the tie.  The bulge attribute
    describes the curve as a set of distance values above or below an
    imaginary line connecting the endpoints of the curve while the bezier
    attribute records the placement of Bezier control points as a series
    of space-separated xy coordinates, eg. 19 45 -32 118. The bulge
    attribute must contain one or more values of type %NUMBER. The vo
    attribute is the vertical offset (from its normal position) of the
    entire rendered tie.
  -->
  <xs:attributeGroup name="att.vis.tie">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attributeGroup ref="att.xy2"/>
    <xs:attribute name="bezier" type="xs:NMTOKENS"/>
    <xs:attribute name="bulge" type="xs:NMTOKENS"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="endvo" type="data.VISUALOFFSET"/>
    <xs:attribute name="rend" type="data.CURVERENDITION"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="startvo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for trill                                       * -->
  <xs:attributeGroup name="att.anl.trill">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!--
    doc: Gestural domain attributes: The dur.ges attribute records the
    performed duration.
  -->
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the trill. If logical and visual duration
    differ, it may be necessary to add a dur.vis attribute. Please note
    that the dur attribute is not a true duration, but rather a time stamp
    for the end point of the directive. Alternatively, startid and endid
    attributes may be used. An accidental for the trill may be
    supplied in the accid attribute.
  -->
  <xs:attributeGroup name="att.log.trill">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="accid" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="dur" type="data.MEASUREBEAT"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.trill">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="endho" type="data.VISUALOFFSET"/>
    <xs:attribute name="endto" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="place" type="data.PLACE"/>
    <xs:attribute name="startho" type="data.VISUALOFFSET"/>
    <xs:attribute name="startto" type="data.TSTAMPOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for tuplet                                      * -->
  <xs:attributeGroup name="att.anl.tuplet">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The dur attribute is the time taken up
    by the tuplet. If dur is omitted, the default is to calculate the total
    duration of the included notes and use the next shorter un-dotted value.
    The dots attribute may be used for dotted durations. The num and numbase
    attributes express a ratio. They may be used for explicit labelling of the
    tuplet, i.e. '3' for an 8th-note triplet, '3:2' for a quarter-note
    triplet, etc. The rendering of the ratio, however, is dependent on the
    num.format attribute described below.
  -->
  <xs:attributeGroup name="att.log.tuplet">
    <xs:attributeGroup ref="att.event"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="num" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="numbase" type="data.DURATION"/>
    <xs:attribute name="with" type="data.PLACE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The bracket.place attribute is used to
    state where the bracket will be placed in relation to the noteheads
    while the num.place attribute gives the placement of the number or ratio
    label for the tuplet (if num.visible is 'yes'). The num.visible,
    bracket.visible, and dur.visible attributes indicate whether the
    numbers, bracket, and duration are visible. The num.format attribute
    controls how the num:numbase ratio is to be displayed.
         software defaults:
         bracket.visible 'yes'
         num.visible 'yes'
  -->
  <xs:attributeGroup name="att.vis.tuplet">
    <xs:attribute name="bracket.place" type="data.PLACE"/>
    <xs:attribute name="bracket.visible" type="data.BOOLEAN"/>
    <xs:attribute name="dur.visible" type="data.BOOLEAN"/>
    <xs:attribute name="num.format">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="count"/>
          <xs:enumeration value="ratio"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num.place" type="data.PLACE"/>
    <xs:attribute name="num.visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for tupletspan                                  * -->
  <xs:attributeGroup name="att.anl.tupletspan">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The dur attribute encodes the logical
    and visual duration of the tuplet. Unlike other control events where
    the dur attribute is expressed as a time stamp, dur here is a true
    duration.
  -->
  <xs:attributeGroup name="att.log.tupletspan">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attribute name="dots" type="data.AUGMENTDOT"/>
    <xs:attribute name="dur" type="data.DURATION"/>
    <xs:attribute name="num" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="numbase" type="data.DURATION"/>
    <xs:attribute name="with" type="data.PLACE"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes:
    software defaults:
    bracket.visible 'yes'  What about triplets?
    num.visible 'yes'
  -->
  <xs:attributeGroup name="att.vis.tupletspan">
    <xs:attribute name="bracket.place" type="data.PLACE"/>
    <xs:attribute name="bracket.visible" type="data.BOOLEAN"/>
    <xs:attribute name="dur.visible" type="data.BOOLEAN"/>
    <xs:attribute name="num.format">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="count"/>
          <xs:enumeration value="ratio"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num.place" type="data.PLACE"/>
    <xs:attribute name="num.visible" type="data.BOOLEAN"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for turn                                        * -->
  <xs:attributeGroup name="att.anl.turn">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: Accidentals for the turn may be
    supplied in the accidupper and accidlower attributes. The a.startendid
    entity is expanded here in order to disallow the end attribute. When
    the delayed attribute is set to 'yes', the turn begins on the second
    half of the beat. See Read, p. 246.
  -->
  <xs:attributeGroup name="att.log.turn">
    <xs:attributeGroup ref="att.controlevent"/>
    <xs:attribute name="accidupper" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="accidlower" type="data.ACCIDENTAL.EXPLICIT"/>
    <xs:attribute name="delayed" type="data.BOOLEAN"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inv"/>
          <xs:enumeration value="norm"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="start" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!-- doc: Visual domain attributes: -->
  <xs:attributeGroup name="att.vis.turn">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.visualoffset"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="place" type="data.PLACE"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Attributes for verse                                       * -->
  <!-- doc: Analytical domain attributes: -->
  <xs:attributeGroup name="att.anl.verse">
    <xs:attributeGroup ref="att.common.anl"/>
  </xs:attributeGroup>
  <!-- doc: Gestural domain attributes: -->
  <!--
    doc: Logical domain attributes: The n attribute should be used for
    verse numbers. Numbers need not be consecutive; they may be expressed
    as ranges, e.g. 2-3,6. A value of 'true' may be used in the refrain
    attribute in order to indicate a common, usually centered, refrain
    (Mup User's Guide, p. 44). The rhythm attribute may be used to specify
    a rhythm for the lyrics that differs from that of the notes on the
    staff.
  -->
  <xs:attributeGroup name="att.log.verse">
    <xs:attribute name="refrain" type="data.BOOLEAN"/>
    <xs:attribute name="rhythm"/>
  </xs:attributeGroup>
  <!--
    doc: Visual domain attributes: The a.visualoffset entity is expanded
    here in order to disallow ho.
  -->
  <xs:attributeGroup name="att.vis.verse">
    <xs:attributeGroup ref="att.typography"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="to" type="data.TSTAMPOFFSET"/>
    <xs:attribute name="vo" type="data.VISUALOFFSET"/>
  </xs:attributeGroup>
  <!-- ************************************************************** -->
  <!-- * Element model classes                                      * -->
  <!-- ************************************************************** -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.addressLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.address">
          <xs:attributeGroup ref="attlist.address"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.annotLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.annot">
          <xs:attributeGroup ref="attlist.annot"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.biblLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.bibl">
          <xs:attributeGroup ref="attlist.bibl"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.dateLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.date">
          <xs:attributeGroup ref="attlist.date"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.editionLike" abstract="true" substitutionGroup="model.biblPart"/>
  <xs:element name="model.editorialLike" abstract="true"/>
  <xs:element name="model.graphicLike" abstract="true">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.graphic"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.identifierLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.identifier">
          <xs:attributeGroup ref="attlist.identifier"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:group name="model.lbLike">
    <xs:sequence>
      <xs:element ref="lb"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="model.milestoneLike.text">
    <xs:choice>
      <xs:element ref="lb"/>
      <xs:element ref="pb"/>
    </xs:choice>
  </xs:group>
  <xs:element name="model.nameLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.name">
          <xs:attributeGroup ref="attlist.name"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.noteModifierLike" abstract="true"/>
  <xs:element name="model.numLike" abstract="true" substitutionGroup="model.measurementLike"/>
  <xs:element name="model.pLike" abstract="true" substitutionGroup="model.textcomponentLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.p">
          <xs:attributeGroup ref="attlist.p"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.pbLike" abstract="true" substitutionGroup="model.milestoneLike.music">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pb">
          <xs:attributeGroup ref="attlist.pb"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.rendLike" abstract="true"/>
  <xs:element name="model.repositoryLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.repository">
          <xs:attributeGroup ref="attlist.repository"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.titleLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.title">
          <xs:attributeGroup ref="attlist.title"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="model.pgmetaLike">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="fw"/>
      <xs:element minOccurs="0" ref="pgdesc"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="model.pgmetaLike.score">
    <xs:sequence>
      <xs:element minOccurs="0" ref="pghead1"/>
      <xs:element minOccurs="0" ref="pghead2"/>
      <xs:element minOccurs="0" ref="pgfoot1"/>
      <xs:element minOccurs="0" ref="pgfoot2"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="model.eventLike.common" abstract="true"/>
  <xs:element name="model.eventLike.neume-mensural" abstract="true"/>
  <xs:element name="model.eventLike.mensural-cmn" abstract="true"/>
  <!-- '%n.accid;|%n.barline;|%n.dot;|%n.keychange;' -->
  <xs:element name="model.controleventLike.common" abstract="true" substitutionGroup="model.controleventLike"/>
  <xs:element name="model.keyaccidLike" abstract="true">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.keyaccid"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.keysigLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.keysig">
          <xs:attributeGroup ref="attlist.keysig"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.backLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.back">
          <xs:attributeGroup ref="attlist.back"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.divLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.div">
          <xs:attributeGroup ref="attlist.div"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.frontLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.front">
          <xs:attributeGroup ref="attlist.front"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.headLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.head">
          <xs:attributeGroup ref="attlist.head"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.lLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.l">
          <xs:attributeGroup ref="attlist.l"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.listLike" abstract="true" substitutionGroup="model.textcomponentLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.list">
          <xs:attributeGroup ref="attlist.list"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.quoteLike" abstract="true" substitutionGroup="model.textcomponentLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.blockquote">
          <xs:attributeGroup ref="attlist.blockquote"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.tableLike" abstract="true" substitutionGroup="model.textcomponentLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.table">
          <xs:attributeGroup ref="attlist.table"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.lgLike" abstract="true" substitutionGroup="model.textcomponentLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.lg">
          <xs:attributeGroup ref="attlist.lg"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.labelLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.label">
          <xs:attributeGroup ref="attlist.label"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.endingLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ending">
          <xs:attributeGroup ref="attlist.ending"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.instrdefLike" abstract="true">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.instrdef"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.layerLike" abstract="true" substitutionGroup="model.measurePart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.layer">
          <xs:attributeGroup ref="attlist.layer"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.layerdefLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.layerdef">
          <xs:attributeGroup ref="attlist.layerdef"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.mdivLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.mdiv">
          <xs:attributeGroup ref="attlist.mdiv"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.milestoneLike.music" abstract="true"/>
  <xs:group name="model.musicPart">
    <xs:sequence>
      <xs:element minOccurs="0" ref="model.frontLike"/>
      <xs:choice minOccurs="0">
        <xs:element ref="body"/>
        <xs:element ref="group"/>
      </xs:choice>
      <xs:element minOccurs="0" ref="model.backLike"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="model.partLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.part">
          <xs:attributeGroup ref="attlist.part"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.partsLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.parts">
          <xs:attributeGroup ref="attlist.parts"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.scoreLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.score">
          <xs:attributeGroup ref="attlist.score"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.scoredefLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.scoredef">
          <xs:attributeGroup ref="attlist.scoredef"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.sectionLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.section">
          <xs:attributeGroup ref="attlist.section"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.staffLike" abstract="true" substitutionGroup="model.measurePart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.staff">
          <xs:attributeGroup ref="attlist.staff"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.staffdefLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.staffdef">
          <xs:attributeGroup ref="attlist.staffdef"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.staffgrpLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.staffgrp">
          <xs:attributeGroup ref="attlist.staffgrp"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.nameLike.agent" abstract="true"/>
  <xs:element name="model.nameLike.geogname" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.geogname">
          <xs:attributeGroup ref="attlist.geogname"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:group name="model.nameLike.place">
    <xs:choice>
      <xs:element ref="geogname"/>
      <xs:element ref="model.repositoryLike"/>
    </xs:choice>
  </xs:group>
  <xs:element name="model.nameLike.label" abstract="true"/>
  <!-- Include desired elements -->
  <!-- Create appropriate classess -->
  <xs:element name="model.figureLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.fig">
          <xs:attributeGroup ref="attlist.fig"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.captionLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.caption">
          <xs:attributeGroup ref="attlist.caption"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="model.availabilityPart">
    <xs:sequence>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="acqsource"/>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="accessdesc"/>
          <xs:element minOccurs="0" ref="price"/>
        </xs:sequence>
      </xs:sequence>
      <xs:element minOccurs="0" ref="userestrict"/>
      <xs:element minOccurs="0" ref="sysreq"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="model.biblPart" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.edition">
          <xs:attributeGroup ref="attlist.edition"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.editorialdeclPart" abstract="true"/>
  <xs:complexType name="model.encodingPart">
    <xs:sequence>
      <xs:element minOccurs="0" ref="appinfo"/>
      <xs:element minOccurs="0" ref="projectdesc"/>
      <xs:element minOccurs="0" ref="samplingdecl"/>
      <xs:element minOccurs="0" ref="editorialdecl"/>
    </xs:sequence>
  </xs:complexType>
  <!--
    doc: Location/referencing elements. These entities must be declared
    before the model.textphraseLike and model.textphraseLike.limited
    entities.
  -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:group name="model.locrefLike">
    <xs:choice>
      <xs:element ref="extptr"/>
      <xs:element ref="extref"/>
      <xs:element ref="ptr"/>
      <xs:element ref="ref"/>
    </xs:choice>
  </xs:group>
  <xs:group name="model.ptrLike">
    <xs:sequence>
      <xs:element ref="ptr"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="model.measurementLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.num">
          <xs:attributeGroup ref="attlist.num"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.lyricsLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.lyrics">
          <xs:attributeGroup ref="attlist.lyrics"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.sylLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.syl">
          <xs:attributeGroup ref="attlist.syl"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.verseLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.verse">
          <xs:attributeGroup ref="attlist.verse"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!--
    This entity must be declared before the model.controleventLike.cmn
    entity.
  -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.ornamentLike.cmn" abstract="true" substitutionGroup="model.controleventLike.cmn"/>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:group name="model.neumeModifierLike">
    <xs:choice>
      <xs:element ref="accid"/>
      <xs:element ref="artic"/>
      <xs:element ref="model.verseLike"/>
    </xs:choice>
  </xs:group>
  <xs:element name="model.eventLike.neume" abstract="true"/>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <!-- <!ENTITY % model.notaModifierLike  '%n.accid;|%n.artic;|%n.dot;'> -->
  <!-- |%model.sylLike;|%model.verseLike;'> -->
  <xs:element name="model.eventLike.mensural" abstract="true"/>
  <!-- <!ENTITY % model.notaModifierLike  '_DUMMYmodel.notaModifierLike'> -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.measureLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.measure">
          <xs:attributeGroup ref="attlist.measure"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.ossiaLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ossia">
          <xs:attributeGroup ref="attlist.ossia"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.controleventLike.instruments" abstract="true" substitutionGroup="model.controleventLike.cmn"/>
  <xs:element name="model.controleventLike.cmn" abstract="true" substitutionGroup="model.controleventLike"/>
  <xs:group name="model.eventLike.cmn">
    <xs:choice>
      <xs:element ref="beam"/>
      <xs:element ref="bend"/>
      <xs:element ref="beatrpt"/>
      <xs:element ref="btrem"/>
      <xs:element ref="chord"/>
      <xs:element ref="ftrem"/>
      <xs:element ref="gliss"/>
      <xs:element ref="halfmrpt"/>
      <xs:element ref="note"/>
      <xs:element ref="rest"/>
      <xs:element ref="tuplet"/>
    </xs:choice>
  </xs:group>
  <xs:element name="model.eventLike.cmn.measureFilling" abstract="true" substitutionGroup="model.measurePart"/>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.chordtableLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.chordtable">
          <xs:attributeGroup ref="attlist.chordtable"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.harmLike" abstract="true" substitutionGroup="model.controleventLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.harm">
          <xs:attributeGroup ref="attlist.harm"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.graphicprimitiveLike" abstract="true"/>
  <xs:element name="model.symboltableLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.symboltable">
          <xs:attributeGroup ref="attlist.symboltable"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.apparatusLike" abstract="true" substitutionGroup="model.measurePart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.app">
          <xs:attributeGroup ref="attlist.app"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- doc: When meiCritApp is IGNOREd, use the following declaration. -->
  <!--  doc: This entity must be declared before the model.controlevents entity. -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.midiLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.midi">
          <xs:attributeGroup ref="attlist.midi"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Editorial/Transcription elements. -->
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.frontPart" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.titlepage">
          <xs:attributeGroup ref="attlist.titlepage"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="model.transcriptionLike" abstract="true" substitutionGroup="model.measurePart"/>
  <xs:element name="model.editLike" abstract="true" substitutionGroup="model.measurePart"/>
  <xs:group name="model.choicePart">
    <xs:choice>
      <xs:element ref="corr"/>
      <xs:element ref="orig"/>
      <xs:element ref="reg"/>
      <xs:element ref="sic"/>
      <xs:element ref="unclear"/>
      <xs:element ref="model.editorialLike"/>
    </xs:choice>
  </xs:group>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.facsimileLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.facsimile">
          <xs:attributeGroup ref="attlist.facsimile"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:element name="model.alignLike" abstract="true">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.timeline">
          <xs:attributeGroup ref="attlist.timeline"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <!-- Include desired elements -->
  <!-- Create appropriate classes -->
  <xs:group name="model.headerPart">
    <xs:sequence>
      <xs:element minOccurs="0" ref="encodingdesc"/>
      <xs:element minOccurs="0" ref="profiledesc"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="model.physdescPart">
    <xs:choice>
      <xs:element ref="condition"/>
      <xs:element ref="dimensions"/>
      <xs:element ref="exhibithist"/>
      <xs:element ref="extent"/>
      <xs:element ref="handlist"/>
      <xs:element ref="inscription"/>
      <xs:element ref="physmedium"/>
      <xs:element ref="physloc"/>
      <xs:element ref="provenance"/>
      <xs:element ref="repository"/>
      <xs:element ref="model.frontPart"/>
      <xs:element ref="treatmenthist"/>
      <xs:element ref="treatmentsched"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="model.profiledescPart">
    <xs:sequence>
      <xs:element minOccurs="0" ref="creation"/>
      <xs:element minOccurs="0" ref="langusage"/>
      <xs:element minOccurs="0" ref="classification"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="model.pubstmtPart">
    <xs:choice>
      <xs:element ref="model.nameLike.geogname"/>
      <xs:element ref="model.addressLike"/>
      <xs:element ref="respstmt"/>
      <xs:element ref="model.dateLike"/>
      <xs:element ref="identifier"/>
      <xs:element ref="availability"/>
    </xs:choice>
  </xs:group>
  <!-- doc: Phrase-level text elements. -->
  <xs:group name="model.textphraseLike">
    <xs:choice>
      <xs:group ref="model.locrefLike"/>
      <xs:element ref="model.addressLike"/>
      <xs:element ref="model.annotLike"/>
      <xs:element ref="model.biblLike"/>
      <xs:element ref="model.editorialLike"/>
      <xs:element ref="model.nameLike"/>
      <xs:element ref="model.nameLike.agent"/>
      <xs:group ref="model.nameLike.place"/>
      <xs:element ref="model.nameLike.label"/>
      <xs:element ref="model.dateLike"/>
      <xs:element ref="model.rendLike"/>
      <xs:element ref="model.measurementLike"/>
      <xs:element ref="model.titleLike"/>
      <xs:element ref="model.identifierLike"/>
      <xs:element ref="model.figureLike"/>
      <xs:group ref="model.milestoneLike.text"/>
    </xs:choice>
  </xs:group>
  <!--
    doc: Anchored text sub-elements. These occur as part of the
    representation of the score, as opposed to the textual matter which
    accompanies it. % model.anchoredtext is equivalent to % model.textphraseLike
    without the pb element.
  -->
  <xs:group name="model.textphraseLike.limited">
    <xs:choice>
      <xs:group ref="model.locrefLike"/>
      <xs:element ref="model.addressLike"/>
      <xs:element ref="model.biblLike"/>
      <xs:element ref="model.editorialLike"/>
      <xs:element ref="model.nameLike"/>
      <xs:element ref="model.nameLike.agent"/>
      <xs:group ref="model.nameLike.place"/>
      <xs:element ref="model.nameLike.label"/>
      <xs:element ref="model.dateLike"/>
      <xs:element ref="model.rendLike"/>
      <xs:element ref="model.measurementLike"/>
      <xs:element ref="model.titleLike"/>
      <xs:element ref="model.identifierLike"/>
      <xs:element ref="model.figureLike"/>
      <xs:group ref="model.lbLike"/>
    </xs:choice>
  </xs:group>
  <!--
    doc: Paragraph content model. A paragraph may contain inline elements
    and all the other block-level elements except lg and itself. The
    % model.textphrase and % model.edit entities must be declared prior to the
    model.paracontent entity.
  -->
  <xs:group name="model.paracontentPart">
    <xs:choice>
      <xs:element ref="model.quoteLike"/>
      <xs:element ref="model.listLike"/>
      <xs:element ref="model.tableLike"/>
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:group>
  <!-- doc: Block level text elements. -->
  <xs:element name="model.textcomponentLike" abstract="true"/>
  <!--
    If a single notational style is INCLUDED, some high-level content models are
    more restrictive.
  -->
  <!-- The following declarations are used when two or more notation styles are INCLUDED. -->
  <!-- doc: -->
  <xs:complexType name="model.clefchangePart">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="clef"/>
    </xs:sequence>
  </xs:complexType>
  <!-- doc: Multiple clefs -->
  <xs:element name="model.staffdefPart.multiplyDefinable" abstract="true"/>
  <!-- If more than one notational style is INCLUDED, a mix of notational styles is allowed. -->
  <!-- doc: Control events modify or otherwise depend on the existence of notated events. -->
  <xs:element name="model.controleventLike" abstract="true"/>
  <!--
    doc: Notated events. Sometimes referred to as "logical" events. The
    mrest, mrpt, mspace, multirest, and multirpt elements are not included
    in this list since in the measure element's content model they are
    alternatives to the elements listed here. They are, however, part of the
    att.events class.
  -->
  <xs:group name="model.eventLike">
    <xs:choice>
      <xs:element ref="model.eventLike.common"/>
      <xs:element ref="model.eventLike.neume"/>
      <xs:element ref="model.eventLike.neume-mensural"/>
      <xs:element ref="model.eventLike.mensural"/>
      <xs:element ref="model.eventLike.mensural-cmn"/>
      <xs:group ref="model.eventLike.cmn"/>
    </xs:choice>
  </xs:group>
  <!-- doc: Notated events at the layer level -->
  <xs:group name="model.layerPart">
    <xs:choice>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.noteModifierLike"/>
      <xs:element ref="model.verseLike"/>
      <xs:element ref="model.sylLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
    </xs:choice>
  </xs:group>
  <!--
    <!ENTITY % model.layerPart   '%model.eventLike;|%model.midiLike;|%model.editLike;|
    %model.transcriptionLike;|%model.noteModifierLike;|
    %model.verseLike;|%model.sylLike;|
    %model.eventLike.cmn.measureFilling;'>
  -->
  <!-- doc: Measure content model -->
  <xs:element name="model.measurePart" abstract="true"/>
  <!-- doc: Staff content model -->
  <xs:complexType name="model.staffPart">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.measureLike"/>
      <xs:element ref="model.layerLike"/>
      <xs:element ref="model.milestoneLike.music"/>
      <xs:group ref="model.layerPart"/>
      <xs:element ref="model.annotLike"/>
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.apparatusLike"/>
      <xs:element ref="model.controleventLike"/>
    </xs:choice>
  </xs:complexType>
  <!-- doc: Reading content model -->
  <xs:group name="model.rdgPart">
    <xs:choice>
      <xs:element ref="model.scoredefLike"/>
      <xs:element ref="model.staffgrpLike"/>
      <xs:element ref="model.staffdefLike"/>
      <xs:sequence>
        <xs:element ref="model.sectionLike"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.endingLike"/>
      </xs:sequence>
      <xs:element ref="model.divLike"/>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.measureLike"/>
        <xs:element minOccurs="0" ref="model.milestoneLike.music"/>
      </xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.layerLike"/>
        <xs:group ref="model.eventLike"/>
        <xs:element ref="model.sylLike"/>
      </xs:choice>
      <xs:sequence>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="model.staffLike"/>
          <xs:element ref="model.editLike"/>
          <xs:element ref="model.transcriptionLike"/>
        </xs:choice>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.ossiaLike"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="model.controleventLike"/>
          <xs:element ref="model.lyricsLike"/>
          <xs:element ref="model.midiLike"/>
          <xs:element ref="model.annotLike"/>
        </xs:choice>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.graphicprimitiveLike"/>
      </xs:sequence>
      <xs:element ref="model.apparatusLike"/>
    </xs:choice>
  </xs:group>
  <!-- doc: Score content model -->
  <xs:group name="model.scorePart">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.measureLike"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.staffLike"/>
        <xs:element ref="model.milestoneLike.music"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <!-- doc: Score components -->
  <xs:group name="model.scorecomponentLike">
    <xs:choice>
      <xs:element ref="model.scoredefLike"/>
      <xs:element ref="model.staffgrpLike"/>
      <xs:element ref="model.staffdefLike"/>
      <xs:sequence>
        <xs:element ref="model.sectionLike"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.endingLike"/>
      </xs:sequence>
      <xs:element ref="model.divLike"/>
      <xs:group ref="model.scorePart"/>
      <xs:element ref="model.apparatusLike"/>
    </xs:choice>
  </xs:group>
  <!-- ************************************************************** -->
  <!-- * Element Declarations (By Module)                           * -->
  <!-- ************************************************************** -->
  <!--  Shared Elements -->
  <!-- Basic text elements -->
  <!--
    doc: abbr (abbreviation) contains an abbreviation of any sort. The
         type attribute may be used to classify the abbreviation according
         to some convenient typology. Sample values include:
    
      suspension     the abbreviation provides the first letter(s) of the
                     word or phrase, omitting the remainder.
      contraction    the abbreviation omits some letter(s) in the middle.
      brevigraph     the abbreviation comprises a special symbol or mark.
      superscription the abbreviation includes writing above the line.
      acronym        the abbreviation comprises the initial letters of
                     the words of a phrase.
      title          the abbreviation is for a title of address (Dr, Ms,
                     Mr, ...)
      organization   the abbreviation is for the name of an organization.
      geographic     the abbreviation is for a geographic name.
    
    This tag is the mirror image of the <expan> tag; both allow the
    encoder to transcribe both an abbreviation and its expansion. In
    <abbr>, however, the original is transcribed as the content of the
    element and the expansion as an attribute value; <expan> reverses
    this. The choice between the two is up to the user. The <abbr> tag is
    not required; if appropriate, the encoder may transcribe abbreviations
    in the source text silently, without tagging them. If abbreviations
    are not transcribed directly but expanded silently, then the MEI
    header should so indicate. The cert attribute signifies the degree of
    certainty ascribed to the expansion of the abbreviation. The expan
    attribute gives an expansion of the abbreviation. The resp attribute
    contains an ID reference to an element containing the name of the
    editor or transcriber responsible for supplying the expansion of the
    abbreviation.
    Used by: model.editorialLike
    Module:  meiShared
  -->
  <xs:complexType name="content.abbr" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="abbr" substitutionGroup="model.editorialLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.abbr">
          <xs:attributeGroup ref="attlist.abbr"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.abbr">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.trans"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="expan"/>
  </xs:attributeGroup>
  <!--
    doc: A postal address 
    Used by: model.addressLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.address">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="addressline"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="address" substitutionGroup="model.addressLike"/>
  <xs:attributeGroup name="attlist.address">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Single line of an address 
    Used by: address 
    Module:  meiShared
  -->
  <xs:complexType name="content.addressline" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="addressline">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.addressline">
          <xs:attributeGroup ref="attlist.addressline"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.addressline">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Page-anchored text. The content model here is similar to paragraph
    without %model.textcomponent and %n.pb sub-elements. If the startid attribute
    is present, then the xy coordinates are relative to the xy coordinates
    of the referenced element. Otherwise, they are assumed to be absolute
    page coordinate references. 
    Used by: model.graphicprimitiveLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.anchoredtext" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="anchoredtext" substitutionGroup="model.graphicprimitiveLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.anchoredtext">
          <xs:attributeGroup ref="attlist.anchoredtext"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.anchoredtext">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.xy.required"/>
    <xs:attribute name="startid" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: The annot element provides a way to group participating *events*
    and/or *control events*, the notes that form a descending bass line or
    phrase marks, for example, and provide a label for or comment regarding
    the group. An enumerated list of event IDs may be given in the plist
    attribute.  Alternatively, if only the start and/or end events in a
    group are to be marked, then use the startid and endid attributes.  An
    editorial or analytical comment or observation, encoded elsewhere, such
    as in the front or back matter, in score text elements, or in an external
    document may be pointed to using the link.common, link.internal, or
    link.external attributes. Alternatively, the observation may be included
    directly within the annot element. The annot element, along with other
    elements with %att.link.external attributes, may also be used to link/
    synchronize elements within the MEI file to external media such as images
    or sound recordings. The ID of the MEI element(s) to be linked from
    should be encoded in the plist attribute while the link to the external
    media may be encoded in the href or entityref attributes or in the body
    of the annotation using extref or extptr elements. 
    Used by: model.annotLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.annot" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="annot" substitutionGroup="model.annotLike"/>
  <xs:attributeGroup name="attlist.annot">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.log.annot"/>
    <xs:attributeGroup ref="att.anl.annot"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attribute name="resp" type="xs:IDREF"/>
    <xs:attribute name="source" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Bibliographic reference. May function as a hypertext reference
    to an external electronic resource. A more structured content model,
    similar to TEI's biblFull, requires new elements that function like
    those in the meiHead DTD, but that do not duplicate their names. 
    Used by: model.biblLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.bibl" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.biblPart"/>
      <xs:group ref="model.textphraseLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="bibl" substitutionGroup="model.biblLike"/>
  <xs:attributeGroup name="attlist.bibl">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
  </xs:attributeGroup>
  <!--
    doc: Date contains a date in any format. 
    Used by: model.dateLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.date" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike"/>
  </xs:complexType>
  <xs:element name="date" substitutionGroup="model.dateLike"/>
  <xs:attributeGroup name="attlist.date">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.date"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: The edition designation is a word or text phrase that normally
    indicates a difference in either content or form between the item
    being described and a related item previously issued by the same
    publisher/distributor (e.g. 2nd edition, version 2.0, etc.), or
    simultaneously issued by either the same publisher/distributor or
    another publisher/distributor (e.g. large print edition, British
    edition, etc.). The %model.textphraseLike.limited entity is used
    here in order to disallow the pb element. 
    Used by: model.biblPart editionstmt 
    Module:  meiShared
  -->
  <xs:complexType name="content.edition" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="edition" substitutionGroup="model.editionLike"/>
  <xs:attributeGroup name="attlist.edition">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: expan (expansion) contains the expansion of an abbreviation. The
    type attribute may be used to classify the abbreviation according to
    some convenient typology. See example values above. This tag is the
    mirror image of the <abbr> tag; both allow the encoder to transcribe
    both an abbreviation and its expansion. In <abbr>, however, the
    original is transcribed as the content of the element and the
    expansion as an attribute value; <expan> reverses this. The choice
    between the two is up to the user. The <expan> tag is not required; if
    appropriate, the encoder may expand abbreviations in the source text
    silently, without tagging them. If this is done, the MEI header should
    so indicate. The abbr attribute gives the abbreviation in its
    unexpanded form. The cert attribute signifies the degree of certainty
    ascribed to the expansion of the abbreviation. The resp attribute
    contains an ID reference to an element containing the name of the
    editor or transcriber responsible for supplying the expansion of the
    abbreviation held as the content of the <expan> element. 
    Used by: model.editorialLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.expan" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="expan" substitutionGroup="model.editorialLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.expan">
          <xs:attributeGroup ref="attlist.expan"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.expan">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.trans"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="abbr"/>
  </xs:attributeGroup>
  <!--
    doc: Contains a brief prose description of the appearance or content of a
    graphic figure, for use when documenting an image without displaying it.
    Best practice suggests the use of controlled vocabulary. Don't confuse
    this element with a figure caption. A caption is text primarily intended
    for display with an illustration. It may or may not function as a
    description of the illustration. 
    Used by: figure surface zone
    Module:  meiFigures
  -->
  <xs:complexType name="content.figdesc" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.textcomponentLike"/>
      <xs:element ref="model.annotLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="figdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.figdesc">
          <xs:attributeGroup ref="attlist.figdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.figdesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Forme work, e.g. header and footer. This element is intended for
    capture of header/footer material that is non-repeating; that is, it
    occurs on isolated pages. For running headers and footers use pgheadN
    and pgfootN elements. Auto-generated page numbers may be included with
    a processing instruction. 
    Used by: model.pgmetaLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.fw" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="fw">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.fw">
          <xs:attributeGroup ref="attlist.fw"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.fw">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Indicates the location of an inline graphic, illustration, or
    figure. 
    Used by: model.graphicLike 
    Module:  meiShared
  -->
  <xs:element name="graphic" substitutionGroup="model.graphicLike"/>
  <xs:attributeGroup name="attlist.graphic">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attribute name="height" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="units"/>
    <xs:attribute name="width" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Bibliographic, e.g., International Standard Book/Music Number,
    Library of Congress Control Number, Publisher's Number, or personal
    identifier. 
    Used by: model.textphraseLike model.textphraseLike.limited model.pubstmtPart 
    Module:  meiShared
  -->
  <xs:complexType name="content.identifier" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="identifier" substitutionGroup="model.identifierLike"/>
  <xs:attributeGroup name="attlist.identifier">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Text line break. The n attribute should be used to record a label
    for the line, i.e. most likely a line number. See comment on verse element
    for description of func attribute. 
    Used by: model.milestoneLike.text model.textphraseLike.limited 
    Module:  meiShared
  -->
  <xs:element name="lb">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.lb"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.lb">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="func">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="line"/>
          <xs:enumeration value="group"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="source" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Contains the name of an individual, such as 'Henry VIII, King of
    England', a corporate body, such as 'The Beatles', a geographical place
    or a generative mechanical process. They are available here in order to
    record any identifiers or dates, associated with the name, i.e., birth
    and death in the case of persons or creation and dissolution in the
    case of a corporate entity or place.  When name parts are needed, use
    name sub-elements. The recommended values for the type attribute are:
    pers, corp, place, process. The role attribute may be used to record
    the function of the person, corporate body, etc. 
    Used by: model.nameLike.agent 
    Module:  meiShared
  -->
  <xs:complexType name="content.name" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="name" substitutionGroup="model.nameLike"/>
  <xs:attributeGroup name="attlist.name">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="role"/>
  </xs:attributeGroup>
  <!--
    doc: A number in any form 
    Used by: model.measurementLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.num" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="num" substitutionGroup="model.numLike"/>
  <xs:attributeGroup name="attlist.num">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attribute name="units"/>
  </xs:attributeGroup>
  <!--
    doc: Paragraph 
    Used by: model.textcomponentLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.p" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.paracontentPart"/>
  </xs:complexType>
  <xs:element name="p" substitutionGroup="model.pLike"/>
  <xs:attributeGroup name="attlist.p">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!--
    doc: Page break. Meta-data about an accompanying page image may be
    recorded in the pgdesc element. The n attribute records the page number
    in the source. It need not be an integer, e.g. 'iv', or 'p17-3'. The
    logical page number can be calculated by counting previous pb ancestor
    elements. The source attribute is provided for linking to the
    bibliographic description of the source(s) that contains the page break.
    When used in a score context, a page break implies an accompanying
    system break. Permitting the following attributes will make it possible
    to record layout changes at a pagebreak rather than forcing a new
    section element:
              botmar             %data.NUMBER;         #IMPLIED
              height             %data.NUMBER;         #IMPLIED
              leftmar            %data.NUMBER;         #IMPLIED
              rightmar           %data.NUMBER;         #IMPLIED
              topmar             %data.NUMBER;         #IMPLIED
              spacing.system     CDATA                 #IMPLIED
              width              %data.NUMBER;         #IMPLIED 
    Used by: model.milestoneLike.text model.milestoneLike.music 
    Module:  meiShared
  -->
  <xs:complexType name="content.pb">
    <xs:complexContent>
      <xs:extension base="model.pgmetaLike"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="pb" substitutionGroup="model.pbLike"/>
  <xs:attributeGroup name="attlist.pb">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attribute name="func">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="verso"/>
          <xs:enumeration value="recto"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="source" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <!--
    doc: Contains a brief prose description of the appearance or description
    of the content of a physical page. Best practice suggests the use of
    controlled vocabulary. Don't confuse this element with a figure caption.
    A caption is text primarily intended for display with an illustration.
    It may or may not function as a description of the illustration. Perhaps
    a better model is (%model.locrefLike;)* with which one could force page-
    level meta-data to the header where it could be encoded in notesstmt
    elements. 
    Used by: pb 
    Module:  meiShared
  -->
  <xs:complexType name="content.pgdesc" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.textcomponentLike"/>
      <xs:element ref="model.annotLike"/>
      <xs:group ref="model.locrefLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pgdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pgdesc">
          <xs:attributeGroup ref="attlist.pgdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pgdesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Special visual rendering of text. A positive value for rotation
    rotates the text in a counter-clockwise fashion, while negative values
    produce clockwise rotation. The altrend attribute can be used to
    extend the values of the rend attribute. One or the other of the rend
    and altrend attributes is required. 
    Used by: model.rendLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.rend" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="rend" substitutionGroup="model.rendLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.rend">
          <xs:attributeGroup ref="attlist.rend"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.rend">
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typography"/>
    <xs:attribute name="altrend"/>
    <xs:attribute name="halign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="justify"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="rend" type="data.TEXTRENDITION"/>
    <xs:attribute name="rotation" type="data.DEGREES"/>
    <xs:attribute name="valign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="middle"/>
          <xs:enumeration value="bottom"/>
          <xs:enumeration value="baseline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Institution which holds a bibliographic item. Sub-units of the
    institution may be marked with nested repository elements. 
    Used by: model.nameLike.place 
    Module:  meiShared
  -->
  <xs:complexType name="content.repository" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="repository" substitutionGroup="model.repositoryLike"/>
  <xs:attributeGroup name="attlist.repository">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Stacked text, e.g. an inline table with a single column. 
    Used by: model.rendLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.stack" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike"/>
  </xs:complexType>
  <xs:element name="stack" substitutionGroup="model.rendLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.stack">
          <xs:attributeGroup ref="attlist.stack"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.stack">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attribute name="delim"/>
    <xs:attribute name="align">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="rightdigit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Title of a bibliographic entity. The type attribute may be used
    to classify the title according to some convenient typology. Sample
    values include: 
       main         main title 
       subordinate  subtitle, title of part 
       parallel     alternate title, often in another language, by which
                    the work is also known 
       abbreviated  abbreviated form of title
       uniform      uniform title
    
    The type attribute is provided for convenience in analysing titles and
    processing them according to their type; where such specialized
    processing is not necessary, there is no need for such analysis, and the
    entire title, including subtitles and any parallel titles, may be
    enclosed within a single <title> element. The level attribute indicates
    whether this is the title of an article, monograph, journal, series, or
    unpublished material. Title parts may be encoded in title sub-elements
    since title is included in model.textphrase. 
    Used by: model.titleLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.title" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="title" substitutionGroup="model.titleLike"/>
  <xs:attributeGroup name="attlist.title">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="level">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="a"/>
          <xs:enumeration value="m"/>
          <xs:enumeration value="j"/>
          <xs:enumeration value="s"/>
          <xs:enumeration value="u"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- Multiple Repertoires -->
  <!-- Neume, mensural, and CMN: -->
  <!--
    doc: The clef element must be used when a staff employs multiple
    simultaneous clefs. 
    Used by: model.clefchangePart model.staffdefPart.multiplyDefinable 
    Module:  meiShared
  -->
  <xs:element name="clef" substitutionGroup="model.staffdefPart.multiplyDefinable">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.clef"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.clef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.anl.clef"/>
    <xs:attributeGroup ref="att.log.clef"/>
    <xs:attributeGroup ref="att.vis.clef"/>
  </xs:attributeGroup>
  <!--
    doc: Custos 
    Used by: model.eventLike.common 
    Module:  meiShared
  -->
  <xs:element name="custos" substitutionGroup="model.eventLike.common">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.custos"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.custos">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.custos"/>
    <xs:attributeGroup ref="att.vis.custos"/>
    <xs:attributeGroup ref="att.anl.sb"/>
  </xs:attributeGroup>
  <!--
    doc: Mid-measure clef change. Coming as it does, in the middle of a
    measure, a clef change is an event. 
    Used by: model.eventLike.common 
    Module:  meiShared
  -->
  <xs:complexType name="content.clefchange">
    <xs:complexContent>
      <xs:extension base="model.clefchangePart"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="clefchange" substitutionGroup="model.eventLike.common">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.clefchange">
          <xs:attributeGroup ref="attlist.clefchange"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.clefchange">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.event"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.clefchange"/>
    <xs:attributeGroup ref="att.vis.clefchange"/>
    <xs:attributeGroup ref="att.anl.clefchange"/>
  </xs:attributeGroup>
  <!--
    doc: Used to create additional visual space between notational
    elements. 
    Used by: model.eventLike.common 
    Module:  meiShared
  -->
  <xs:element name="pad" substitutionGroup="model.eventLike.common">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.pad"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pad">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.log.pad"/>
  </xs:attributeGroup>
  <!--
    doc: A placeholder used to fill an incomplete measure, layer, etc.
    most often so that the combined duration of the events equals the number
    of beats in the measure. 
    Used by: model.eventLike.common 
    Module:  meiShared
  -->
  <xs:element name="space" substitutionGroup="model.eventLike.common">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.space"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.space">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.space"/>
    <xs:attributeGroup ref="att.vis.space"/>
    <xs:attributeGroup ref="att.ges.space"/>
    <xs:attributeGroup ref="att.anl.space"/>
  </xs:attributeGroup>
  <!--
    doc: Directives, e.g. text expressions that are on the score (typically
    above, below, or between staves), but not on the staff and not encoded
    elsewhere, such as in tempo or dynam elements. Examples include text
    strings, such as 'affettuoso' or fingerings and music symbols, such as
    segno and coda symbols, fermatas over a barline, etc. Unlike generic
    text elements, directives can be control elements. That is, they can be
    used as pointers to other events. The %model.textphraseLike.limited
    entity is employed here instead of %model.textphrase in order to
    disallow use of the pb sub-element. 
    Used by: model.controleventLike.common 
    Module:  meiShared
  -->
  <xs:complexType name="content.dir" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="dir" substitutionGroup="model.controleventLike.common">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.dir">
          <xs:attributeGroup ref="attlist.dir"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.dir">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.log.dir"/>
    <xs:attributeGroup ref="att.vis.dir"/>
    <xs:attributeGroup ref="att.ges.dir"/>
    <xs:attributeGroup ref="att.anl.dir"/>
  </xs:attributeGroup>
  <!--
    doc: The dynam element may be used for instantaneous or continuous
    textual dynamics, e.g. 'p', 'mf', or 'cresc. poco a poco'. See Read, p.
    250-255. The hairpin element should be used for graphical dynamic
    markings. The %model.textphraseLike.limited entity is employed here
    instead of %model.textphrase in order to disallow use of the pb
    sub-element. 
    Used by: model.controleventLike.common 
    Module:  meiShared
  -->
  <xs:complexType name="content.dynam" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="dynam" substitutionGroup="model.controleventLike.common">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.dynam">
          <xs:attributeGroup ref="attlist.dynam"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.dynam">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.dynam"/>
    <xs:attributeGroup ref="att.vis.dynam"/>
    <xs:attributeGroup ref="att.ges.dynam"/>
    <xs:attributeGroup ref="att.anl.dynam"/>
  </xs:attributeGroup>
  <!--
    doc: Phrase mark, used for a "unified melodic idea" (Read, p. 265). 
    Used by: model.controleventLike.common 
    Module:  meiShared
  -->
  <xs:element name="phrase" substitutionGroup="model.controleventLike.common">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.phrase"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.phrase">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.phrase"/>
    <xs:attributeGroup ref="att.vis.phrase"/>
    <xs:attributeGroup ref="att.anl.phrase"/>
  </xs:attributeGroup>
  <!--
    doc: Text and symbols descriptive of tempo, mood, or style, e.g.,
    "allarg.", "a tempo", "cantabile", "Moderato", "[qtrnote]=60", "Moderato
    [qtrnote] =60"). Both "instantaneous" and "continuous" tempo markings
    may be encoded using this element. The %model.textphraseLike.limited
    entity is employed here instead of %model.textphrase in order to
    disallow the use of the pb sub-element. 
    Used by: model.controleventLike.common 
    Module:  meiShared
  -->
  <xs:complexType name="content.tempo" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="tempo" substitutionGroup="model.controleventLike.common">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.tempo">
          <xs:attributeGroup ref="attlist.tempo"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.tempo">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.log.tempo"/>
    <xs:attributeGroup ref="att.vis.tempo"/>
    <xs:attributeGroup ref="att.ges.tempo"/>
    <xs:attributeGroup ref="att.anl.tempo"/>
  </xs:attributeGroup>
  <!-- Neume and mensural: -->
  <!--
    doc: The mensur element is provided for the encoding of mensural
    notation.
    Used by: model.staffdefPart.multiplyDefinable 
    Module:  meiShared
  -->
  <xs:element name="mensur" substitutionGroup="model.staffdefPart.multiplyDefinable">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.mensur"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mensur">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mensur"/>
    <xs:attributeGroup ref="att.vis.mensur"/>
    <xs:attributeGroup ref="att.anl.mensur"/>
  </xs:attributeGroup>
  <!--
    doc: Proportion.
    Used by: model.staffdefPart.multiplyDefinable 
    Module:  meiShared
  -->
  <xs:element name="proport" substitutionGroup="model.staffdefPart.multiplyDefinable">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.proport"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.proport">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.proport"/>
    <xs:attributeGroup ref="att.anl.proport"/>
  </xs:attributeGroup>
  <!--
    doc: The ligature element is provided for the encoding of mensural
    notation.
    Used by: model.eventLike.neume-mensural 
    Module:  meiShared
  -->
  <xs:complexType name="content.ligature">
    <xs:choice>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.eventLike"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="accid"/>
        <xs:element ref="artic"/>
        <xs:element ref="model.verseLike"/>
      </xs:choice>
    </xs:choice>
  </xs:complexType>
  <xs:element name="ligature" substitutionGroup="model.eventLike.neume-mensural">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ligature">
          <xs:attributeGroup ref="attlist.ligature"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.ligature">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.ligature"/>
    <xs:attributeGroup ref="att.anl.ligature"/>
  </xs:attributeGroup>
  <!--
    doc: Mensuration change.
    Used by: model.eventLike.neume-mensural 
    Module:  meiShared
  -->
  <xs:complexType name="content.mensurchange">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="mensur"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="mensurchange" substitutionGroup="model.eventLike.neume-mensural">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.mensurchange">
          <xs:attributeGroup ref="attlist.mensurchange"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mensurchange">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
  </xs:attributeGroup>
  <!--
    doc: Proportion change.
    Used by: model.eventLike.neume-mensural 
    Module:  meiShared
  -->
  <xs:complexType name="content.proportchange">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="proport"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="proportchange" substitutionGroup="model.eventLike.neume-mensural">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.proportchange">
          <xs:attributeGroup ref="attlist.proportchange"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.proportchange">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
  </xs:attributeGroup>
  <!-- Neume and CMN: -->
  <!--
    doc: Articulation. This element provides an alternative to the artic
    attributes on the note and chord elements. The element should be used
    when when specific display info, such as size or color, needs to be
    recorded for the articulation. 
    Used by: model.noteModifierLike model.notaModifierLike model.neumeModifierLike 
    Module:  meiShared
  -->
  <xs:element name="artic" substitutionGroup="model.noteModifierLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.artic"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.artic">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typography"/>
    <xs:attributeGroup ref="att.log.artic"/>
    <xs:attributeGroup ref="att.vis.artic"/>
    <xs:attributeGroup ref="att.anl.artic"/>
  </xs:attributeGroup>
  <!--
    doc: Accidental in a key signature.  It is a semantic error not
    to provide x and y or staffloc attributes. 
    Used by: model.keyaccidLike 
    Module:  meiShared
  -->
  <xs:element name="keyaccid" substitutionGroup="model.keyaccidLike"/>
  <xs:attributeGroup name="attlist.keyaccid">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="enclose" type="data.ENCLOSURE"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="implicit"/>
          <xs:enumeration value="explicit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="oct" type="data.OCTAVE"/>
    <xs:attribute name="pname" use="required" type="data.PITCHNAME"/>
    <xs:attribute name="staffloc" type="data.STAFFLOC"/>
    <xs:attribute name="value" use="required" type="data.ACCIDENTAL.EXPLICIT"/>
  </xs:attributeGroup>
  <!--
    doc: Key signature.  This element may be used as an alternative to the
    key.* attributes (especially key.sig.mixed) on scoredef and staffdef. 
    Used by: model.keysigLike 
    Module:  meiShared
  -->
  <xs:complexType name="content.keysig">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.keyaccidLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="keysig" substitutionGroup="model.keysigLike"/>
  <xs:attributeGroup name="attlist.keysig">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attribute name="accid" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="mode" type="data.MODE"/>
    <xs:attribute name="pname" type="data.PITCHNAME"/>
  </xs:attributeGroup>
  <!--
    doc: Accidental. This element provides an alternative to the acci
    attributes on the note element. The element should be used when
    specific display info, such as size or color, needs to be recorded
    for the accidental. The func attribute can be used to differentiate
    different functions, such as 'cautionary' or 'editorial'. 
    Used by: model.noteModifierLike model.notaModifierLike model.neumeModifierLike model.eventLike.mensural-cmn 
    Module:  meiShared
  -->
  <xs:element name="accid" substitutionGroup="model.noteModifierLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.accid"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.accid">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typography"/>
    <xs:attributeGroup ref="att.log.accid"/>
    <xs:attributeGroup ref="att.vis.accid"/>
    <xs:attributeGroup ref="att.anl.accid"/>
  </xs:attributeGroup>
  <!--
    doc: The barline element may be used instead of the measure element.
    It has the same attributes as measure.
    Used by: model.eventLike.mensural-cmn 
    Module:  meiShared
  -->
  <xs:element name="barline" substitutionGroup="model.eventLike.mensural-cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.barline"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.barline">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.log.barline"/>
    <xs:attributeGroup ref="att.vis.barline"/>
    <xs:attributeGroup ref="att.ges.barline"/>
    <xs:attributeGroup ref="att.anl.barline"/>
  </xs:attributeGroup>
  <!--
    doc: The dot element is provided for the encoding of mensural
    notation. The dot element may be used for dots of augmentation
    or division. 
    Used by: model.eventLike.mensural-cmn 
    Module:  meiShared
  -->
  <xs:element name="dot" substitutionGroup="model.noteModifierLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.dot"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.dot">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.dot"/>
    <xs:attributeGroup ref="att.vis.dot"/>
    <xs:attributeGroup ref="att.anl.dot"/>
  </xs:attributeGroup>
  <!--
    doc: Key change.
    Used by: model.eventLike.mensural-cmn 
    Module:  meiShared
  -->
  <xs:complexType name="content.keychange">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.keyaccidLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="keychange" substitutionGroup="model.eventLike.mensural-cmn">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.keychange">
          <xs:attributeGroup ref="attlist.keychange"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.keychange">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
  </xs:attributeGroup>
  <!-- Text Components -->
  <!--
    doc: Back matter such as indexes, advertisements, etc. 
    Used by: music 
    Module:  meiText
  -->
  <xs:complexType name="content.back">
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
      <xs:element maxOccurs="unbounded" ref="model.divLike"/>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="back" substitutionGroup="model.backLike"/>
  <xs:attributeGroup name="attlist.back">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Blockquote contains a text phrase or passage attributed to a
    source external to the text. The source for the quote may be included
    in the optional bibl sub-element. 
    Used by: model.textcomponentLike model.paracontentPart 
    Module:  meiText
  -->
  <xs:complexType name="content.blockquote">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.textcomponentLike"/>
      <xs:element minOccurs="0" ref="model.biblLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="blockquote" substitutionGroup="model.quoteLike"/>
  <xs:attributeGroup name="attlist.blockquote">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!--
    doc: Textual division. 
    Used by: model.divLike 
    Module:  meiText
  -->
  <xs:complexType name="content.div">
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
      <xs:element minOccurs="0" ref="model.headLike"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="model.divLike"/>
        <xs:element ref="model.textcomponentLike"/>
      </xs:choice>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="div" substitutionGroup="model.divLike"/>
  <xs:attributeGroup name="attlist.div">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Front matter. The pb element is allowed here in order to
    accommodate page images, e.g. cover, endpapers, etc. before and after
    the actual textual matter. 
    Used by: music 
    Module:  meiText
  -->
  <xs:complexType name="content.front">
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="model.divLike"/>
        <xs:element ref="model.frontPart"/>
      </xs:choice>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.milestoneLike.text"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="front" substitutionGroup="model.frontLike"/>
  <xs:attributeGroup name="attlist.front">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Contains any heading, for example, the title of a text division,
    or the heading of a list. A head is not allowed to contain a sub-head
    in order to encourage the proper nesting of div elements. 
    Used by: model.headLike 
    Module:  meiText
  -->
  <xs:complexType name="content.head" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="head" substitutionGroup="model.headLike"/>
  <xs:attributeGroup name="attlist.head">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!--
    doc: Single item in a list 
    Used by: list 
    Module:  meiText
  -->
  <xs:complexType name="content.item" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="item">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.item">
          <xs:attributeGroup ref="attlist.item"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.item">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
  </xs:attributeGroup>
  <!--
    doc: Line contains a single line of text. The n attribute should
    be used to record a label for the line, i.e. most likely a line
    number. 
    Used by: model.lLike 
    Module:  meiText
  -->
  <xs:complexType name="content.l" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="l" substitutionGroup="model.lLike"/>
  <xs:attributeGroup name="attlist.l">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Line group usually contains verse although it may be used for
    any section of text that is organized as a group of lines. 
    Used by: model.textcomponentLike 
    Module:  meiText
  -->
  <xs:complexType name="content.lg">
    <xs:sequence>
      <xs:element minOccurs="0" ref="model.headLike"/>
      <xs:element maxOccurs="unbounded" ref="model.lLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="lg" substitutionGroup="model.lgLike"/>
  <xs:attributeGroup name="attlist.lg">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!--
    doc: List. N.B. A definition list should be encoded as a 2-column
    table. 
    Used by: model.listLike 
    Module:  meiText
  -->
  <xs:complexType name="content.list">
    <xs:sequence>
      <xs:element minOccurs="0" ref="model.headLike"/>
      <xs:element maxOccurs="unbounded" ref="item"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="list" substitutionGroup="model.listLike"/>
  <xs:attributeGroup name="attlist.list">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="form">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="simple"/>
          <xs:enumeration value="marked"/>
          <xs:enumeration value="ordered"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Visual layout in tabular form 
    Used by: model.tableLike 
    Module:  meiText
  -->
  <xs:complexType name="content.table">
    <xs:sequence>
      <xs:element minOccurs="0" ref="model.captionLike"/>
      <xs:element maxOccurs="unbounded" ref="tr"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="table" substitutionGroup="model.tableLike"/>
  <xs:attributeGroup name="attlist.table">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!--
    doc: Table cell containing data 
    Used by: tr 
    Module:  meiText
  -->
  <xs:complexType name="content.td" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="td">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.td">
          <xs:attributeGroup ref="attlist.td"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.td">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="colspan" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="rowspan" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Table cell containing header information 
    Used by: table 
    Module:  meiText
  -->
  <xs:complexType name="content.th" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="th">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.th">
          <xs:attributeGroup ref="attlist.th"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.th">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
    <xs:attribute name="colspan" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="rowspan" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Table row 
    Used by: table 
    Module:  meiText
  -->
  <xs:complexType name="content.tr">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="th"/>
      <xs:element ref="td"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="tr">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.tr">
          <xs:attributeGroup ref="attlist.tr"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.tr">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!-- Additional Names and Dates -->
  <!--
    doc: Identifies an organization or group of people that acts as an
    entity. May contain name parts in corpname sub-elements since corpname
    is included in model.textphraseLike. 
    Used by: model.nameLike.agent 
    Module:  meiNamesDates
  -->
  <xs:complexType name="content.corpname" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="corpname" substitutionGroup="model.nameLike.agent">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.corpname">
          <xs:attributeGroup ref="attlist.corpname"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.corpname">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="role"/>
  </xs:attributeGroup>
  <!--
    doc: Geographic name. The proper noun designation for a place, natural
    feature, or political jurisdiction. May contain name sub-parts in
    geogname sub-elements since geogname is included in model.textphrase. 
    Used by: model.nameLike.place model.pubstmtPart 
    Module:  meiNamesDates
  -->
  <xs:complexType name="content.geogname" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="geogname" substitutionGroup="model.nameLike.geogname"/>
  <xs:attributeGroup name="attlist.geogname">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: A label for a period of time, such as 'Baroque' or '3rd Style
    period'. 
    Used by: model.nameLike.label 
    Module:  meiNamesDates
  -->
  <xs:complexType name="content.periodname" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="periodname" substitutionGroup="model.nameLike.label">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.periodname">
          <xs:attributeGroup ref="attlist.periodname"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.periodname">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Designation for an individual, including any or all of that
    individual's forenames, surnames, honorific titles, and added names. May
    contain name parts in persname sub-elements since persname is included
    in model.textphrase. 
    Used by: model.nameLike.agent 
    Module:  meiNamesDates
  -->
  <xs:complexType name="content.persname" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="persname" substitutionGroup="model.nameLike.agent">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.persname">
          <xs:attributeGroup ref="attlist.persname"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.persname">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="role"/>
  </xs:attributeGroup>
  <!--
    doc: A label for a characteristic style of writing or performance,
    such as 'bebop' or 'rock-n-roll'. May be used independently of
    periodname. 
    Used by: model.nameLike.label 
    Module:  meiShared
  -->
  <xs:complexType name="content.stylename" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="stylename" substitutionGroup="model.nameLike.label">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.stylename">
          <xs:attributeGroup ref="attlist.stylename"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.stylename">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.name"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!-- Figures -->
  <!--
    doc: A label which accompanies an illustration or a table. 
    Used by: figure 
    Module:  meiFigures
  -->
  <xs:complexType name="content.caption" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="caption" substitutionGroup="model.captionLike"/>
  <xs:attributeGroup name="attlist.caption">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: An illustration. 
    Used by: model.figureLike 
    Module:  meiFigures
  -->
  <xs:complexType name="content.fig">
    <xs:sequence>
      <xs:element minOccurs="0" ref="caption"/>
      <xs:element minOccurs="0" ref="figdesc"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.graphicLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="fig" substitutionGroup="model.figureLike"/>
  <xs:attributeGroup name="attlist.fig">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.xy"/>
  </xs:attributeGroup>
  <!-- Pointers and References -->
  <!--
    doc: An empty linking element that uses attributes to connect the MEI
    document to an external electronic object. Don't confuse this element
    with the ptr element, which is an internal link for movement from one
    place in the MEI document to another in the same document. 
    Used by: model.locrefLike 
    Module:  meiPtrRefs
  -->
  <xs:element name="extptr">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.extptr"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.extptr">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
  </xs:attributeGroup>
  <!--
    doc: A linking element that can include text and subelements as part of
    its reference to an electronic object that is external to the MEI
    document. Don't confuse this element with the ref element, which is an
    internal link for movement from one place in the MEI document to another
    in the same document. 
    Used by: model.locrefLike 
    Module:  meiPtrRefs
  -->
  <xs:complexType name="content.extref" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike"/>
  </xs:complexType>
  <xs:element name="extref">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.extref">
          <xs:attributeGroup ref="attlist.extref"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.extref">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
  </xs:attributeGroup>
  <!--
    doc: An empty internal linking element that uses attributes to provide
    for movement from one place in a MEI document to another place in the
    same document. Unlike the ref element, the ptr element cannot contain
    text or subelements to describe the referenced object. Don't confuse
    this element with extptr which is used to connect the MEI document to
    an external electronic object. 
    Used by: model.locrefLike 
    Module:  meiPtrRefs
  -->
  <xs:element name="ptr">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.ptr"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.ptr">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.internal"/>
  </xs:attributeGroup>
  <!--
    doc: An internal linking element that provides for movement from one
    place in a MEI document to another point in the same document. Unlike
    the ptr element, ref may contain text and subelements to describe the
    destination. Don't confuse this element with extref which provides for
    linking to an electronic object that is external to the MEI document. 
    Used by: model.locrefLike 
    Module:  meiPtrRefs
  -->
  <xs:complexType name="content.ref" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike"/>
  </xs:complexType>
  <xs:element name="ref">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ref">
          <xs:attributeGroup ref="attlist.ref"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.ref">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.internal"/>
  </xs:attributeGroup>
  <!-- Default Structure -->
  <!--
    doc: The body element contains the actual music data. When the
    music can be broken into high-level, discrete, linear segments, such
    as movements in the case of a symphony, there may be multiple mdiv
    elements within the body. This is the highest level indication of
    the structure of the music. The model &lt;!ELEMENT %n.body; (%n.mdiv;)*>
    allows the body element to be empty, which might be useful in some
    editing/creation situations. 
    Used by: music 
    Module:  meiStructure
  -->
  <xs:complexType name="content.body">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.mdivLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="body">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.body">
          <xs:attributeGroup ref="attlist.body"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.body">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Alternative ending. The scoredef element is allowed so that an
    ending may have its own meta-data without the overhead of child
    &lt;section>s. Div sub-elements are not allowed within ending in order to
    avoid collisions with the brackets that are usually displayed over
    endings. Endings may *not* contain endings. 
    Used by: model.endingLike ending 
    Module:  meiStructure
  -->
  <xs:complexType name="content.ending">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.scorecomponentLike"/>
  </xs:complexType>
  <xs:element name="ending" substitutionGroup="model.endingLike"/>
  <xs:attributeGroup name="attlist.ending">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.anl.ending"/>
  </xs:attributeGroup>
  <!--
    doc: The group element enables the gathering of multiple documents
    into a single file. Because its model contains the music element,
    each of the documents can have its own front and back matter. 
    Used by: music group 
    Module:  meiStructure
  -->
  <xs:complexType name="content.group">
    <xs:sequence>
      <xs:choice>
        <xs:element ref="music"/>
        <xs:element ref="group"/>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="music"/>
        <xs:element ref="group"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="group">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.group">
          <xs:attributeGroup ref="attlist.group"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.group">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Group symbol, i.e., a brace or bracket.  This element may be used
    instead of the staffgrp element's symbol attribute when exact
    placement or editorial details for the brace must be recorded. 
    Used by: staffgrp 
    Module:  meiStructure
  -->
  <xs:complexType name="content.grpsym">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.labelLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="grpsym">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.grpsym">
          <xs:attributeGroup ref="attlist.grpsym"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.grpsym">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.grpsym"/>
    <xs:attributeGroup ref="att.vis.grpsym"/>
    <xs:attributeGroup ref="att.anl.grpsym"/>
  </xs:attributeGroup>
  <!--
    doc: Default MIDI instrument declaration. This element provides a
    starting or default instrument declaration for a staff, a group of
    staves, or a layer. MIDI prog elements may then change the instrument
    as necessary. 
    Used by: instrdefLike 
    Module:  meiStructure
  -->
  <xs:element name="instrdef" substitutionGroup="model.instrdefLike"/>
  <xs:attributeGroup name="attlist.instrdef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="midi.channel" type="data.MIDICHANNEL"/>
    <xs:attribute name="midi.duty" type="data.PERCENT"/>
    <xs:attribute name="midi.instr" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.instrname"/>
    <xs:attribute name="midi.port" type="data.MIDIVALUE"/>
    <xs:attribute name="midi.track" type="data.INTEGERPOSITIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Staff, staffgrp, or grpsym label 
    Used by: model.labelLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.label" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="label" substitutionGroup="model.labelLike"/>
  <xs:attributeGroup name="attlist.label">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attribute name="source" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Layer (voice). The n attribute should be used to establish a
    connection back to the appropriate layerdef element.  Usually, the
    topmost layer is "1", next is "2", etc. *regardless of voicing*). If
    the n attribute is omitted, encoding order is presumed to match the
    layer order. Of course, if data is supplied for only a subset of
    layers, the n attribute must be supplied. 
    Used by: model.layerLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.layer">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.layerPart"/>
      <xs:element ref="model.annotLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="layer" substitutionGroup="model.layerLike"/>
  <xs:attributeGroup name="attlist.layer">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.vis.layer"/>
    <xs:attributeGroup ref="att.anl.layer"/>
  </xs:attributeGroup>
  <!--
    doc: Container for layer (e.g. voice) meta-information. 
    Used by: layerdefLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.layerdef">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.instrdefLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="layerdef" substitutionGroup="model.layerdefLike"/>
  <xs:attributeGroup name="attlist.layerdef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.log.layerdef"/>
    <xs:attributeGroup ref="att.vis.layerdef"/>
    <xs:attributeGroup ref="att.ges.layerdef"/>
  </xs:attributeGroup>
  <!--
    doc: The mdiv element may contain one or both of 2 possible views of the
    music. The score view is the traditional full and open score while the
    parts view contains each performer's view of the score; that is, his
    part. These 2 views are necessary because it is not always possible or
    desirable to generate one from the other. The score and parts elements
    are placed here and not directly within the body element because score
    and part characteristics may change from mdiv to mdiv. For example, the
    2nd movement of a symphony may require different performing forces (and
    therefore different score and part layout) than the other movements.
    Another possible model is &lt;!ELEMENT mdiv (score?, parts?, sourcedesc*)>
    which allows meta-data to accompany an mdiv. However, this creates a
    dependency between the meiBase DTD and the meiHead DTD. The mdiv may be
    recursively nested in order to represent music which exhibits this kind
    of structure.  For example, an opera is normally divided into acts,
    which are in turn divided into scenes. This may be represented by the
    following markup:
      &lt;mdiv> &lt;- the opera
        &lt;mdiv> &lt;- act I
          &lt;mdiv> &lt;- scene i
          &lt;mdiv> &lt;- scene ii
        &lt;/mdiv>
        &lt;mdiv> &lt;- act II
          &lt;mdiv> &lt;- scene i
          &lt;mdiv> &lt;- scene ii
        &lt;/mdiv>
      &lt;/mdiv>
    
    Used by: body mdiv 
    Module:  meiStructure
  -->
  <xs:complexType name="content.mdiv">
    <xs:choice>
      <xs:sequence>
        <xs:element minOccurs="0" ref="model.scoreLike"/>
        <xs:element minOccurs="0" ref="model.partsLike"/>
      </xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.mdivLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="mdiv" substitutionGroup="model.mdivLike"/>
  <xs:attributeGroup name="attlist.mdiv">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: A part is an alternative visual rendition of the score from a
    particular performer's point of view. Part elements are not used in the
    score to indicate voice leading. Next attributes on event elements
    should be used for this purpose. Part elements are useful for encoding
    individual parts when there is no score, such as early music part books,
    when the music has non-aligning barlines, when different layout, such as
    page turns, are needed for the score and parts, or for accommodating
    software that requires part-by-part encoding. When assembly of the parts
    into a score is desired and there are non-aligning barlines, barlines which
    indicate points of alignment across all the parts should be marked as
    'controlling', while non-aligning ones should be marked as 'non-
    controlling'. 
    Used by: model.partLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.part">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.scorecomponentLike"/>
  </xs:complexType>
  <xs:element name="part" substitutionGroup="model.partLike"/>
  <xs:attributeGroup name="attlist.part">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.anl.part"/>
  </xs:attributeGroup>
  <!--
    doc: Parts view of the mdiv. 
    Used by: partsLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.parts">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.partLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="parts" substitutionGroup="model.partsLike"/>
  <xs:attributeGroup name="attlist.parts">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.anl.parts"/>
  </xs:attributeGroup>
  <!--
    doc: A running footer on the first page. This element is a specialized
    form of the fw element. Auto-generated page numbers may be indicated with
    a processing instruction. The pgheadN and pgfootN elements should *not* be
    used to encode textual notes! 
    Used by: model.pgmetaLike.score 
    Module:  meiStructure
  -->
  <xs:complexType name="content.pgfoot1" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pgfoot1">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pgfoot1">
          <xs:attributeGroup ref="attlist.pgfoot1"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pgfoot1">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: A running header on the pages following the first. This element
    is a specialized form of the fw element. Auto-generated page numbers may
    be indicated with a processing instruction. The pgheadN and pgfootN
    elements should *not* be used to encode textual notes! 
    Used by: model.pgmetaLike.score 
    Module:  meiStructure
  -->
  <xs:complexType name="content.pgfoot2" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pgfoot2">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pgfoot2">
          <xs:attributeGroup ref="attlist.pgfoot2"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pgfoot2">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: A running header on the first page. This element is a specialized
    form of the fw element for capturing the table-formatted textual data
    that often appears on the first page of printed music. It may also be
    used for similarly formatted material in manuscripts. The pgheadN and
    pgfootN elements should *not* be used to encode textual notes!  Auto-
    generated page numbers may be indicated with a processing instruction. 
    Used by: model.pgmetaLike.score 
    Module:  meiStructure
  -->
  <xs:complexType name="content.pghead1" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pghead1">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pghead1">
          <xs:attributeGroup ref="attlist.pghead1"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pghead1">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: A running header on the pages following the first. This element is
    a specialized form of the fw element. The pgheadN and pgfootN elements
    should *not* be used to encode textual notes! Auto-generated page
    numbers may be indicated with a processing instruction. 
    Used by: model.pgmetaLike.score 
    Module:  meiStructure
  -->
  <xs:complexType name="content.pghead2" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pghead2">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pghead2">
          <xs:attributeGroup ref="attlist.pghead2"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pghead2">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: System break. Allowing staffdef content, i.e.,  <!ENTITY % content.sb ''>
    <!ELEMENT %n.sb;
    (staffdef)*>, here would make it possible to record layout changes
    without requiring these changes to be made at section boundaries.
    However, it would also allow meter and key changes, which is probably
    undesirable. 
    Used by: model.milestoneLike.music 
    Module:  meiStructure
  -->
  <xs:complexType name="content.sb">
    <xs:sequence>
      <xs:element minOccurs="0" ref="custos"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="sb" substitutionGroup="model.milestoneLike.music">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.sb">
          <xs:attributeGroup ref="attlist.sb"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.sb">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.sb"/>
    <xs:attributeGroup ref="att.vis.sb"/>
    <xs:attributeGroup ref="att.anl.sb"/>
  </xs:attributeGroup>
  <!--
    doc: Full score view of the mdiv. Since the measure element is optional,
    a score may consist entirely of pagebreaks, each of which points to a page
    image. Div elements are allowed preceding and following sections of music
    data in order to accommodate blocks of explanatory text. 
    Used by: model.scoreLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.score">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.scorecomponentLike"/>
  </xs:complexType>
  <xs:element name="score" substitutionGroup="model.scoreLike"/>
  <xs:attributeGroup name="attlist.score">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.anl.score"/>
  </xs:attributeGroup>
  <!--
    doc: Container for score meta-information. 
    Used by: model.scoredefLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.scoredef">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.alignLike"/>
      <xs:element minOccurs="0" ref="model.chordtableLike"/>
      <xs:element minOccurs="0" ref="model.symboltableLike"/>
      <xs:element minOccurs="0" ref="model.keysigLike"/>
      <xs:group ref="model.pgmetaLike.score"/>
      <xs:choice>
        <xs:element minOccurs="0" ref="model.staffgrpLike"/>
        <xs:element minOccurs="0" ref="model.staffdefLike"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="scoredef" substitutionGroup="model.scoredefLike"/>
  <xs:attributeGroup name="attlist.scoredef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.log.scoredef"/>
    <xs:attributeGroup ref="att.vis.scoredef"/>
    <xs:attributeGroup ref="att.ges.scoredef"/>
  </xs:attributeGroup>
  <!--
    doc: The section element contains actual music data. The linking
    attributes are available here so that this element can point to external
    media objects or to related internal elements, such as annotations. 
    Used by: model.rdgPart section 
    Module:  meiStructure
  -->
  <xs:complexType name="content.section">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.scorecomponentLike"/>
  </xs:complexType>
  <xs:element name="section" substitutionGroup="model.sectionLike"/>
  <xs:attributeGroup name="attlist.section">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.ges.section"/>
    <xs:attributeGroup ref="att.anl.section"/>
  </xs:attributeGroup>
  <!--
    doc: Staff. The n attribute is a connection back to the appropriate
    staffdef element. If the n attribute is omitted, encoding order is
    presumed to match the staff order.  Of course, if data is supplied
    for only a subset of staves, the n attribute must be supplied. 
    Used by: model.staffLike 
    Module:  meiStructure
  -->
  <xs:complexType name="content.staff">
    <xs:complexContent>
      <xs:extension base="model.staffPart"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="staff" substitutionGroup="model.staffLike"/>
  <xs:attributeGroup name="attlist.staff">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.vis.staff"/>
    <xs:attributeGroup ref="att.anl.staff"/>
  </xs:attributeGroup>
  <!--
    doc: Container for staff meta-information. 
    Used by: model.rdgPart 
    Module:  meiStructure
  -->
  <xs:complexType name="content.staffdef">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.labelLike"/>
      <xs:element minOccurs="0" ref="model.keysigLike"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.instrdefLike"/>
        <xs:element ref="model.layerdefLike"/>
        <xs:element ref="model.staffdefPart.multiplyDefinable"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="staffdef" substitutionGroup="model.staffdefLike"/>
  <xs:attributeGroup name="attlist.staffdef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.log.staffdef"/>
    <xs:attributeGroup ref="att.vis.staffdef"/>
    <xs:attributeGroup ref="att.ges.staffdef"/>
  </xs:attributeGroup>
  <!--
    doc: A group of staves. Bracketed staff groups may contain other
    bracketed or braced staff groups or single staves. See Read, p. 35-38,
    examples p. 434, 438. System is the more proper name for this concept
    (Read, p. 37-38). Split staffgrp into bracket and brace elements? 
    Used by: staffgrpLike staffgrp 
    Module:  meiStructure
  -->
  <xs:complexType name="content.staffgrp">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.labelLike"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.instrdefLike"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="model.staffgrpLike"/>
        <xs:element ref="model.staffdefLike"/>
      </xs:choice>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="grpsym"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="staffgrp" substitutionGroup="model.staffgrpLike"/>
  <xs:attributeGroup name="attlist.staffgrp">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.vis.staffgrp"/>
    <xs:attributeGroup ref="att.ges.staffgrp"/>
  </xs:attributeGroup>
  <!-- Neumes -->
  <!--
    doc: The syllable element is used only for neume notation.  Most neume
    notation can be thought of as "neumed text". 
    Used by: model.eventLike.neume 
    Module:  meiNeumes
  -->
  <xs:complexType name="content.syllable">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:choice>
        <xs:group ref="model.eventLike"/>
        <xs:element ref="model.sylLike"/>
        <xs:element ref="model.apparatusLike"/>
        <xs:element ref="model.editLike"/>
        <xs:element ref="model.transcriptionLike"/>
      </xs:choice>
      <xs:element minOccurs="0" ref="model.milestoneLike.music"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="syllable" substitutionGroup="model.eventLike.neume">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.syllable">
          <xs:attributeGroup ref="attlist.syllable"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.syllable">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: The interrupted neume element is provided for the encoding of neume
    notation.
    Used by: model.eventLike.neume 
    Module:  meiNeumes
  -->
  <xs:complexType name="content.ineume">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.eventLike"/>
      <xs:group ref="model.neumeModifierLike"/>
      <xs:element ref="model.apparatusLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="ineume" substitutionGroup="model.eventLike.neume">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ineume">
          <xs:attributeGroup ref="attlist.ineume"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.ineume">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.log.ineume"/>
    <xs:attributeGroup ref="att.vis.ineume"/>
    <xs:attributeGroup ref="att.anl.ineume"/>
  </xs:attributeGroup>
  <!--
    doc: A single, uninterrupted neume sign. While ineume is allowed here as
    part of the model.events class, it is unlikely that an uninterrupted neume
    containing an interrupted neume is a meaningful construct. 
    Used by: model.eventLike.neume 
    Module:  meiNeumes
  -->
  <xs:complexType name="content.uneume">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.eventLike"/>
      <xs:group ref="model.neumeModifierLike"/>
      <xs:element ref="model.apparatusLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="uneume" substitutionGroup="model.eventLike.neume">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.uneume">
          <xs:attributeGroup ref="attlist.uneume"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.uneume">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.log.uneume"/>
    <xs:attributeGroup ref="att.vis.uneume"/>
    <xs:attributeGroup ref="att.anl.uneume"/>
  </xs:attributeGroup>
  <!-- Mensural -->
  <!--
    doc: A single pitched event in the mensural repertoire. The nota element
    is allowed to contain other events for situations where a single written
    note may be representative of a group of performed notes. The accid and
    artic sub-elements may be used instead of the note element's attributes
    when accid and artic represent first-class objects, e.g. when they
    require attributes, such as x and y location attributes. Similarly, the
    syl sub-element may be used instead of the syl attribute. The verse
    sub-element may be used to group text syllables by verse.
    Used by: model.eventLike.mensural 
    Module:  meiMensural
  -->
  <xs:complexType name="content.nota">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.noteModifierLike"/>
      <xs:element ref="model.sylLike"/>
      <xs:element ref="model.verseLike"/>
      <xs:element ref="model.apparatusLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="nota" substitutionGroup="model.eventLike.mensural">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.nota">
          <xs:attributeGroup ref="attlist.nota"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.nota">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.nota"/>
    <xs:attributeGroup ref="att.vis.nota"/>
    <xs:attributeGroup ref="att.ges.nota"/>
    <xs:attributeGroup ref="att.anl.nota"/>
  </xs:attributeGroup>
  <!--
    doc: A rest in the mensural repertoire.
    Used by: model.eventLike.mensural 
    Module:  meiMensural
  -->
  <xs:element name="pausa" substitutionGroup="model.eventLike.mensural">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.pausa"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pausa">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.pausa"/>
    <xs:attributeGroup ref="att.vis.pausa"/>
    <xs:attributeGroup ref="att.ges.pausa"/>
    <xs:attributeGroup ref="att.anl.pausa"/>
  </xs:attributeGroup>
  <!-- CMN -->
  <!--
    doc: Measure. "In Western notation a vertical line drawn through the
    staff to mark off metrical units. Hence also the metrical unit thus
    indicated, which in American usage is called 'measure'. English usage
    often relies on context alone to make the distinction clear (e.g. 'up to
    the double bar', 'the end of the bar'), but 'bar-line' is also common."
    (New Grove) In MEI, the measure element is also a linking element that
    uses attributes to connect the MEI document to an external electronic
    object or to another location within the MEI instance. Any number of
    alternative encodings for the measure (ossia) can be included. 
    Used by: model.measureLike 
    Module:  meiCMN
  -->
  <xs:complexType name="content.measure">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element minOccurs="0" ref="model.staffdefLike"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.measurePart"/>
        <xs:element ref="model.ossiaLike"/>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.controleventLike"/>
        <xs:element ref="model.lyricsLike"/>
        <xs:element ref="model.midiLike"/>
        <xs:element ref="model.annotLike"/>
        <xs:element ref="model.graphicprimitiveLike"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <!--
    <!ENTITY % content.measure '
    (
      (%model.staffdefLike;)?,
      (%model.measurePart;|%model.ossiaLike;|%model.staffdefLike;)*,
      (%model.controleventLike;|%model.lyricsLike;|%model.midiLike;|
      %model.annotLike;|%model.graphicprimitiveLike;|%model.apparatusLike;|
      %model.editLike;|%model.transcriptionLike;)*
    )'>
  -->
  <xs:element name="measure" substitutionGroup="model.measureLike"/>
  <xs:attributeGroup name="attlist.measure">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.log.measure"/>
    <xs:attributeGroup ref="att.vis.measure"/>
    <xs:attributeGroup ref="att.anl.measure"/>
  </xs:attributeGroup>
  <!--
    doc: The term "ossia" indicates an alternative, usually simpler, version
    of a measure *present in the source being transcribed*. An ossia may be
    treated as a substitute for the measure, in which case it is rendered on
    the current staff, or it may be rendered in addition to the measure's
    contents, in which case it is rendered above the staff on a reduced-size
    staff. 
    Used by: model.ossiaLike 
    Module:  meiCMN
  -->
  <xs:complexType name="content.ossia">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element minOccurs="0" ref="model.staffdefLike"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.measurePart"/>
        <xs:element ref="model.ossiaLike"/>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="model.controleventLike"/>
        <xs:element ref="model.lyricsLike"/>
        <xs:element ref="model.midiLike"/>
        <xs:element ref="model.annotLike"/>
        <xs:element ref="model.graphicprimitiveLike"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <!--
    <!ENTITY % content.ossia '
    (
      (%model.staffdefLike;)*,
      (%model.measurePart;|%model.ossiaLike;)*,
      (%model.controleventLike;|%model.lyricsLike;|%model.midiLike;|
      %model.annotLike;|%model.graphicprimitiveLike;|
      %model.editLike;|%model.transcriptionLike;)*
    )*'>
  -->
  <xs:element name="ossia" substitutionGroup="model.ossiaLike"/>
  <xs:attributeGroup name="attlist.ossia">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.anl.ossia"/>
  </xs:attributeGroup>
  <!--
    doc: Beam. A container for a series of explicitly beamed events (Read,
    p. 80-94) which begins and ends entirely within a measure. For beams
    which cross the barline, use the beamspan element. Beaming may be
    indicated for an entire score, part or section by using the beamgroup
    attribute on these elements. Secondary beams may be broken explicitly
    using the breaksec attribute. Stem direction determines whether beams
    are centered between notes with alternating stems (Read, p. 88-89). 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.beam">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="model.eventLike.common"/>
      <xs:group ref="model.eventLike.cmn"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="beam">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.beam">
          <xs:attributeGroup ref="attlist.beam"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.beam">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.beam"/>
    <xs:attributeGroup ref="att.vis.beam"/>
    <xs:attributeGroup ref="att.anl.beam"/>
  </xs:attributeGroup>
  <!--
    doc: A repeated single beat (Read, p. 223-224) 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="beatrpt">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.beatrpt"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.beatrpt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.beatrpt"/>
    <xs:attributeGroup ref="att.vis.beatrpt"/>
    <xs:attributeGroup ref="att.anl.beatrpt"/>
  </xs:attributeGroup>
  <!--
    doc: Bend (stretching a string to make it sound higher than normal). The
    bend element can also be used for scoop, plop, falloff, and doit
    performance effects. It should *not* be used for l.v. (laissez vibrer)
    indications. Precise performance data that differs from the logical
    events in a measure may be recorded within the bend element. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.bend">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="note"/>
      <xs:element ref="rest"/>
      <xs:element ref="tuplet"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="bend">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.bend">
          <xs:attributeGroup ref="attlist.bend"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.bend">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.bend"/>
    <xs:attributeGroup ref="att.vis.bend"/>
    <xs:attributeGroup ref="att.ges.bend"/>
    <xs:attributeGroup ref="att.anl.bend"/>
  </xs:attributeGroup>
  <!--
    doc: Bowed tremolo (Read, p. 393-394) is a rapid alternation on a single
    pitch or chord. This element should also be used for wind double and
    triple tonguing and for flutter tonguing when these are expressed as
    tremolandi. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.btrem">
    <xs:choice>
      <xs:element ref="chord"/>
      <xs:element ref="note"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="btrem">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.btrem">
          <xs:attributeGroup ref="attlist.btrem"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.btrem">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.btrem"/>
    <xs:attributeGroup ref="att.vis.btrem"/>
    <xs:attributeGroup ref="att.anl.btrem"/>
  </xs:attributeGroup>
  <!--
    doc: Chord, a simultaneous sounding of 2 or more notes in the same voice
    *with the same duration*. (Read, p. 69) 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.chord">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="note"/>
      <xs:element ref="artic"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="chord">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.chord">
          <xs:attributeGroup ref="attlist.chord"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.chord">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.chord"/>
    <xs:attributeGroup ref="att.vis.chord"/>
    <xs:attributeGroup ref="att.ges.chord"/>
    <xs:attributeGroup ref="att.anl.chord"/>
  </xs:attributeGroup>
  <!--
    doc: Fingered tremolo (Read, p. 235-238) is a rapid alternation between
    a  pair of notes (or chords or perhaps between a note and a chord) that
    are (usually) farther apart than a major second. For rapid alternation
    between notes on the same pitch (bowed tremolo, double & triple
    tonguing, and flutter tonguing) use the btrem element. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.ftrem">
    <xs:choice>
      <xs:sequence>
        <xs:element ref="chord"/>
        <xs:choice>
          <xs:element ref="chord"/>
          <xs:element ref="note"/>
        </xs:choice>
      </xs:sequence>
      <xs:sequence>
        <xs:element ref="note"/>
        <xs:choice>
          <xs:element ref="chord"/>
          <xs:element ref="note"/>
        </xs:choice>
      </xs:sequence>
    </xs:choice>
  </xs:complexType>
  <xs:element name="ftrem">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.ftrem">
          <xs:attributeGroup ref="attlist.ftrem"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.ftrem">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.ftrem"/>
    <xs:attributeGroup ref="att.vis.ftrem"/>
    <xs:attributeGroup ref="att.ges.ftrem"/>
    <xs:attributeGroup ref="att.anl.ftrem"/>
  </xs:attributeGroup>
  <!--
    doc: Glissando (Read, p. 243-245, 397-398). Sometimes called a 'slide'.
    More precise performance data may be recorded within the gliss element. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.gliss">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="note"/>
      <xs:element ref="rest"/>
      <xs:element ref="tuplet"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="gliss">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.gliss">
          <xs:attributeGroup ref="attlist.gliss"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.gliss">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.gliss"/>
    <xs:attributeGroup ref="att.vis.gliss"/>
    <xs:attributeGroup ref="att.anl.gliss"/>
  </xs:attributeGroup>
  <!--
    doc: Half-measure repeat sign 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.halfmrpt">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.eventLike"/>
  </xs:complexType>
  <xs:element name="halfmrpt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.halfmrpt">
          <xs:attributeGroup ref="attlist.halfmrpt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.halfmrpt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.halfmrpt"/>
    <xs:attributeGroup ref="att.vis.halfmrpt"/>
    <xs:attributeGroup ref="att.anl.halfmrpt"/>
  </xs:attributeGroup>
  <!--
    doc: Note (Read, p. 63), a single pitched event. The note element is
    allowed to contain other events for situations where a single written
    note may be representative of a group of performed notes. The accid and
    artic sub-elements may be used instead of the note element's attributes
    when accid and artic represent first-class objects, e.g. when they
    require attributes, such as x and y location attributes. Similarly, the
    syl sub-element may be used instead of the syl attribute. The verse
    sub-element may be used to group text syllables by verse. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.note">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.noteModifierLike"/>
      <xs:element ref="model.verseLike"/>
      <xs:element ref="model.sylLike"/>
      <xs:element ref="model.apparatusLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="note">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.note">
          <xs:attributeGroup ref="attlist.note"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.note">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.note"/>
    <xs:attributeGroup ref="att.vis.note"/>
    <xs:attributeGroup ref="att.ges.note"/>
    <xs:attributeGroup ref="att.anl.note"/>
  </xs:attributeGroup>
  <!--
    doc: Rest (Read, p. 96-102), i.e. a non-sounding event, found in
    the source being transcribed. Do not confuse this element with the
    space element which is used as an aid for visual alignment. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="rest">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.rest"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.rest">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.rest"/>
    <xs:attributeGroup ref="att.vis.rest"/>
    <xs:attributeGroup ref="att.ges.rest"/>
    <xs:attributeGroup ref="att.anl.rest"/>
  </xs:attributeGroup>
  <!--
    doc: Tuplet (Read, p. 187-215), bowed tremolo (Read, p. 394) & double,
    triple, or flutter tonguing (Read, p. 348-349). The beam sub-element is
    allowed so that custom beaming may be indicated, i.e. a septuplet may be
    divided into a group of 3 plus a group of 4 notes. 
    Used by: model.eventLike.cmn 
    Module:  meiCMN
  -->
  <xs:complexType name="content.tuplet">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="model.eventLike.common"/>
      <xs:group ref="model.eventLike.cmn"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="tuplet">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.tuplet">
          <xs:attributeGroup ref="attlist.tuplet"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.tuplet">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.tuplet"/>
    <xs:attributeGroup ref="att.vis.tuplet"/>
    <xs:attributeGroup ref="att.anl.tuplet"/>
  </xs:attributeGroup>
  <!--
    doc: Complete measure rest in any meter (Read, p. 97-98). The numbering
    of consecutive measures of rest may be controlled via the multi.number
    attribute on the scoredef or staffdef elements. 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="mrest" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.mrest"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mrest">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mrest"/>
    <xs:attributeGroup ref="att.vis.mrest"/>
    <xs:attributeGroup ref="att.ges.mrest"/>
    <xs:attributeGroup ref="att.anl.mrest"/>
  </xs:attributeGroup>
  <!--
    doc: A repeated measure (Read, p. 224-225). The numbering of consecutive
    measures of rest may be controlled via the multi.number attribute on the
    scoredef or staffdef elements. 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="mrpt" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.mrpt"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mrpt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mrpt"/>
    <xs:attributeGroup ref="att.vis.mrpt"/>
    <xs:attributeGroup ref="att.anl.mrpt"/>
  </xs:attributeGroup>
  <!--
    doc: 2-measure repeat sign 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="mrpt2" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.mrpt2"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mrpt2">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mrpt2"/>
    <xs:attributeGroup ref="att.vis.mrpt2"/>
    <xs:attributeGroup ref="att.anl.mrpt2"/>
  </xs:attributeGroup>
  <!--
    doc: Complete measure of space in any meter.  The numbering of consecutive
    measures of space may be controlled via the multi.number attribute on the
    scoredef or staffdef elements. 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="mspace" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.mspace"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mspace">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mspace"/>
    <xs:attributeGroup ref="att.vis.mspace"/>
    <xs:attributeGroup ref="att.ges.mspace"/>
    <xs:attributeGroup ref="att.anl.mspace"/>
  </xs:attributeGroup>
  <!--
    doc: Multiple measures of rest. 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="multirest" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.multirest"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.multirest">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.multirest"/>
    <xs:attributeGroup ref="att.vis.multirest"/>
    <xs:attributeGroup ref="att.ges.multirest"/>
    <xs:attributeGroup ref="att.anl.multirest"/>
  </xs:attributeGroup>
  <!--
    doc: Multiple repeated measures. Read (p. 225-226) says repeats of more
    than 2 measures should be written out using repeat signs. 
    Used by: model.eventLike.cmn.measureFilling 
    Module:  meiCMN
  -->
  <xs:element name="multirpt" substitutionGroup="model.eventLike.cmn.measureFilling">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.multirpt"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.multirpt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.multirpt"/>
    <xs:attributeGroup ref="att.vis.multirpt"/>
    <xs:attributeGroup ref="att.anl.multirpt"/>
  </xs:attributeGroup>
  <!--
    doc: Arpeggiation, roll (Read, p. 241-243). 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="arpeg" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.arpeg"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.arpeg">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.arpeg"/>
    <xs:attributeGroup ref="att.vis.arpeg"/>
    <xs:attributeGroup ref="att.anl.arpeg"/>
  </xs:attributeGroup>
  <!--
    doc: Alternative element for encoding beams, especially useful for beams
    which extend across barlines. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="beamspan" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.beamspan"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.beamspan">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.beamspan"/>
    <xs:attributeGroup ref="att.vis.beamspan"/>
    <xs:attributeGroup ref="att.anl.beamspan"/>
  </xs:attributeGroup>
  <!--
    doc: The breathmark element is a specialized form of, i.e., syntactic sugar
    for, dir/@type="breathmark" with "," as its PCDATA content. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="breath" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.breath"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.breath">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.breath"/>
    <xs:attributeGroup ref="att.vis.breath"/>
    <xs:attributeGroup ref="att.anl.breath"/>
  </xs:attributeGroup>
  <!--
    doc: The fermata element is a specialized form of, i.e., syntactic sugar
    for, dir/@type="fermata" with &ferm; or &uferm; as its PCDATA content. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="fermata" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.fermata"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.fermata">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.fermata"/>
    <xs:attributeGroup ref="att.vis.fermata"/>
    <xs:attributeGroup ref="att.ges.fermata"/>
    <xs:attributeGroup ref="att.anl.fermata"/>
  </xs:attributeGroup>
  <!--
    doc: Hairpin indicates continuous dynamics expressed on the score as
    graphics, e.g. < and >. See Read, p. 250-255. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="hairpin" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.hairpin"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.hairpin">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.hairpin"/>
    <xs:attributeGroup ref="att.vis.hairpin"/>
    <xs:attributeGroup ref="att.ges.hairpin"/>
    <xs:attributeGroup ref="att.anl.hairpin"/>
  </xs:attributeGroup>
  <!--
    doc: Harp pedal diagram 
    Used by: model.controleventLike.instruments 
    Module:  meiCMN
  -->
  <xs:element name="harppedal" substitutionGroup="model.controleventLike.instruments">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.harppedal"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.harppedal">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.harppedal"/>
    <xs:attributeGroup ref="att.vis.harppedal"/>
    <xs:attributeGroup ref="att.ges.harppedal"/>
    <xs:attributeGroup ref="att.anl.harppedal"/>
  </xs:attributeGroup>
  <!--
    doc: Octave displacement. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="octave" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.octave"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.octave">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.octave"/>
    <xs:attributeGroup ref="att.vis.octave"/>
    <xs:attributeGroup ref="att.ges.octave"/>
    <xs:attributeGroup ref="att.anl.octave"/>
  </xs:attributeGroup>
  <!--
    doc: Piano pedal mark (Read, p. 317-318). 
    Used by: model.controleventLike.instruments 
    Module:  meiCMN
  -->
  <xs:element name="pedal" substitutionGroup="model.controleventLike.instruments">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.pedal"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pedal">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.pedal"/>
    <xs:attributeGroup ref="att.vis.pedal"/>
    <xs:attributeGroup ref="att.anl.pedal"/>
  </xs:attributeGroup>
  <!--
    doc: Rehearsal mark (Read, p. 443). The content model uses a subset of
    %model.textphraseLike.limited.  If the entire rehearsal mark is boxed or
    circled, the enclose attribute is preferred over a rend sub-element. 
    Used by: model.controleventLike.common 
    Module:  meiCMN
  -->
  <xs:complexType name="content.reh" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="lb"/>
      <xs:element ref="model.rendLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="reh" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.reh">
          <xs:attributeGroup ref="attlist.reh"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.reh">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.reh"/>
    <xs:attributeGroup ref="att.vis.reh"/>
    <xs:attributeGroup ref="att.anl.reh"/>
  </xs:attributeGroup>
  <!--
    doc: Slur, 2 notes performed legato (Read, p. 265-266). The slur element
    will use either tstamp, duration, and place attributes or start, end,
    and bulge attributes. It is a semantic error not to specify one of these
    groups of attributes. The slur and tie elements may be used instead of
    the slur.* and tie.* attributes provided on chord and note elements when
    1) they are required by software, or 2) multiple, alternative slurs are
    needed. Normally, a slur has only 2 participating events - the starting
    and ending notes/chords. 
    Used by: model.controleventLike.common 
    Module:  meiCMN
  -->
  <xs:element name="slur" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.slur"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.slur">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.slur"/>
    <xs:attributeGroup ref="att.vis.slur"/>
    <xs:attributeGroup ref="att.anl.slur"/>
  </xs:attributeGroup>
  <!--
    doc: Tie (Read, p. 110-111, 122). 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="tie" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.tie"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.tie">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.tie"/>
    <xs:attributeGroup ref="att.vis.tie"/>
    <xs:attributeGroup ref="att.anl.tie"/>
  </xs:attributeGroup>
  <!--
    doc: Alternative element for encoding tuplets, especially useful for
    those which extend across barlines. 
    Used by: model.controleventLike.cmn 
    Module:  meiCMN
  -->
  <xs:element name="tupletspan" substitutionGroup="model.controleventLike.cmn">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.tupletspan"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.tupletspan">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.tupletspan"/>
    <xs:attributeGroup ref="att.vis.tupletspan"/>
    <xs:attributeGroup ref="att.anl.tupletspan"/>
  </xs:attributeGroup>
  <!-- Lyrics -->
  <!--
    doc: Lyrics. The staff attribute gives the staff to which the lyrics
    are attached. The rhythm of the lyrics will be taken from the notes of
    that staff. If there is more than 1 layer on that staff, the layer
    attribute may be used to indicate the layer from which the rhythm
    should be taken. 
    Used by: model.controleventLike.cmn 
    Module:  meiLyrics
  -->
  <xs:complexType name="content.lyrics">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="verse"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="lyrics" substitutionGroup="model.lyricsLike"/>
  <xs:attributeGroup name="attlist.lyrics">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.log.lyrics"/>
    <xs:attributeGroup ref="att.vis.lyrics"/>
    <xs:attributeGroup ref="att.anl.lyrics"/>
  </xs:attributeGroup>
  <!--
    doc: Lyric verse. The lb element is allowed here in order to facilitate
    karaoke applications. The func attribute on lb may be used to
    distinguish true line ends from line group ends for these applications. 
    Used by: model.noteModifierLike model.notaModifierLike model.neumeModifierLike 
    Module:  meiLyrics
  -->
  <xs:complexType name="content.verse">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="dir"/>
        <xs:element ref="dynam"/>
        <xs:element ref="tempo"/>
        <xs:element ref="space"/>
      </xs:choice>
      <xs:element maxOccurs="unbounded" ref="syl"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="lb"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="verse" substitutionGroup="model.verseLike"/>
  <xs:attributeGroup name="attlist.verse">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attributeGroup ref="att.log.verse"/>
    <xs:attributeGroup ref="att.vis.verse"/>
    <xs:attributeGroup ref="att.anl.verse"/>
  </xs:attributeGroup>
  <!--
    doc: Individual lyric syllable. 
    Used by: model.noteModifierLike model.notaModifierLike model.rdgPart 
    Module:  meiLyrics
  -->
  <xs:complexType name="content.syl" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="syl" substitutionGroup="model.sylLike"/>
  <xs:attributeGroup name="attlist.syl">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.syl"/>
    <xs:attributeGroup ref="att.vis.syl"/>
    <xs:attributeGroup ref="att.anl.syl"/>
  </xs:attributeGroup>
  <!-- CMN Ornaments -->
  <!--
    doc: Events may be contained within mordent in order to record precise
    performance data. (Read, p. 245-246) 
    Used by: model.ornamentLike.cmn 
    Module:  meiCMNOrnaments
  -->
  <xs:complexType name="content.mordent">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.eventLike"/>
  </xs:complexType>
  <xs:element name="mordent" substitutionGroup="model.ornamentLike.cmn">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.mordent">
          <xs:attributeGroup ref="attlist.mordent"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mordent">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.mordent"/>
    <xs:attributeGroup ref="att.vis.mordent"/>
    <xs:attributeGroup ref="att.anl.mordent"/>
  </xs:attributeGroup>
  <!--
    doc: Trill (Read, p. 232-235). Events may be contained within trill in
    order to record precise performance data. 
    Used by: model.ornamentLike.cmn 
    Module:  meiCMNOrnaments
  -->
  <xs:complexType name="content.trill">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.eventLike"/>
  </xs:complexType>
  <xs:element name="trill" substitutionGroup="model.ornamentLike.cmn">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.trill">
          <xs:attributeGroup ref="attlist.trill"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.trill">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.trill"/>
    <xs:attributeGroup ref="att.vis.trill"/>
    <xs:attributeGroup ref="att.anl.trill"/>
  </xs:attributeGroup>
  <!--
    doc: Turn (Read, p. 246-247). Events may be contained within turn in
    order to record precise performance data. Whether the turn is accented
    or unaccented may be inferred from the timestamp - accented turns occur
    directly on the affected beat, unaccented ones do not. 
    Used by: model.ornamentLike.cmn 
    Module:  meiCMNOrnaments
  -->
  <xs:complexType name="content.turn">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.eventLike"/>
  </xs:complexType>
  <xs:element name="turn" substitutionGroup="model.ornamentLike.cmn">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.turn">
          <xs:attributeGroup ref="attlist.turn"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.turn">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.turn"/>
    <xs:attributeGroup ref="att.vis.turn"/>
    <xs:attributeGroup ref="att.anl.turn"/>
  </xs:attributeGroup>
  <!-- Harmony -->
  <!--
    doc: An indication of fingering in a chord tablature grid. The from
    and to attributes should contain the id of a chordmember element. 
    Used by: chorddef 
    Module:  meiHarmony
  -->
  <xs:element name="barre">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.barre"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.barre">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="fret" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="1"/>
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
          <xs:enumeration value="4"/>
          <xs:enumeration value="5"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="from" use="required" type="xs:IDREF"/>
    <xs:attribute name="to" use="required" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Chord/tablature definition. An individual chord in the chord
    table. An id isn't required here but harm elements can only reference
    a particular chorddef via an id. Therefore, if a chorddef will ever be
    referenced, an id is necessary. The pos (position) attribute is
    provided in order to create displayable chord tablature grids. (Read,
    p. 409-410) 
    Used by: chordtable 
    Module:  meiHarmony
  -->
  <xs:complexType name="content.chorddef">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="chordmember"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="barre"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="chorddef">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.chorddef">
          <xs:attributeGroup ref="attlist.chorddef"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.chorddef">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="pos"/>
  </xs:attributeGroup>
  <!--
    doc: Chord member. An individual pitch in a chord. The fing and fret
    attributes are provided in order to create displayable chord tablature
    grids. The inth (harmonic interval) attribute gives the number of 1/2
    steps above the bass. Of course, for the bass note itself, inth should
    be set to '0'. The inth attribute may be used to provide "playable"
    chords. 
    Used by: chordmember 
    Module:  meiHarmony
  -->
  <xs:element name="chordmember">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.chordmember"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.chordmember">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="accid" type="data.ACCIDENTAL.IMPLICIT"/>
    <xs:attribute name="fing">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="x"/>
          <xs:enumeration value="o"/>
          <xs:enumeration value="1"/>
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
          <xs:enumeration value="4"/>
          <xs:enumeration value="5"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="fret">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="1"/>
          <xs:enumeration value="2"/>
          <xs:enumeration value="3"/>
          <xs:enumeration value="4"/>
          <xs:enumeration value="5"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="inth" type="data.INTEGERNONNEGATIVE"/>
    <xs:attribute name="pname" use="required" type="data.PITCHNAME"/>
  </xs:attributeGroup>
  <!--
    doc: Chord/tablature look-up table. A table may be shared between mei
    instances through the use of an external parsed entity containing the
    look-up table to be shared. 
    Used by: model.chordtableLike 
    Module:  meiHarmony
  -->
  <xs:complexType name="content.chordtable">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="chorddef"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="chordtable" substitutionGroup="model.chordtableLike"/>
  <xs:attributeGroup name="attlist.chordtable">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Indication of harmony, e.g. chord names, tablature grids, harmonic
    analysis, figured bass. Read, p. 411. The %model.textphraseLike.limited
    entity is employed here instead of %model.textphrase in order to disallow
    the use of the pb sub-element. 
    Used by: model.controleventLike.cmn 
    Module:  meiHarmony
  -->
  <xs:complexType name="content.harm" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.graphicprimitiveLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="harm" substitutionGroup="model.harmLike"/>
  <xs:attributeGroup name="attlist.harm">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.log.harm"/>
    <xs:attributeGroup ref="att.vis.harm"/>
    <xs:attributeGroup ref="att.ges.harm"/>
    <xs:attributeGroup ref="att.anl.harm"/>
  </xs:attributeGroup>
  <!-- User-defined symbols -->
  <!--
    doc: Curve. The x1,y1 and x2,y2 attributes identify the two terminal
    points of the curve. If the startid or endid attributes are present,
    then the x,y and x2,y2 coordinates are relative to the xy coordinates
    of the referenced element(s). Otherwise, they are assumed to be
    absolute page coordinate references. The bulge or, alternatively, the
    bezier attribute, describe the shape of the curve. The bulge attribute
    describes the curve as a set of distance values above or below an
    imaginary line connecting the endpoints of the curve while the bezier
    attribute records the placement of Bezier control points as a series
    of space-separated xy coordinate pairs, eg. 19 45 -32 118. The bulge
    attribute must contain one or more values of the %NUMBER type. Either
    the bezier attribute or the bulge and xy coordinates are required. 
    Used by: model.graphicprimitiveLike 
    Module:  meiUserSymbols
  -->
  <xs:element name="curve" substitutionGroup="model.graphicprimitiveLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.curve"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.curve">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.xy.required"/>
    <xs:attributeGroup ref="att.xy2.required"/>
    <xs:attribute name="bezier" type="xs:NMTOKENS"/>
    <xs:attribute name="bulge" type="xs:NMTOKENS"/>
    <xs:attribute name="rend" type="data.CURVERENDITION"/>
  </xs:attributeGroup>
  <!--
    doc: Line. The x,y and x2,y2 attributes identify the two terminal
    points of the line. Text content of the line element, e.g. 'gliss.',
    may be rendered with the line. If the startid or endid attributes are
    present, then the x,y and x2,y2 coordinates are relative to the xy
    coordinates of the referenced element(s). Otherwise, they are assumed
    to be absolute page coordinate references. 
    Used by: model.graphicprimitiveLike 
    Module:  meiUserSymbols
  -->
  <xs:complexType name="content.line" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="line" substitutionGroup="model.graphicprimitiveLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.line">
          <xs:attributeGroup ref="attlist.line"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.line">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.startendid"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.xy.required"/>
    <xs:attributeGroup ref="att.xy2.required"/>
    <xs:attribute name="rend" type="data.LINERENDITION"/>
  </xs:attributeGroup>
  <!--
    doc: A reference to a previously defined symbol. The x and y attributes
    identify the starting point, e.g. "hotspot" of the symbol. If the
    startid attribute is present, then the xy coordinates are relative to
    the xy coordinates of the referenced element. Otherwise, they are
    assumed to be absolute page coordinate references. The ref attribute
    must contain the id of a symboldef element. The scale attribute indicates
    that the printed output must be scaled by the specified percentage. 
    Used by: model.graphicprimitiveLike 
    Module:  meiUserSymbols
  -->
  <xs:element name="symbol" substitutionGroup="model.graphicprimitiveLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.symbol"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.symbol">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.color"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.xy.required"/>
    <xs:attribute name="ref" use="required" type="xs:IDREF"/>
    <xs:attribute name="scale" type="data.PERCENT"/>
    <xs:attribute name="startid" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Declaration of an individual symbol. 
    Used by: symboltable 
    Module:  meiUserSymbols
  -->
  <xs:complexType name="content.symboldef">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.graphicprimitiveLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="symboldef">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.symboldef">
          <xs:attributeGroup ref="attlist.symboldef"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.symboldef">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Symboltable contains individual, user-defined symbols. Like
    a chord table, a symboltable may be shared between mei instances
    through the use of an external parsed entity containing the
    symboltable to be shared. 
    Used by: model.symboltableLike 
    Module:  meiUserSymbols
  -->
  <xs:complexType name="content.symboltable">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="symboldef"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="symboltable" substitutionGroup="model.symboltableLike"/>
  <xs:attributeGroup name="attlist.symboltable">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!-- Critical apparatus -->
  <!--
    doc: An app (apparatus) element contains one or more alternative
    encodings. The alternatives may be thought of as exclusive or as
    parallel. The type attribute may contain any convenient descriptive
    word, describing the extent of the variation (e.g. note, phrase,
    measure, etc.), its text-critical significance (e.g. significant,
    accidental, unclear), or the nature of the variation or the principles
    required to understand it (e.g. lectio difficilior, usus auctoris,
    etc.) 
    Used by: model.apparatusLike 
    Module:  meiCritApp
  -->
  <xs:complexType name="content.app">
    <xs:sequence>
      <xs:element ref="rdg"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="rdg"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="app" substitutionGroup="model.apparatusLike"/>
  <xs:attributeGroup name="attlist.app">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Reading. Since a reading can be a multi-measure section, the
    scoredef element is allowed so that a reading may have its own meta-
    data without the overhead of child sections. The measure sub-element
    is declared in the meiBase DTD and the pb sub-element is declared in
    the meiShared DTD. The app sub-element is permitted in order to allow
    nested sub-variants. 
    Used by: app 
    Module:  meiCritApp
  -->
  <xs:complexType name="content.rdg">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.rdgPart"/>
  </xs:complexType>
  <xs:element name="rdg">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.rdg">
          <xs:attributeGroup ref="attlist.rdg"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.rdg">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.crit"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attributeGroup ref="att.link.common"/>
    <xs:attributeGroup ref="att.link.external"/>
    <xs:attributeGroup ref="att.link.internal"/>
    <xs:attributeGroup ref="att.anl.rdg"/>
    <xs:attributeGroup ref="att.log.rdg"/>
  </xs:attributeGroup>
  <!-- Header -->
  <!--
    doc: Description of the access that may be obtained. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. 
    Used by: model.availabilityPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.accessdesc" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="accessdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.accessdesc">
          <xs:attributeGroup ref="attlist.accessdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.accessdesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Source from which access to this item may be obtained, e.g. vendor,
    distributor, etc. The %model.textphraseLike.limited entity is used here
    in order to disallow the pb element. 
    Used by: model.availabilityPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.acqsource" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="acqsource">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.acqsource">
          <xs:attributeGroup ref="attlist.acqsource"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.acqsource">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The altmeiid element may contain a bibliographic identifier
    that does not fit within the meihead id attribute, for example because
    the id does not fit the definition of an XML id or because multiple
    identifiers are needed. 
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.altmeiid" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="altmeiid">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.altmeiid">
          <xs:attributeGroup ref="attlist.altmeiid"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.altmeiid">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    doc: Appinfo (application information) groups information about
    applications which have acted upon the MEI file. This is not to be
    confused with applications which were used to create the MEI file.
    These are recorded in the projectdesc element. 
    Used by: model.encodingPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.appinfo">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="application"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="appinfo">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.appinfo">
          <xs:attributeGroup ref="attlist.appinfo"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.appinfo">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Application provides information about an application which has acted
    upon the document. 
    Used by: appinfo 
    Module:  meiHeader
  -->
  <xs:complexType name="content.application">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="name"/>
      <xs:choice>
        <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.ptrLike"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.pLike"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="application">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.application">
          <xs:attributeGroup ref="attlist.application"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.application">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.date"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="version"/>
  </xs:attributeGroup>
  <!--
    doc: Availability information/qualifications. 
    Used by: model.pubstmtPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.availability">
    <xs:complexContent>
      <xs:extension base="model.availabilityPart"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="availability">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.availability">
          <xs:attributeGroup ref="attlist.availability"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.availability">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Individual change within the revision description. The resp
    attribute contains a pointer to an element containing info about the
    person/entity responsible for change. The date element is declared in
    the meiShared DTD. 
    Used by: revisiondesc 
    Module:  meiHeader
  -->
  <xs:complexType name="content.change">
    <xs:sequence>
      <xs:element ref="changedesc"/>
      <xs:element ref="model.dateLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="change">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.change">
          <xs:attributeGroup ref="attlist.change"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.change">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="resp" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Description of a revision. The p element is declared in the
    meiShared DTD. 
    Used by: change 
    Module:  meiHeader
  -->
  <xs:complexType name="content.changedesc">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="changedesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.changedesc">
          <xs:attributeGroup ref="attlist.changedesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.changedesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: A classification code, i.e., LC subject or call number, or a
    thesaurus or ontology citation.  The source of controlled-vocabulary
    terms used in the keywords element. 
    Used by: classification 
    Module:  meiHeader
  -->
  <xs:element name="classcode">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.classcode"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.classcode">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The classification element groups information which describes the
    nature or topic of a musical work in terms of a standard classification
    scheme, thesaurus, etc. 
    Used by: model.profiledescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.classification">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="classcode"/>
      <xs:element ref="keywords"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="classification">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.classification">
          <xs:attributeGroup ref="attlist.classification"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.classification">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The physical condition of an item, particularly any variances
    between the physical makeup of the item and that of other copies of the
    same item (e.g., missing pages, plates, etc.). Condition may reflect
    other aspects of the physical condition of the item as well (e.g.,
    brittleness, faded images, etc.). The %model.textphraseLike.limited
    entity is used here in order to disallow the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.condition" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="condition">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.condition">
          <xs:attributeGroup ref="attlist.condition"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.condition">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: States how and under what circumstances corrections have been made
    in the music/text. 
    Used by: model.editorialdeclPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.correction">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="correction" substitutionGroup="model.editorialdeclPart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.correction">
          <xs:attributeGroup ref="attlist.correction"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.correction">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="method">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="silent"/>
          <xs:enumeration value="tags"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="status">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="high"/>
          <xs:enumeration value="medium"/>
          <xs:enumeration value="low"/>
          <xs:enumeration value="unknown"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Non-bibliographic creation details for the work being encoded, in
    narrative form. The model.textcomponent class elements are declared in the
    meiShared DTD. 
    Used by: model.profiledescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.creation">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.textcomponentLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="creation">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.creation">
          <xs:attributeGroup ref="attlist.creation"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.creation">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Physical dimensions of a bibliographic source. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. There are no height and width sub-elements; however,
    the num element may be used. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.dimensions" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="dimensions">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.dimensions">
          <xs:attributeGroup ref="attlist.dimensions"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.dimensions">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="units"/>
  </xs:attributeGroup>
  <!--
    doc: Container for meta-data pertaining to the edition. 
    Used by: filedesc source 
    Module:  meiHeader
  -->
  <xs:complexType name="content.editionstmt">
    <xs:sequence maxOccurs="unbounded">
      <xs:element ref="edition"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="respstmt"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="editionstmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.editionstmt">
          <xs:attributeGroup ref="attlist.editionstmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.editionstmt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Editorialdecl should be used to provide details of editorial
    principles and practices applied during the encoding of musical text.
    Used by: model.encodingPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.editorialdecl">
    <xs:choice>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="model.editorialdeclPart"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.pLike"/>
      </xs:sequence>
    </xs:choice>
  </xs:complexType>
  <xs:element name="editorialdecl">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.editorialdecl">
          <xs:attributeGroup ref="attlist.editorialdecl"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.editorialdecl">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Documents the relationship between an electronic file and the
    source or sources from which it was derived as well as applications used
    in the encoding/editing process. 
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.encodingdesc">
    <xs:complexContent>
      <xs:extension base="model.encodingPart"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="encodingdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.encodingdesc">
          <xs:attributeGroup ref="attlist.encodingdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.encodingdesc">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Exhibition history is a record of public exhibitions, including
    dates, venues, etc. The %model.textphraseLike.limited entity is used
    here in order to disallow the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.exhibithist" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="exhibithist">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.exhibithist">
          <xs:attributeGroup ref="attlist.exhibithist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.exhibithist">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The extent element is used to express size in terms other than
    physical dimensions, such as number of pages, number of records in file,
    number of bytes, performance duration for music, audio recordings and
    visual projections, etc. For physical dimensions use the dimensions
    element. The %model.textphraseLike.limited entity is used here in order
    to disallow the pb element. 
    Used by: model.physdescPart filedesc 
    Module:  meiHeader
  -->
  <xs:complexType name="content.extent" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="extent">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.extent">
          <xs:attributeGroup ref="attlist.extent"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.extent">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="units"/>
  </xs:attributeGroup>
  <!--
    doc: Filedesc contains a full bibliographic description of the
    MEI file. Extent in this context is file size. 
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.filedesc">
    <xs:sequence>
      <xs:element ref="titlestmt"/>
      <xs:element minOccurs="0" ref="editionstmt"/>
      <xs:element minOccurs="0" ref="extent"/>
      <xs:element minOccurs="0" ref="fingerprint"/>
      <xs:element ref="pubstmt"/>
      <xs:element minOccurs="0" ref="seriesstmt"/>
      <xs:element minOccurs="0" ref="notesstmt"/>
      <xs:element minOccurs="0" ref="sourcedesc"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="filedesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.filedesc">
          <xs:attributeGroup ref="attlist.filedesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.filedesc">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Traditionally, an identifier constructed by combining groups of
    characters transcribed from specified pages of a printed item. For an
    electronic item, however, the fingerprint should be a checksum. The
    checksum makes it possible to signal differences between copies of the
    item. 
    Used by: filedesc 
    Module:  meiHeader
  -->
  <xs:element name="fingerprint">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.fingerprint"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.fingerprint">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: The hand element is used to define each distinct scribe or
    handwriting style. The initial attribute indicates whether this is the
    first or main scribe of the document. The medium attribute describes
    the writing medium, e.g., 'pencil', or the tint or type of ink, e.g.
    'brown'. The resp attribute contains an ID reference to an element
    containing the name of the editor or transcriber responsible for
    identifying the hand. The characteristics of the hand, particularly
    those related to the quality of the writing, such as 'shaky', 'thick',
    etc. may be described within the content of the hand element. 
    Used by: handlist 
    Module:  meiHeader
  -->
  <xs:complexType name="content.hand" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="hand">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.hand">
          <xs:attributeGroup ref="attlist.hand"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.hand">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="initial" type="data.BOOLEAN"/>
    <xs:attribute name="medium"/>
    <xs:attribute name="resp" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: The handlist element contains a series of <hand> elements listing
    the different hands of the source. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.handlist">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="hand"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="handlist">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.handlist">
          <xs:attributeGroup ref="attlist.handlist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.handlist">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: An inscription added to an item, such as a bookplate, a note
    designating the item as a gift, and/or the author's signature. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.inscription" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike.limited"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="inscription">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.inscription">
          <xs:attributeGroup ref="attlist.inscription"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.inscription">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Describes the scope of any analytic or interpretive information
    added to the musical text in addition to the transcription. 
    Used by: model.editorialdeclPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.interpretation">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="interpretation" substitutionGroup="model.editorialdeclPart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.interpretation">
          <xs:attributeGroup ref="attlist.interpretation"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.interpretation">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Collection of keywords or text phrases which describe the work. 
    Used by: classification 
    Module:  meiHeader
  -->
  <xs:complexType name="content.keywords">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="term"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="keywords">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.keywords">
          <xs:attributeGroup ref="attlist.keywords"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.keywords">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The name of a language. The language of text elements may be
    related to this element via its id, which may take the form of a code,
    drawn from a coded list, such as iso639-2b. The
    %model.textphraseLike.limited entity is used here in order to
    disallow the pb element. 
    Used by: langusage 
    Module:  meiHeader
  -->
  <xs:complexType name="content.language" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="language">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.language">
          <xs:attributeGroup ref="attlist.language"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.language">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Langusage describes the languages, sublanguages, dialects, etc.,
    represented within the encoded work. 
    Used by: model.profiledescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.langusage">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="language"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="langusage">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.langusage">
          <xs:attributeGroup ref="attlist.langusage"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.langusage">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Indicates the extent of normalization or regularization of the
    original source carried out in converting it to electronic form. 
    Used by: model.editorialdeclPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.normalization">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="normalization" substitutionGroup="model.editorialdeclPart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.normalization">
          <xs:attributeGroup ref="attlist.normalization"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.normalization">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="method">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="silent"/>
          <xs:enumeration value="tags"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Collects together any bibliographic notes providing information
    additional to that recorded in other parts of the bibliographic
    description. 
    Used by: filedesc 
    Module:  meiHeader
  -->
  <xs:complexType name="content.notesstmt">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.annotLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="notesstmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.notesstmt">
          <xs:attributeGroup ref="attlist.notesstmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.notesstmt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Physical description of a source for the electronic edition.
    Dedicatory text and title page features may be encoded here when
    they are not transcribed as part of the front or back matter; i.e.,
    when they are considered to be meta-data. 
    Used by: source 
    Module:  meiHeader
  -->
  <xs:complexType name="content.physdesc">
    <xs:group maxOccurs="unbounded" ref="model.physdescPart"/>
  </xs:complexType>
  <xs:element name="physdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.physdesc">
          <xs:attributeGroup ref="attlist.physdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.physdesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Location of the source within a repository, e.g., shelf mark or
    other locational information. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.physloc" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="physloc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.physloc">
          <xs:attributeGroup ref="attlist.physloc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.physloc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Physmedium is used to record the physical materials used in the
    source, such as ink and paper. The %model.textphraseLike.limited
    entity is used here in order to disallow the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.physmedium" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="physmedium">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.physmedium">
          <xs:attributeGroup ref="attlist.physmedium"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.physmedium">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The cost of access. The %model.textphraseLike.limited entity is
    used here in order to disallow the pb element. 
    Used by: model.availabilityPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.price" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="price">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.price">
          <xs:attributeGroup ref="attlist.price"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.price">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attribute name="units"/>
  </xs:attributeGroup>
  <!--
    doc: Profiledesc provides a detailed description of the non-
    bibliographic aspects of the creation of a work, specifically the
    languages and sublanguages used, the situation in which it was
    produced, e.g. the participants, setting, reception history, etc. 
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.profiledesc">
    <xs:complexContent>
      <xs:extension base="model.profiledescPart"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="profiledesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.profiledesc">
          <xs:attributeGroup ref="attlist.profiledesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.profiledesc">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Project-level meta-data describing the aim or purpose for which
    the electronic file was encoded, funding agencies, etc. together with
    any other relevant information concerning the process by which it was
    assembled or collected.
    Used by: model.encodingPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.projectdesc">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="projectdesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.projectdesc">
          <xs:attributeGroup ref="attlist.projectdesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.projectdesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The record of ownership or custodianship of an item. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.provenance" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.listLike"/>
      <xs:group ref="model.textphraseLike.limited"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="provenance">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.provenance">
          <xs:attributeGroup ref="attlist.provenance"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.provenance">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Publication meta-data.
    Used by: filedesc source 
    Module:  meiHeader
  -->
  <xs:complexType name="content.pubstmt">
    <xs:choice>
      <xs:element minOccurs="0" ref="unpub"/>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.pubstmtPart"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="pubstmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.pubstmt">
          <xs:attributeGroup ref="attlist.pubstmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.pubstmt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: A statement of responsibility names one or more individuals,
    groups, or in rare cases, mechanical processes, responsible for
    creation or realization of the intellectual or artistic content.
    Used by: model.pubstmtPart model.respLike titlestmt editionstmt seriesstmt 
    Module:  meiHeader
  -->
  <xs:complexType name="content.respstmt">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="model.nameLike"/>
      <xs:element ref="model.nameLike.agent"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="respstmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.respstmt">
          <xs:attributeGroup ref="attlist.respstmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.respstmt">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: The revision history for an MEI file. 
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.revisiondesc">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="change"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="revisiondesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.revisiondesc">
          <xs:attributeGroup ref="attlist.revisiondesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.revisiondesc">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Contains a prose description of the rationale and methods used in
    sampling texts in the creation of a corpus or collection. 
    Used by: model.encodingPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.samplingdecl">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="samplingdecl">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.samplingdecl">
          <xs:attributeGroup ref="attlist.samplingdecl"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.samplingdecl">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Describes the principles according to which the musical text has been
    segmented, for example into movements, sections, etc. 
    Used by: model.editorialdeclPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.segmentation">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="segmentation" substitutionGroup="model.editorialdeclPart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.segmentation">
          <xs:attributeGroup ref="attlist.segmentation"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.segmentation">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Groups information about the series, if any, to which a
    publication belongs. In this context, the title element records the
    series title, the respStmt element records the person or group
    responsible for the series, and the identifier element contains a
    series identifier. The list element should be used when it is necessary
    to enumerate the contents of the series. The seriesstmt is provided
    within seriesstmt for the description of a sub-series.
    Used by: filedesc source seriesstmt 
    Module:  meiHeader
  -->
  <xs:complexType name="content.seriesstmt">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="title"/>
      <xs:element minOccurs="0" ref="respstmt"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="identifier"/>
      <xs:choice>
        <xs:element ref="model.listLike"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="seriesstmt"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="seriesstmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.seriesstmt">
          <xs:attributeGroup ref="attlist.seriesstmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.seriesstmt">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Source contains a bibliographic description of a source for the
    electronic file. When there are multiple sources, the data attribute may
    be used to link the description to a particular data element, i.e., mdiv,
    part, section, ending, reading, measure, staff or layer. Within source,
    the extent element may be used when only a portion of the source, pages
    1-3 for example, are encoded. If extent is absent, then the entire
    source is presumed to have been encoded. Multiple physdesc sub-elements
    may be used to describe the physically separate parts of a single
    source. 
    Used by: sourcedesc 
    Module:  meiHeader
  -->
  <xs:complexType name="content.source">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="identifier"/>
      <xs:element minOccurs="0" ref="titlestmt"/>
      <xs:element minOccurs="0" ref="editionstmt"/>
      <xs:element ref="pubstmt"/>
      <xs:element minOccurs="0" ref="physdesc"/>
      <xs:element minOccurs="0" ref="seriesstmt"/>
      <xs:element minOccurs="0" ref="notesstmt"/>
      <xs:element minOccurs="0" ref="langusage"/>
      <xs:element minOccurs="0" ref="classification"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="source">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.source">
          <xs:attributeGroup ref="attlist.source"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.source">
    <xs:attribute name="data" type="xs:IDREFS"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Sourcedesc is a container for the descriptions of the source(s)
    used in the creation of the electronic file. The sourcedesc element is
    required where the MEI file is a transcription of existing music. In the
    case where the data is originally created in MEI form, the sourcedesc
    element is not required.
    Used by: meihead 
    Module:  meiHeader
  -->
  <xs:complexType name="content.sourcedesc">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="source"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="sourcedesc">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.sourcedesc">
          <xs:attributeGroup ref="attlist.sourcedesc"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.sourcedesc">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Specifies the format used when standardized date or number values are
    supplied. 
    Used by: model.editorialdeclPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.stdvals">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="model.pLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="stdvals" substitutionGroup="model.editorialdeclPart">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.stdvals">
          <xs:attributeGroup ref="attlist.stdvals"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.stdvals">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: System requirements for using the electronic item. The
    %model.textphraseLike.limited entity is used here in order to disallow the pb
    element. 
    Used by: model.availabilityPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.sysreq" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="sysreq">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.sysreq">
          <xs:attributeGroup ref="attlist.sysreq"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.sysreq">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Individual keywords or phrases which describe the work. The
    classcode attribute may be used to link the term to a terminological
    source given in a classcode element. The %model.textphraseLike.limited
    entity is used here in order to disallow the pb element. The term
    element may include other term elements in order to allow the creation
    of coordinated terms; i.e., terms created from a combination of other,
    independent terms. 
    Used by: keywords 
    Module:  meiHeader
  -->
  <xs:complexType name="content.term" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="term"/>
      <xs:group ref="model.textphraseLike.limited"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="term">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.term">
          <xs:attributeGroup ref="attlist.term"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.term">
    <xs:attribute name="classcode" type="xs:IDREF"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Container for title and responsibility meta-data.
    Used by: filedesc source 
    Module:  meiHeader
  -->
  <xs:complexType name="content.titlestmt">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" ref="title"/>
      <xs:element minOccurs="0" ref="respstmt"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="titlestmt">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.titlestmt">
          <xs:attributeGroup ref="attlist.titlestmt"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.titlestmt">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: A record of the treatment the item has undergone (e.g.,
    deacidification, restoration, etc.) Treatment history may also comprise
    details of the treatment process (e.g., chemical solutions used,
    techniques applied, etc.), the date the treatment was applied, etc. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.treatmenthist" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="treatmenthist">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.treatmenthist">
          <xs:attributeGroup ref="attlist.treatmenthist"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.treatmenthist">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Scheduled treatment, e.g. deacidification, restoration, etc., for
    an item. The %model.textphraseLike.limited entity is used here in
    order to disallow the pb element. 
    Used by: model.physdescPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.treatmentsched" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="treatmentsched">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.treatmentsched">
          <xs:attributeGroup ref="attlist.treatmentsched"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.treatmentsched">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: The unpub element should be used to explicitly indicate that a
    bibliographic source is unpublished. 
    Used by: pubstmt 
    Module:  meiHeader
  -->
  <xs:element name="unpub">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.unpub"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.unpub">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!--
    doc: Usage restrictions, e.g., copyright statement in the filedesc, or
    (re-)publication rights in the source element. The
    %model.textphraseLike.limited entity is used here in order to disallow
    the pb element. 
    Used by: model.availabilityPart 
    Module:  meiHeader
  -->
  <xs:complexType name="content.userestrict" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="model.textphraseLike.limited"/>
  </xs:complexType>
  <xs:element name="userestrict">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.userestrict">
          <xs:attributeGroup ref="attlist.userestrict"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.userestrict">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.bibl"/>
  </xs:attributeGroup>
  <!-- MIDI -->
  <!--
    doc: Parameter/control change. The n attribute specifies parameter number,
    while val contains the parameter value. Each must fall in the range 0-127.
    A sampling of controllers and their numbers:
    0   Bank Select MSB
    1   Modulation 
    2   Breath Control
    5   Portamento Time
    7   Main Volume
    10  Pan
    11  Expression
    32  Bank Select LSB
    64  Sustain Pedal (0=up, 127=down)
    65  Portamento Pedal (0=off, 127=on)
    91  Reverb
    93  Chorus Depth
    120 All Sounds Off (0)
    121 Reset All Controllers (0)
    123 All Notes Off (0) 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="cc">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.cc"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.cc">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
    <xs:attribute name="val" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Channel assignment 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="chan">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.chan"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.chan">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDICHANNEL"/>
  </xs:attributeGroup>
  <!--
    doc: Channel pressure/after touch. The n attribute must be in the
    range 0-127. 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="chanpr">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.chanpr"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.chanpr">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Cue point 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="cue">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.cue"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.cue">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
  </xs:attributeGroup>
  <!--
    doc: Arbitrary MIDI data in hex 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="hex">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.hex"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.hex">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
  </xs:attributeGroup>
  <!--
    doc: Marker meta event
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="marker">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.marker"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.marker">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
  </xs:attributeGroup>
  <!--
    doc: Text meta event 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="metatext">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.metatext"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.metatext">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
  </xs:attributeGroup>
  <!--
    doc: Container for a collection of elements which contain information
    useful when generating MIDI output. The n attribute can be used to
    differentiate between multiple MIDI data streams, e.g.
    quantized/unquantized, straight/swing, ornamented/as notated, etc. 
    Used by: model.midiLike 
    Module:  meiMIDI
  -->
  <xs:complexType name="content.midi">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="cc"/>
      <xs:element ref="chan"/>
      <xs:element ref="chanpr"/>
      <xs:element ref="cue"/>
      <xs:element ref="hex"/>
      <xs:element ref="marker"/>
      <xs:element ref="metatext"/>
      <xs:element ref="noteoff"/>
      <xs:element ref="noteon"/>
      <xs:element ref="port"/>
      <xs:element ref="prog"/>
      <xs:element ref="seqnum"/>
      <xs:element ref="trkname"/>
      <xs:element ref="vel"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="midi" substitutionGroup="model.midiLike"/>
  <xs:attributeGroup name="attlist.midi">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.log.midi"/>
    <xs:attributeGroup ref="att.anl.midi"/>
  </xs:attributeGroup>
  <!--
    doc: Note-off 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="noteoff">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.noteoff"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.noteoff">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Note-on 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="noteon">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.noteon"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.noteon">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: MIDI port. The n attribute must be in the range 0-127. 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="port">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.port"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.port">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Program change/new instrument. The n attribute must be in the
    range 0-127. 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="prog">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.prog"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.prog">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.MIDIVALUE"/>
  </xs:attributeGroup>
  <!--
    doc: Sequence number. The n attribute must be in the range 0-65535 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="seqnum">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.seqnum"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.seqnum">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="num" use="required" type="data.INTEGERNONNEGATIVE"/>
  </xs:attributeGroup>
  <!--
    doc: Track/sequence name 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="trkname">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="attlist.trkname"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.trkname">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
  </xs:attributeGroup>
  <!--
    doc: Note-on/off velocity. For on velocity, the attribute must be in
    the range 1-127. For off velocity, the n attribute must be in the range
    0-127. 
    Used by: model.midieventLike 
    Module:  meiMIDI
  -->
  <xs:element name="vel">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.vel"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.vel">
    <xs:attributeGroup ref="att.common.anl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.midi.event"/>
    <xs:attribute name="form" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="on"/>
          <xs:enumeration value="off"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="num" use="required"/>
  </xs:attributeGroup>
  <!-- Editorial/Transcription -->
  <!--
    doc: Marks an addition to the musical text.  The add element contains
    material inserted by an author, scribe, annotator, or corrector. The
    resp attribute contains a ID reference to an element containing the
    editor or transcriber responsible for identifying the hand of the
    addition. The cert attribute signifies the degree of certainty
    ascribed to the identification of the hand of the addition. The hand
    attribute signifies the hand of the agent which made the addition. 
    Used by: model.transcriptionLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.add" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="add" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.add">
          <xs:attributeGroup ref="attlist.add"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.add">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.trans"/>
  </xs:attributeGroup>
  <!--
    doc: Choice 
    Used by: model.editLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.choice">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="choice"/>
      <xs:group ref="model.choicePart"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="choice" substitutionGroup="model.editLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.choice">
          <xs:attributeGroup ref="attlist.choice"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.choice">
    <xs:attributeGroup ref="att.common"/>
  </xs:attributeGroup>
  <!--
    doc: Correction contains the correct form of an apparent erroneous
    passage. The resp attribute contains an ID reference to an element
    containing the name of the editor or transcriber responsible for
    suggesting the correction held as the content of the <corr> element.
    If the correction was made in the source, resp should be used to
    identify the hand of the corrector. 
    Used by: model.transcriptionLike model.choicePart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.corr" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="corr" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.corr">
          <xs:attributeGroup ref="attlist.corr"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.corr">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.trans"/>
  </xs:attributeGroup>
  <!--
    doc: Contains an area of damage to the carrier.  In the case of damage
    resulting from an identifiable cause, the agent attribute signifies
    the causative agent.  The degree attribute signifies the degree of
    damage according to a convenient scale. The <damage> tag with this
    attribute should only be used where the text may be read with some
    confidence; data supplied from other sources should be tagged as
    <supplied>. The extent attribute indicates approximately how much text
    is in the damaged area, in notes, measures, inches, or any appropriate
    unit, where this cannot be deduced from the contents of the tag. For
    example, the damage may span structural divisions in the text so that
    the tag must then be empty of content. In the case of damage
    (deliberate defacement, etc.) assignable to an identifiable hand, the
    hand attribute signifies the hand responsible for the damage. 
    Used by: model.transcriptionLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.damage" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="damage" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.damage">
          <xs:attributeGroup ref="attlist.damage"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.damage">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="agent"/>
    <xs:attribute name="degree"/>
    <xs:attribute name="extent"/>
    <xs:attribute name="hand" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: Del contains information deleted, marked as deleted, or otherwise
    indicated as superfluous or spurious in the copy text by an author,
    scribe, annotator, or corrector. The resp attribute contains an ID
    reference to an element containing the name of the editor or
    transcriber responsible for identifying the hand of the deletion. The
    cert attribute signifies the degree of certainty ascribed to the
    identification of the hand of the deletion. The hand of the agent
    which made the deletion should be pointed to using the hand attribute.
    The rend attribute may be used to record the method used to make the
    deletion (overstrike, strike[through], etc.) or how the deleted matter
    should be displayed. 
    Used by: model.transcriptionLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.del" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="del" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.del">
          <xs:attributeGroup ref="attlist.del"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.del">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.trans"/>
    <xs:attribute name="rend"/>
  </xs:attributeGroup>
  <!--
    doc: Indicates a point where material has been omitted in a
    transcription, whether as part of sampling practice or for editorial
    reasons described in the MEI header. When material is omitted because
    it is illegible or inaudible, <unclear> should be used instead.
    Similarly, use <damage> if the omission is due to damage and <del> if
    the omission is because the material is marked as deleted, or
    otherwise indicated as superfluous or spurious in the copy text by an
    author, scribe, annotator, or corrector. An indication of how much
    material has been omitted from the transcription may be recorded in
    the extent attribute. The unit attribute names the unit used for
    describing the extent of the gap. The reason attribute gives the
    reason for omission. Sample values include 'sampling', 'irrelevant',
    'cancelled'. The resp attribute contains an ID reference to an element
    containing the name of the editor, transcriber or encoder responsible
    for the decision not to provide any transcription of the material and
    hence the application of the <gap> tag. 
    Used by: model.editLike 
    Module:  meiEditTrans
  -->
  <xs:element name="gap" substitutionGroup="model.editLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.gap"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.gap">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attribute name="extent"/>
    <xs:attribute name="hand" type="xs:IDREF"/>
    <xs:attribute name="reason"/>
    <xs:attribute name="unit"/>
  </xs:attributeGroup>
  <!--
    doc: Marks the beginning of a passage written in a new hand, or of a
    change in the scribe, writing style, ink or character of the document
    hand. The character attribute describes characteristics of the hand,
    particularly those related to the quality of the writing, e.g.,
    'shaky', 'thick', regular'. A description of the tint or type of ink,
    e.g. 'brown' or the writing medium, e.g. 'pencil', may be placed in
    the medium attribute. The new hand may be identified using the new
    attribute, while the previous hand may be recorded in the old
    attribute. The resp attribute contains an ID reference to an element
    containing the name of the editor or transcriber responsible for
    identifying the change of hand. 
    Used by: model.editLike 
    Module:  meiEditTrans
  -->
  <xs:element name="handshift" substitutionGroup="model.editLike">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.handshift"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.handshift">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attribute name="character"/>
    <xs:attribute name="medium"/>
    <xs:attribute name="new" type="xs:IDREF"/>
    <xs:attribute name="old" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    Used by: model.transcriptionLike model.choicePart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.orig" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="orig" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.orig">
          <xs:attributeGroup ref="attlist.orig"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.orig">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.typed"/>
  </xs:attributeGroup>
  <!--
    Used by: model.transcriptionLike model.choicePart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.reg" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="reg" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.reg">
          <xs:attributeGroup ref="attlist.reg"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.reg">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
  </xs:attributeGroup>
  <!--
    doc: Restore indicates restoration of musical material to an earlier
    state by cancellation of an editorial or authorial marking or
    instruction. The desc (description) attribute gives a prose
    description of the means of restoration, 'stet' or 'strike-down', for
    example. The cert attribute signifies the degree of certainty ascribed
    to the identification of the hand of the restoration. The type
    attribute may be used to indicate the action cancelled by the
    restoration. The resp attribute contains an ID reference to an element
    containing the name of the editor or transcriber responsible for
    identifying the hand of the restoration. The hand attribute signifies
    the hand of the agent which made the restoration. 
    Used by: model.transcriptionLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.restore" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="restore" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.restore">
          <xs:attributeGroup ref="attlist.restore"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.restore">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.trans"/>
    <xs:attributeGroup ref="att.typed"/>
    <xs:attribute name="desc"/>
  </xs:attributeGroup>
  <!--
    doc: Contains apparently incorrect or inaccurate musical material. A
    correction for the apparent error may be given in an accompanying
    child or sibling corr element. 
    Used by: model.transcriptionLike model.choicePart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.sic" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="sic" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.sic">
          <xs:attributeGroup ref="attlist.sic"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.sic">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
  </xs:attributeGroup>
  <!--
    doc: Substitution 
    Used by: model.editLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.subst">
    <xs:sequence>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element maxOccurs="unbounded" ref="model.transcriptionLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="subst" substitutionGroup="model.editLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.subst">
          <xs:attributeGroup ref="attlist.subst"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.subst">
    <xs:attribute name="meiform" default="subst">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="subst"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: Supplied contains musical material supplied by the transcriber or
    editor in place of text which cannot be read, either because of
    physical damage or loss in the original or because it is illegible for
    any reason. When the presumed loss of text arises from an identifiable
    cause, agent signifies the causative agent. When the presumed loss of
    text arises from action (partial deletion, etc.) assignable to an
    identifiable hand, the hand attribute signifies the hand responsible
    for the action. The reason attribute indicates why the text has to be
    supplied, e.g. 'overbinding', 'faded ink', 'lost folio', 'omitted in
    original', etc. The source attribute contains the source of the
    supplied text. 
    Used by: model.transcriptionLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.supplied" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="supplied" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.supplied">
          <xs:attributeGroup ref="attlist.supplied"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.supplied">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attribute name="agent"/>
    <xs:attribute name="reason"/>
  </xs:attributeGroup>
  <!--
    doc: The titlepage element contains a transcription of the title page
    of a text. It may be used within the physdesc element when no other
    transcription is provided. 
    Used by: model.frontPart model.physdescPart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.titlepage">
    <xs:choice maxOccurs="unbounded">
      <xs:element ref="model.textcomponentLike"/>
      <xs:group ref="model.milestoneLike.text"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="titlepage" substitutionGroup="model.frontPart"/>
  <xs:attributeGroup name="attlist.titlepage">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attributeGroup ref="att.lang"/>
  </xs:attributeGroup>
  <!--
    doc: Unclear contains musical material which cannot be transcribed
    with certainty because it is illegible or inaudible in the source.
    Where the difficulty in transcription arises from an identifiable
    cause, the agent attribute signifies the causative agent. The cert
    attribute signifies the degree of certainty ascribed to the
    transcription of the text contained within the <unclear> element.
    Where the difficulty in transcription arises from action (partial
    deletion, etc.) assignable to an identifiable hand, the hand attribute
    signifies the hand responsible for the action. The reason attribute
    indicates why the material is difficult to transcribe. The resp
    attribute indicates the individual responsible for the transcription
    of the word, phrase, or passage contained with the <unclear>
    element. 
    Used by: model.transcriptionLike model.choicePart 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.unclear" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="model.textphraseLike"/>
      <xs:group ref="model.eventLike"/>
      <xs:element ref="model.controleventLike"/>
      <xs:element ref="model.lyricsLike"/>
      <xs:element ref="model.midiLike"/>
      <xs:element ref="model.editLike"/>
      <xs:element ref="model.transcriptionLike"/>
      <xs:element ref="model.eventLike.cmn.measureFilling"/>
      <xs:element ref="model.noteModifierLike"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="unclear" substitutionGroup="model.transcriptionLike">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.unclear">
          <xs:attributeGroup ref="attlist.unclear"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.unclear">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.edit"/>
    <xs:attributeGroup ref="att.facsimile"/>
    <xs:attribute name="agent"/>
    <xs:attribute name="hand" type="xs:IDREF"/>
    <xs:attribute name="reason"/>
  </xs:attributeGroup>
  <!-- Facsimile -->
  <!--
    doc: Facsimile contains a representation of some written source in the
    form of a set of images rather than as transcribed or encoded text. The
    source attribute may be used to link the collection of images with a
    particular source. 
    Used by: model.facsimileLike 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.facsimile">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element ref="model.graphicLike"/>
      <xs:element ref="surface"/>
    </xs:choice>
  </xs:complexType>
  <xs:element name="facsimile" substitutionGroup="model.facsimileLike"/>
  <xs:attributeGroup name="attlist.facsimile">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="source" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: The surface element defines a written surface in terms of a
    rectangular coordinate space, optionally grouping one or more graphic
    representations of that space, and rectangular zones of interest within
    it.
    Used by: zone 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.surface">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="figdesc"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.graphicLike"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="zone"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="surface">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.surface">
          <xs:attributeGroup ref="attlist.surface"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.surface">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.coordinated"/>
    <xs:attribute name="start" type="xs:IDREF"/>
  </xs:attributeGroup>
  <!--
    doc: The zone element defines a rectangular area contained within a
    surface element. 
    Used by: surface 
    Module:  meiEditTrans
  -->
  <xs:complexType name="content.zone">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="figdesc"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.graphicLike"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="zone">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="content.zone">
          <xs:attributeGroup ref="attlist.zone"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.zone">
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.coordinated"/>
  </xs:attributeGroup>
  <!-- Linking and Alignment -->
  <!--
    doc: Timeline provides a set of ordered points in time to which
    musical elements can be linked in order to create a temporal alignment
    of those elements. The origin attribute designates the origin of the
    timeline, i.e. the time at which it begins. It must point to one of
    the when elements in its content. Units specifies the unit of time
    corresponding to the value of the interval attribute of the timeline
    or of its constituent points in time. The mediacontent attribute is
    provided in order to link the timeline to a particular external media
    file, such as an audio file. The medialength attribute specifies the
    length of the external media file in terms of the units attribute. 
    Used by: model.alignLike 
    Module:  meiLinkAlign
  -->
  <xs:complexType name="content.timeline">
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" ref="when"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="timeline" substitutionGroup="model.alignLike"/>
  <xs:attributeGroup name="attlist.timeline">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="mediacontent" type="data.URI"/>
    <xs:attribute name="medialength" type="data.INTEGERPOSITIVE"/>
    <xs:attribute name="origin" use="required" type="xs:IDREF"/>
    <xs:attribute name="units" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!--
    doc: The when element indicates a point in time either absolutely
    (using the absolute attribute), or relative to other elements in the
    same timeline element (using the interval and since attributes).
    The absolute attribute provides an absolute value for the time
    associated with this point. It is required for the element designated
    as the origin by the parent timeline. Unit specifies the unit of time
    in which the @interval value is expressed, if this is not inherited
    from the parent timeline. Interval specifies a positive numeric time
    interval. The since attribute identifies the reference point for
    determining the time of the current when element, which is obtained
    by adding the interval to the time of the reference point. It should
    point to another when element in the same timeline. If this attribute
    is omitted, and the absolute attribute is not specified, then the
    reference point is understood to be the preceding when element. 
    Used by: timeline 
    Module:  meiLinkAlign
  -->
  <xs:element name="when">
    <xs:complexType>
      <xs:attributeGroup ref="attlist.when"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.when">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="absolute"/>
    <xs:attribute name="interval" type="data.NUMBERPOSITIVE"/>
    <xs:attribute name="since" type="xs:IDREF"/>
    <xs:attribute name="unit" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!-- Document elements. -->
  <!--
    doc: The names of the potential document elements, i.e., mei,
    meicorpus, meihead, and music, should not be changed in order to
    assure an absolute minimum level of MEI compliance. The version
    attribute contains the version of the DTD used by the instance. The
    document element for a single document contains a header and data.
  -->
  <xs:element name="mei">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="meihead"/>
        <xs:element ref="music"/>
      </xs:sequence>
      <xs:attributeGroup ref="attlist.mei"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.mei">
    <xs:attribute name="id" type="xs:ID"/>
    <xs:attribute name="version" default="1.9b">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="1.9b"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: The document element for a group of documents, each with its own
    complete header, contains a header for the group, and one or more mei
    elements.
  -->
  <xs:element name="meicorpus">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="meihead"/>
        <xs:element maxOccurs="unbounded" ref="mei"/>
      </xs:sequence>
      <xs:attributeGroup ref="attlist.meicorpus"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.meicorpus">
    <xs:attribute name="id" type="xs:ID"/>
    <xs:attribute name="version" default="1.9b">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="1.9b"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: The meihead element contains general information about the
    encoded file.
  -->
  <xs:element name="meihead">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="altmeiid"/>
        <xs:element ref="filedesc"/>
        <xs:group ref="model.headerPart"/>
        <xs:element minOccurs="0" ref="revisiondesc"/>
      </xs:sequence>
      <xs:attributeGroup ref="attlist.meihead"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.meihead">
    <xs:attributeGroup ref="att.bibl"/>
    <xs:attributeGroup ref="att.common"/>
    <xs:attributeGroup ref="att.lang"/>
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="music"/>
          <xs:enumeration value="corpus"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="version" default="1.9b">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="1.9b"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!--
    doc: This element is a container for everything else in the document
    besides the header. The front and back elements are declared in the
    meiText DTD.
  -->
  <xs:element name="music">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="model.facsimileLike"/>
        <xs:group ref="model.musicPart"/>
      </xs:sequence>
      <xs:attributeGroup ref="attlist.music"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="attlist.music">
    <xs:attributeGroup ref="att.common"/>
    <xs:attribute name="version" default="1.9b">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="1.9b"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
</xs:schema>
