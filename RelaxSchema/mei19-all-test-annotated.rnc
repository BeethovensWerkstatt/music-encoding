namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace xhtml = "http://www.w3.org/1000/xhtml"

include "datatypes.rnc"
[
  xml:id = "att.alignment"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.alignment" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The when attribute indicates a particular kind of correspondence; i.e.,\x{a}" ~
        "          temporal correspondence. It should be used to point to <when>\x{a}" ~
        "          elements within one or more <timeline> elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.alignment = attribute when { xsd:IDREFS }?
}
[
  xml:id = "att.bibl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.bibl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Bibliographic attributes: The analog attribute contains a reference to a\x{a}" ~
        "          field or element in another descriptive encoding system to which an MEI element\x{a}" ~
        "          is comparable. Mapping elements from one system to another may help a repository\x{a}" ~
        "          harvest selected data from the MEI file to build a basic catalog record. The\x{a}" ~
        "          encoding system from which fields are taken must be specified. When possible,\x{a}" ~
        "          subfields as well as fields should be specified, e.g., subfields within MARC\x{a}" ~
        "          fields. A display label for an element can be supplied using the label attribute\x{a}" ~
        "          when a meaningful label cannot be derived by a style sheet from the element name\x{a}" ~
        "          or when a heading element <head> is not available."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.bibl = attribute analog { text }?
}
[
  xml:id = "att.color"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.color" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.color = attribute color { data.COLOR }?
}
[
  xml:id = "att.common.anl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.common.anl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Common analytical attributes: corresp may be used to point to other\x{a}" ~
        "          events or control events that correspond to this event in some\x{a}" ~
        "          fashion."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.common.anl =
    attribute corresp { xsd:IDREFS }?,
    att.alignment
}
[
  xml:id = "att.common"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.common" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Common attributes: Each id within a document must have a unique value.\x{a}" ~
        "          The id attribute regularizes the naming of the element and thus facilitates\x{a}" ~
        "          building links between it and other resources. The n attribute may be used to\x{a}" ~
        "          provide a label (name or number) for the element. This need not be\x{a}" ~
        "          unique."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.common =
    attribute id { xsd:ID }?,
    attribute n { xsd:NMTOKEN }?
}
[
  xml:id = "att.controlevent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.controlevent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Control events rely on other events for their existence. For example, a\x{a}" ~
        "          slur/phrase marking must be drawn between or over a group of notes. The next\x{a}" ~
        "          attribute may be used to point to the next control event(s) in a user-defined\x{a}" ~
        "          collection while the prev attribute may point to the previous event(s). The\x{a}" ~
        "          plist (participant list) attribute may contain ID references or xPointer\x{a}" ~
        "          fragment identifiers (depending on how % PLIST is configured) which identify\x{a}" ~
        "          logical events which participate in the control event, e.g., notes under a\x{a}" ~
        "          phrase mark. The staff and layer attributes allow the control event to encode\x{a}" ~
        "          its scope of influence. The tstamp attribute encodes the onset time of a musical\x{a}" ~
        "          feature in terms of musical time, i.e., beats. The tstamp.ges attribute may be\x{a}" ~
        "          used to record the onset time in pulses per quarter note (ppq, MusicXML\x{a}" ~
        "          divisions, or MIDI clicks) since the start of the measure, while the tstamp.real\x{a}" ~
        "          attribute records the onset time as a real-time offset, i.e., HH:MM:SS.ss, since\x{a}" ~
        "          the beginning of the file."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.controlevent =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute next { xsd:IDREFS }?,
    attribute plist { data.PLIST }?,
    attribute prev { xsd:IDREFS }?,
    attribute staff { data.INTEGERPOSITIVE },
    attribute tstamp { data.BEAT }?,
    attribute tstamp.ges { data.INTEGERNONNEGATIVE }?,
    attribute tstamp.real { data.ISOTIME }?
}
[
  xml:id = "att.coordinated"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.coordinated" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.coordinated =
    attribute ulx { data.INTEGERNONNEGATIVE }?,
    attribute uly { data.INTEGERNONNEGATIVE }?,
    attribute lrx { data.INTEGERNONNEGATIVE }?,
    attribute lry { data.INTEGERNONNEGATIVE }?
}
[
  xml:id = "att.crit"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.crit" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes common to all elements representing variant\x{a}" ~
        "          readings:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.crit =
    attribute cause { xsd:NMTOKEN }?,
    attribute hand { xsd:IDREF }?,
    attribute resp { xsd:IDREF }?,
    attribute seq { data.INTEGERPOSITIVE }?,
    attribute source { xsd:IDREFS }?
}
[
  xml:id = "att.date"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.date" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes common to dates: calendar indicates the system or calendar to\x{a}" ~
        "          which the date belongs, for example, Gregorian, Julian, Roman, Mosaic,\x{a}" ~
        "          Revolutionary, Islamic; cert indicates the degree of precision to be attributed\x{a}" ~
        "          to the date, e.g. ca., approx, after, before, etc.; from contains the starting\x{a}" ~
        "          point of a date range; notafter should contain an upper boundary for an\x{a}" ~
        "          uncertain date while notbefore should contain a lower boundary, e.g,\x{a}" ~
        "          <date notbefore='1957' notafter='1960'>Feb.\x{a}" ~
        "          5</date>; reg gives the value of the date in standard ISO form; to\x{a}" ~
        "          contains the end point of a date range."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.date =
    attribute calendar { xsd:NMTOKEN }?,
    attribute cert { data.CERTAINTY }?,
    attribute from { data.ISODATE }?,
    attribute notafter { data.ISODATE }?,
    attribute notbefore { data.ISODATE }?,
    attribute reg { data.ISODATE }?,
    attribute to { data.ISODATE }?
}
[
  xml:id = "att.edit"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.edit" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes describing the nature of an encoded scholarly intervention or\x{a}" ~
        "          interpretation: cert signifies the degree of certainty associated with the\x{a}" ~
        "          intervention or interpretation. evidence indicates the nature of the evidence\x{a}" ~
        "          supporting the reliability or accuracy of the intervention or interpretation.\x{a}" ~
        "          Suggested values include: 'internal', 'external', 'conjecture'. The resp\x{a}" ~
        "          attribute indicates responsibility for the identification or content within the\x{a}" ~
        "          element to which it is attached. It must point to one of the identifiers\x{a}" ~
        "          declared in the document header, associated with a person asserted as\x{a}" ~
        "          responsible for some aspect of the text's creation, transcription, editing, or\x{a}" ~
        "          encoding. The source attribute contains a list of one or more pointers\x{a}" ~
        "          indicating the sources which support the given reading."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.edit =
    attribute cert { data.CERTAINTY }?,
    attribute evidence { xsd:NMTOKEN }?,
    attribute resp { xsd:IDREFS }?,
    attribute source { xsd:IDREFS }?
}
[
  xml:id = "att.event"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.event" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes that apply to all written events, e.g. beam, beatrpt, chord,\x{a}" ~
        "          note, etc. The tstamp attribute encodes the onset time of a musical feature in\x{a}" ~
        "          terms of musical time, i.e., beats. The tstamp.ges attribute may be used to\x{a}" ~
        "          record the onset time in pulses per quarter note (ppq, MusicXML divisions, or\x{a}" ~
        "          MIDI clicks) since the start of the measure, while the tstamp.real attribute\x{a}" ~
        "          records the onset time as a real-time offset, i.e., HH:MM:SS.ss, since the\x{a}" ~
        "          beginning of the file."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.event =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute next { xsd:IDREFS }?,
    attribute prev { xsd:IDREFS }?,
    attribute staff { data.INTEGERPOSITIVE }?,
    attribute tstamp { data.BEAT }?,
    attribute tstamp.ges { data.INTEGERNONNEGATIVE }?,
    attribute tstamp.real { data.ISOTIME }?
}
[
  xml:id = "att.facsimile"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.facsimile" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "All elements subscribing to this class may include one or more ID\x{a}" ~
        "          references to an image or to an image zone which corresponds with the\x{a}" ~
        "          element."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.facsimile = attribute facs { xsd:IDREFS }?
}
[
  xml:id = "att.link.common"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.link.common" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes common to all linking elements: actuate defines whether a link\x{a}" ~
        "          occurs automatically or must be requested by the user. It is used in conjunction\x{a}" ~
        "          with the show attribute to determine link behavior. show defines whether a\x{a}" ~
        "          remote resource that is the target of a link appears at the point of the link,\x{a}" ~
        "          replaces the existing link, or appears in a new window. The targettype attribute\x{a}" ~
        "          allows the target resource to be characterized, using any convenient\x{a}" ~
        "          classification scheme or typology."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.link.common =
    attribute actuate { "onLoad" | "onRequest" | "other" | "none" }?,
    attribute show { "new" | "replace" | "other" | "none" }?,
    attribute targettype { xsd:NMTOKEN }?
}
[
  xml:id = "att.link.external"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.link.external" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Linking attributes for external referencing elements: entityref\x{a}" ~
        "          references a previously-declared entity which represents a complete document.\x{a}" ~
        "          The href attribute allows the use of an undeclared URI. The fragment attribute\x{a}" ~
        "          allows one to identify one or more sub-parts within the document being pointed\x{a}" ~
        "          to."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.link.external =
    attribute entityref { xsd:ENTITY }?,
    attribute fragment { data.FRAGMENT }?,
    attribute href { data.URI }?
}
[
  xml:id = "att.link.internal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.link.internal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Linking attributes for internal referencing elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.link.internal = attribute plist { data.PLIST }?
}
[
  xml:id = "att.name"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.name" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes shared by names: The dbkey attribute may be used to record a\x{a}" ~
        "          value which serves as a primary key in an external database. The reg attribute\x{a}" ~
        "          may be used to record a regularized form of the name."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.name =
    attribute key { xsd:NMTOKEN }?,
    attribute reg { text }?
}
[
  xml:id = "att.startendid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.startendid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Start and end attributes record the IDs of other elements to which the\x{a}" ~
        "          current element is associated."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.startendid =
    attribute endid { xsd:IDREF }?,
    attribute startid { xsd:IDREF }?
}
[
  xml:id = "att.lang"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.lang" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes common to text elements: The lang attribute should be used to\x{a}" ~
        "          identify the language of the word or text phrase marked. Its value must be the\x{a}" ~
        "          identifier of a <language> element supplied in the MEI header of\x{a}" ~
        "          the current document."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.lang = attribute lang { xsd:IDREF }?
}
[
  xml:id = "att.trans"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.trans" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes for elements encoding authorial or scribal intervention when\x{a}" ~
        "          transcribing manuscript or similar sources: The hand attribute signifies the\x{a}" ~
        "          hand of the agent which made the intervention. Its value must be the ID of hand\x{a}" ~
        "          element declared in the header. The seq attribute may be used to assign a\x{a}" ~
        "          sequence number related to the order in which the encoded features carrying this\x{a}" ~
        "          attribute are believed to have occurred."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.trans =
    attribute hand { xsd:IDREF }?,
    attribute seq { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.typed"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.typed" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes which can be used to classify or subclassify elements in any\x{a}" ~
        "          way"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.typed =
    attribute subtype { xsd:NMTOKEN }?,
    attribute type { xsd:NMTOKEN }?
}
[
  xml:id = "att.typography"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.typography" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Typographical attributes" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.typography =
    attribute fontfam { data.FONTFAMILY }?,
    attribute fontname { data.FONTNAME }?,
    attribute fontsize { data.NUMBER }?,
    attribute fontstyle { data.FONTSTYLE }?,
    attribute fontweight { data.FONTWEIGHT }?
}
[
  xml:id = "att.visualoffset"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.visualoffset" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Some items may have their location recorded in terms of offsets from\x{a}" ~
        "          their programmatically-determined location. The ho attribute records the\x{a}" ~
        "          horizontal offset while vo records the vertical. The to attribute holds a\x{a}" ~
        "          timestamp offset, the most common use of which is as an alternative to\x{a}" ~
        "          ho."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.visualoffset =
    attribute ho { data.VISUALOFFSET }?,
    attribute to { data.TSTAMPOFFSET }?,
    attribute vo { data.VISUALOFFSET }?
}
[
  xml:id = "att.xy"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.xy" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'Some elements may have their exact "output" coordinates recorded: x and y\x{a}' ~
        "          indicate where to place the rendered output. Recording the coordinates of a\x{a}" ~
        "          feature in a facsimile requires the use of the facs attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.xy =
    attribute x { data.NUMBER }?,
    attribute y { data.NUMBER }?
}
[
  xml:id = "att.xy.required"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.xy.required" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.xy.required =
    attribute x { data.NUMBER },
    attribute y { data.NUMBER }
}
[
  xml:id = "att.xy2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.xy2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Some elements need 2 coordinate pairs" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.xy2 =
    attribute x2 { data.NUMBER }?,
    attribute y2 { data.NUMBER }?
}
[
  xml:id = "att.xy2.required"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.xy2.required" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.xy2.required =
    attribute x2 { data.NUMBER },
    attribute y2 { data.NUMBER }
}
[
  xml:id = "att.anl.barline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.barline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.barline = att.common.anl
}
[
  xml:id = "att.ges.barline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.barline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.barline = attribute tstamp { text }?
}
[
  xml:id = "att.log.barline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.barline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.barline =
    attribute complete { "c" | "i" | "o" }?,
    attribute control { data.BOOLEAN }?,
    attribute measref { xsd:IDREF }?,
    attribute rend { data.BARRENDITION }?
}
[
  xml:id = "att.vis.barline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.barline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.barline =
    att.color,
    attribute barplace { data.BARPLACE }?,
    attribute taktplace { data.STAFFLOC }?,
    attribute width { data.NUMBER }?
}
[
  xml:id = "att.anl.clef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.clef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.clef = att.common.anl
}
[
  xml:id = "att.ges.clef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.clef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.clef = empty
}
[
  xml:id = "att.log.clef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.clef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.clef =
    attribute line { data.CLEFLINE },
    attribute octave.default { data.OCTAVE }?,
    attribute shape { data.CLEFSHAPE },
    attribute trans { data.CLEFTRAN }?
}
[
  xml:id = "att.vis.clef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.clef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.clef =
    att.color,
    attribute altsym { xsd:IDREF }?
}
[
  xml:id = "att.log.custos"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.custos" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The pname and oct attributes identify the\x{a}" ~
        "          location where the custos appears. This is usually, but not always, the same as\x{a}" ~
        "          the target pitch. The target pitch may be referenced using the target\x{a}" ~
        "          attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.custos =
    attribute oct { data.OCTAVE },
    attribute pname { data.PITCHNAME },
    attribute source { xsd:IDREF }?,
    attribute target { xsd:IDREF }?
}
[
  xml:id = "att.vis.custos"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.custos" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The rend attribute indicates whether hash marks\x{a}" ~
        "          should be rendered between systems. See Read, p. 436, ex. 26-3."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.custos = att.color
}
[
  xml:id = "att.anl.dot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.dot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.dot = att.common.anl
}
[
  xml:id = "att.ges.dot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.dot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.dot = empty
}
[
  xml:id = "att.log.dot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.dot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.dot =
    attribute form { "aug" | "div" }?,
    attribute loc { data.STAFFLOC }?
}
[
  xml:id = "att.vis.dot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.dot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.dot = att.color, att.xy
}
[
  xml:id = "att.anl.ending"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.ending" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.ending = att.common.anl
}
[
  xml:id = "att.ges.ending"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.ending" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.ending = empty
}
[
  xml:id = "att.log.ending"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.ending" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.ending = empty
}
[
  xml:id = "att.vis.ending"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.ending" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.ending = empty
}
[
  xml:id = "att.anl.grpsym"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.grpsym" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.grpsym = att.common.anl
}
[
  xml:id = "att.ges.grpsym"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.grpsym" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.grpsym = empty
}
[
  xml:id = "att.log.grpsym"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.grpsym" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The staves attribute must be used when\x{a}" ~
        "          multiple grpsym elements are present. The label.* attributes should be used\x{a}" ~
        "          instead of n."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.grpsym =
    attribute barthru { data.BOOLEAN }?,
    attribute label.abbr { text }?,
    attribute label.full { text }?,
    attribute start { text },
    attribute end { text },
    attribute symbol { "brace" | "bracket" | "line" }
}
[
  xml:id = "att.vis.grpsym"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.grpsym" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.grpsym = att.visualoffset, att.xy
}
[
  xml:id = "att.anl.ineume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.ineume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.ineume = att.common.anl
}
[
  xml:id = "att.ges.ineume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.ineume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.ineume = empty
}
[
  xml:id = "att.log.ineume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.ineume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.ineume =
    attribute form { data.INEUMEFORM }?,
    attribute name { data.INEUMENAME }?
}
[
  xml:id = "att.vis.ineume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.ineume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.ineume = att.color
}
[
  xml:id = "att.anl.layer"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.layer" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.layer = att.common.anl
}
[
  xml:id = "att.ges.layer"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.layer" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.layer = empty
}
[
  xml:id = "att.log.layer"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.layer" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.layer = empty
}
[
  xml:id = "att.vis.layer"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.layer" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.layer = attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.layerdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.layerdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.layerdef = empty
}
[
  xml:id = "att.ges.layerdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.layerdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.layerdef =
    attribute grace { data.GRACE }?,
    attribute midi.channel { data.MIDICHANNEL }?,
    attribute midi.duty { data.PERCENT }?,
    attribute midi.instr { data.MIDIVALUE }?,
    attribute midi.instrname { text }?,
    attribute midi.port { data.MIDIVALUE }?,
    attribute midi.track { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.log.layerdef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.layerdef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The n attribute is provided for explicit layer\x{a}" ~
        "          numbering."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.layerdef.mensural = empty
}
[
  xml:id = "att.log.layerdef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.layerdef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.layerdef.base =
    attribute beam.group { text }?,
    attribute beam.rests { data.BOOLEAN }?,
    attribute dur.default { data.DURATIONS }?,
    attribute octave.default { data.OCTAVE }?
}
[
  xml:id = "att.log.layerdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.layerdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.layerdef = att.log.layerdef.base, att.log.layerdef.mensural
}
[
  xml:id = "att.vis.layerdef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.layerdef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.layerdef.mensural = empty
}
[
  xml:id = "att.vis.layerdef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.layerdef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.layerdef.base =
    attribute beam.rend { "acc" | "rit" | "norm" }?,
    attribute beam.slope { data.NUMBER }?,
    attribute slur.rend { data.CURVERENDITION }?,
    attribute text.fam { data.FONTFAMILY }?,
    attribute text.name { data.FONTNAME }?,
    attribute text.size { data.NUMBER }?,
    attribute text.style { data.FONTSTYLE }?,
    attribute text.weight { data.FONTWEIGHT }?,
    attribute tie.rend { data.CURVERENDITION }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.vis.layerdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.layerdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.layerdef = att.vis.layerdef.base, att.vis.layerdef.mensural
}
[
  xml:id = "att.anl.ligature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.ligature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.ligature = att.common.anl
}
[
  xml:id = "att.ges.ligature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.ligature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.ligature = empty
}
[
  xml:id = "att.log.ligature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.ligature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.ligature = attribute form { data.LIGATUREFORM }?
}
[
  xml:id = "att.vis.ligature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.ligature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.ligature = empty
}
[
  xml:id = "att.anl.mensur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mensur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mensur = att.common.anl
}
[
  xml:id = "att.ges.mensur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mensur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mensur = empty
}
[
  xml:id = "att.log.mensur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mensur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mensur =
    attribute modusmaior { "2" | "3" }?,
    attribute modusminor { "2" | "3" }?,
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.INTEGERPOSITIVE }?,
    attribute prolatio { "2" | "3" }?,
    attribute tempus { "2" | "3" }?
}
[
  xml:id = "att.vis.mensur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mensur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mensur =
    att.color,
    attribute dot { data.BOOLEAN }?,
    attribute form { "horizontal" | "vertical" }?,
    attribute loc { data.STAFFLOC }?,
    attribute orient { "reversed" | "90CW" | "90CCW" }?,
    attribute sign { data.MENSURATIONSIGN }?,
    attribute size { data.SIZE }?,
    attribute slash { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.anl.proport"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.proport" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.proport = att.common.anl
}
[
  xml:id = "att.ges.proport"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.proport" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.proport = empty
}
[
  xml:id = "att.log.proport"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.proport" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.proport =
    attribute num { data.INTEGERPOSITIVE },
    attribute numbase { data.INTEGERPOSITIVE }
}
[
  xml:id = "att.vis.proport"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.proport" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.proport = empty
}
[
  xml:id = "att.anl.part"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.part" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.part = att.common.anl
}
[
  xml:id = "att.ges.part"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.part" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.part = empty
}
[
  xml:id = "att.log.part"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.part" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The n attribute allows explicit numbering of\x{a}" ~
        "          parts."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.part = empty
}
[
  xml:id = "att.vis.part"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.part" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.part = empty
}
[
  xml:id = "att.anl.parts"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.parts" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.parts = att.common.anl
}
[
  xml:id = "att.ges.parts"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.parts" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.parts = empty
}
[
  xml:id = "att.log.parts"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.parts" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.parts = empty
}
[
  xml:id = "att.vis.parts"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.parts" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.parts = empty
}
[
  xml:id = "att.anl.rdg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.rdg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The priority attribute is available so that\x{a}" ~
        "          variant readings may be assigned an order, e.g., for selection and/or rendering\x{a}" ~
        "          purposes, other than the encoded order. The resp attribute identifies the editor\x{a}" ~
        "          responsible for asserting this reading in the source."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.rdg = att.common.anl
}
[
  xml:id = "att.ges.rdg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.rdg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.rdg = empty
}
[
  xml:id = "att.log.rdg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.rdg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The expan attribute contains a list of ids of\x{a}" ~
        "          child section, ending or app elements. This 'expansion list' indicates how the\x{a}" ~
        "          section should be expanded into its 'through-composed' form."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.rdg = attribute expan { xsd:IDREFS }?
}
[
  xml:id = "att.vis.rdg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.rdg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.rdg = empty
}
[
  xml:id = "att.anl.sb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.sb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.sb = att.common.anl
}
[
  xml:id = "att.ges.sb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.sb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.sb = empty
}
[
  xml:id = "att.log.sb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.sb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Adding the following attributes: leftmar %data.NUMBER; #IMPLIED rightmar\x{a}" ~
        "          %data.NUMBER; #IMPLIED spacing.staff %data.NUMBER; #IMPLIED to a.log.sb would\x{a}" ~
        "          make it possible to record layout changes without requiring them to be at\x{a}" ~
        "          section boundaries."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.sb = attribute source { xsd:IDREFS }?
}
[
  xml:id = "att.vis.sb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.sb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The rend attribute indicates whether hash marks\x{a}" ~
        "          should be rendered between systems. See Read, p. 436, ex. 26-3."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.sb = attribute rend { "hash" }?
}
[
  xml:id = "att.anl.score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.score" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.score = att.common.anl
}
[
  xml:id = "att.ges.score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.score" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.score = empty
}
[
  xml:id = "att.log.score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.score" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.score = empty
}
[
  xml:id = "att.vis.score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.score" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.score = empty
}
[
  xml:id = "att.anl.scoredef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.scoredef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: Since the score element carries analytical\x{a}" ~
        "          attributes for the score, it is unlikely a.anl.scoredef will ever be\x{a}" ~
        "          used."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.scoredef = empty
}
[
  xml:id = "att.ges.scoredef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.scoredef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: Definitions and suggested default values:\x{a}" ~
        "          grace do grace notes get time from the current (acc) or previous (unacc) main\x{a}" ~
        "          note? 'acc' midi.channel '1' midi.div MIDI pulses per quarter note '96'\x{a}" ~
        "          midi.duty specifies the 'on' part of the duty cycle as a percentage. '80'\x{a}" ~
        "          midi.instr General MIDI instrument number '1' midi.instrname General MIDI\x{a}" ~
        "          instrument name 'Acoustic Piano' midi.port MIDI port number '1' midi.tempo\x{a}" ~
        "          quarter notes per minute '120' midi.track MIDI track number '1' tempo beats per\x{a}" ~
        "          minute '120' tune.pname name of tuning reference pitch 'a' tune.Hz frequency of\x{a}" ~
        "          tuning reference pitch '440' tune.temper temperament 'equal'"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.scoredef =
    attribute grace { data.GRACE }?,
    attribute midi.channel { data.MIDICHANNEL }?,
    attribute midi.div { data.INTEGERPOSITIVE }?,
    attribute midi.duty { data.PERCENT }?,
    attribute midi.instr { data.MIDIVALUE }?,
    attribute midi.instrname { text }?,
    attribute midi.port { data.MIDIVALUE }?,
    attribute midi.tempo { data.MIDITEMPO }?,
    attribute midi.track { data.INTEGERPOSITIVE }?,
    attribute tempo { data.TEMPOVALUE }?,
    attribute tune.pname { data.PITCHNAME }?,
    attribute tune.Hz { data.NUMBER }?,
    attribute tune.temper { data.TEMPERAMENT }?
}
[
  xml:id = "att.log.scoredef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.scoredef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: beam.group an example of how beaming\x{a}" ~
        "          (including secondary beams) is to be done, e.g. (4.,4.,4.) indicates one outer\x{a}" ~
        "          beam per measure with secondary beams broken at each dotted quarter duration, no\x{a}" ~
        "          default beam.rests should beams include rests shorter than a quarter duration?,\x{a}" ~
        "          'no' clef.line position of the clef, '2' clef.shape clef, 'G' clef.trans octave\x{a}" ~
        "          shift indicated by the clef, '0' dur.default default duration, '4' key.accid\x{a}" ~
        "          tonic accidental, i.e., 's' or 'f', no default key.mode mode, 'major' key.pname\x{a}" ~
        "          tonic pitchname, no default key.sig effective key signature, no default\x{a}" ~
        "          key.sig.mixed key signature contains both sharps and flats, no default\x{a}" ~
        "          meter.count number of beats per measure, top number of the meter sig, no default\x{a}" ~
        "          meter.sym display a symbol, e.g. C, instead of numbers, like 4/4, no default\x{a}" ~
        "          meter.unit beat unit, bottom number of the meter sig, no default octave.default\x{a}" ~
        "          default octave when octave isn't specified on the first note of the measure, '4'\x{a}" ~
        "          trans.diat amount of diatonic pitch shift, e.g. C to C# = 0, C to Db = 1, '0'\x{a}" ~
        "          trans.semi amount of pitch shift in semitones, e.g. C to C# = 1, C to Db = 1,\x{a}" ~
        "          '0'. (Transposition requires both trans.diat and trans.semi.)"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.scoredef.mensural =
    attribute mensur { data.MENSURATIONSIGN }?,
    attribute mensur.dot { data.BOOLEAN }?,
    attribute mensur.slash { data.INTEGERPOSITIVE }?,
    attribute modusmaior { "2" | "3" }?,
    attribute modusminor { "2" | "3" }?,
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.INTEGERPOSITIVE }?,
    attribute prolatio { "2" | "3" }?,
    attribute proport.num { data.INTEGERPOSITIVE }?,
    attribute proport.numbase { data.INTEGERPOSITIVE }?,
    attribute tempus { "2" | "3" }?
}
[
  xml:id = "att.log.scoredef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.scoredef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.scoredef.base =
    attribute beam.group { text }?,
    attribute beam.rests { data.BOOLEAN }?,
    attribute clef.line { data.CLEFLINE }?,
    attribute clef.shape { data.CLEFSHAPE }?,
    attribute clef.trans { data.CLEFTRAN }?,
    attribute dur.default { data.DURATIONS }?,
    attribute key.accid { data.ACCIDENTAL.IMPLICIT }?,
    attribute key.mode { data.MODE }?,
    attribute key.pname { data.PITCHNAME }?,
    attribute key.sig { data.KEYSIGNATURE }?,
    attribute key.sig.mixed { text }?,
    attribute meter.count { data.NUMBER }?,
    attribute meter.sym { data.METERSIGN }?,
    attribute meter.unit { data.NUMBER }?,
    attribute octave.default { data.OCTAVE }?,
    attribute trans.diat { data.NUMBER }?,
    attribute trans.semi { data.NUMBER }?
}
[
  xml:id = "att.log.scoredef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.scoredef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.scoredef = att.log.scoredef.base, att.log.scoredef.mensural
}
[
  xml:id = "att.vis.scoredef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.scoredef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: Definitions and suggested software default\x{a}" ~
        "          values: mnum.visible are measure numbers visible?, 'no' bar.place placement of\x{a}" ~
        "          barlines, 'norm' beam.rend encodes whether a beam is feathered and in which\x{a}" ~
        "          direction, 'norm' beam.slope default beam slope, Mup uses '1.0, 25.0' clef.color\x{a}" ~
        "          hexadecimal RGB/name color value clef.visible are clefs visible?, 'yes'\x{a}" ~
        "          dynam.dist how far from staff to render dynamic marks, '2' ending.rend where to\x{a}" ~
        "          draw ending marks, 'top' grid.show display chord grids?, 'no' harm.dist how far\x{a}" ~
        "          from staff to render harmony, '2' key.sig.show display key signature?, 'yes'\x{a}" ~
        "          key.sig.showchange display cautionary key signature change?, 'yes' lyric.align\x{a}" ~
        "          alignment of lyrics beneath notes, Mup uses '0.25' lyric.fam font family for\x{a}" ~
        "          lyrics, 'times' lyric.name font name for lyrics, 'rom' lyric.size point size of\x{a}" ~
        "          lyrics, '12' meter.rend display meter normally (3/4), with symbol as denom, or\x{a}" ~
        "          invis, 'norm' meter.sig.showchange display cautionary meter signature change?,\x{a}" ~
        "          'yes' ontheline governs display of notes on a 1-line staff, 'yes' optimize\x{a}" ~
        "          display only those staves with notes?, 'no' ** page.* attributes apply to the\x{a}" ~
        "          entire score/part page.height height of page, '11' page.width width of page,\x{a}" ~
        "          '8.5' page.units real-world measurement (inches, centimeters, millimeters), 'in'\x{a}" ~
        "          page.topmar top page margin, '1' page.botmar bottom page margin, '1'\x{a}" ~
        "          page.leftmar left page margin, '.5' page.rightmar right page margin, '.5'\x{a}" ~
        "          page.panels number of logical pages to place on physical page, '1' page.scale\x{a}" ~
        "          scale printed output by the specified percentage, '100' pedal.rend are piano\x{a}" ~
        "          pedal marks drawn as lines or as terms (e.g. 'Ped.' & '*'), 'term'\x{a}" ~
        "          reh.enclose default look of rehearsal letters/numbers, 'box' slur.rend default\x{a}" ~
        "          look of slurs, 'medium' spacing.packexp note spacing relative to its time value,\x{a}" ~
        "          '0.8' spacing.packfact note spacing of output, '1' spacing.staff minimum amount\x{a}" ~
        "          of space between staves in the same system, '2' spacing.system minimum and\x{a}" ~
        "          maximum amount of space between systems, '12, 20' system.leftmar left system\x{a}" ~
        "          margin relative to page.leftmar, '0' system.rightmar right system margin\x{a}" ~
        "          relative to page.rightmar, '0' system.topmar distance from page's top edge to\x{a}" ~
        "          the first system, used for first page only text.dist how far from staff to\x{a}" ~
        "          render text, '2' text.fam font family for text, 'times' text.nam font name for\x{a}" ~
        "          text, 'rom' text.size point size of text, '12' tie.rend default look of ties,\x{a}" ~
        "          'medium'"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.scoredef.mensural =
    attribute mensur.form { "horizontal" | "vertical" }?,
    attribute mensur.loc { data.INTEGERPOSITIVE }?,
    attribute mensur.orient { "reversed" | "90CW" | "90CCW" }?,
    attribute mensur.size { data.SIZE }?
}
[
  xml:id = "att.vis.scoredef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.scoredef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.scoredef.base =
    attribute bar.place { data.BARPLACE }?,
    attribute beam.rend { "acc" | "rit" | "norm" }?,
    attribute beam.slope { data.NUMBER }?,
    attribute clef.color { data.COLOR }?,
    attribute clef.visible { data.BOOLEAN }?,
    attribute dynam.dist { data.NUMBER }?,
    attribute ending.rend { "top" | "barred" | "grouped" }?,
    attribute grid.show { data.BOOLEAN }?,
    attribute harm.dist { data.NUMBER }?,
    attribute key.sig.show { data.BOOLEAN }?,
    attribute key.sig.showchange { data.BOOLEAN }?,
    attribute lyric.align { data.NUMBER }?,
    attribute lyric.fam { data.FONTFAMILY }?,
    attribute lyric.name { data.FONTNAME }?,
    attribute lyric.size { data.NUMBER }?,
    attribute lyric.style { data.FONTSTYLE }?,
    attribute lyric.weight { data.FONTWEIGHT }?,
    attribute meter.rend { "denomsym" | "norm" | "invis" }?,
    attribute meter.sig.showchange { data.BOOLEAN }?,
    attribute mnum.visible { data.BOOLEAN }?,
    attribute multi.number { data.BOOLEAN }?,
    attribute music.name { data.MUSICFONT }?,
    attribute music.size { data.NUMBER }?,
    attribute ontheline { data.BOOLEAN }?,
    attribute optimize { data.BOOLEAN }?,
    attribute page.height { data.NUMBER }?,
    attribute page.width { data.NUMBER }?,
    attribute page.units { data.PGUNITS }?,
    attribute page.topmar { data.NUMBER }?,
    attribute page.botmar { data.NUMBER }?,
    attribute page.leftmar { data.NUMBER }?,
    attribute page.rightmar { data.NUMBER }?,
    attribute page.panels { "1" | "2" }?,
    attribute page.scale { data.PGSCALE }?,
    attribute pedal.rend { "line" | "term" }?,
    attribute reh.enclose { "box" | "circle" | "none" }?,
    attribute slur.rend { data.CURVERENDITION }?,
    attribute spacing.packexp { data.NUMBER }?,
    attribute spacing.packfact { data.NUMBER }?,
    attribute spacing.staff { data.NUMBER }?,
    attribute spacing.system { text }?,
    attribute system.leftmar { data.NUMBER }?,
    attribute system.rightmar { data.NUMBER }?,
    attribute system.topmar { data.NUMBER }?,
    attribute text.dist { data.NUMBER }?,
    attribute text.fam { data.FONTFAMILY }?,
    attribute text.name { data.FONTNAME }?,
    attribute text.size { data.NUMBER }?,
    attribute text.style { data.FONTSTYLE }?,
    attribute text.weight { data.FONTWEIGHT }?,
    attribute tie.rend { data.CURVERENDITION }?
}
[
  xml:id = "att.vis.scoredef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.scoredef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.scoredef = att.vis.scoredef.base, att.vis.scoredef.mensural
}
[
  xml:id = "att.anl.section"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.section" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.section = att.common.anl
}
[
  xml:id = "att.ges.section"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.section" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: The expan attribute contains a list of ids of\x{a}" ~
        "          child section, ending or app elements. This 'expansion list' indicates how the\x{a}" ~
        "          section should be expanded into its 'through-composed' form. See Read, p. 226\x{a}" ~
        "          (ex. 12-10), 228-229 (ex. 12-16)."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.section = attribute expan { xsd:IDREFS }?
}
[
  xml:id = "att.log.section"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.section" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.section = empty
}
[
  xml:id = "att.vis.section"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.section" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.section = empty
}
[
  xml:id = "att.anl.staff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.staff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.staff = att.common.anl
}
[
  xml:id = "att.ges.staff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.staff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.staff = empty
}
[
  xml:id = "att.log.staff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.staff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.staff = empty
}
[
  xml:id = "att.vis.staff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.staff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.staff = attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.staffdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.staffdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.staffdef = empty
}
[
  xml:id = "att.ges.staffdef.tablature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.staffdef.tablature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: Adding tune.pname, tune.Hz, and tune.temper\x{a}" ~
        "          attributes here would allow each staff to establish its own tuning\x{a}" ~
        "          standard."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.staffdef.tablature = attribute tab.strings { text }?
}
[
  xml:id = "att.ges.staffdef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.staffdef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.staffdef.base =
    attribute grace { data.GRACE }?,
    attribute midi.channel { data.MIDICHANNEL }?,
    attribute midi.div { data.INTEGERPOSITIVE }?,
    attribute midi.duty { data.PERCENT }?,
    attribute midi.instr { data.MIDIVALUE }?,
    attribute midi.instrname { text }?,
    attribute midi.port { data.MIDIVALUE }?,
    attribute midi.track { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.ges.staffdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.staffdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.staffdef = att.ges.staffdef.base, att.ges.staffdef.tablature
}
[
  xml:id = "att.log.staffdef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.staffdef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The n attribute is provided for explicit staff\x{a}" ~
        "          numbering."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.staffdef.mensural =
    attribute mensur.sign { data.MENSURATIONSIGN }?,
    attribute mensur.dot { data.BOOLEAN }?,
    attribute mensur.slash { data.INTEGERPOSITIVE }?,
    attribute modusmaior { "2" | "3" }?,
    attribute modusminor { "2" | "3" }?,
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.INTEGERPOSITIVE }?,
    attribute prolatio { "2" | "3" }?,
    attribute proport.num { data.INTEGERPOSITIVE }?,
    attribute proport.numbase { data.INTEGERPOSITIVE }?,
    attribute tempus { "2" | "3" }?
}
[
  xml:id = "att.log.staffdef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.staffdef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.staffdef.base =
    attribute beam.group { text }?,
    attribute beam.rests { data.BOOLEAN }?,
    attribute clef.line { data.CLEFLINE }?,
    attribute clef.shape { data.CLEFSHAPE }?,
    attribute clef.trans { data.CLEFTRAN }?,
    attribute dur.default { data.DURATIONS }?,
    attribute key.accid { data.ACCIDENTAL.IMPLICIT }?,
    attribute key.mode { data.MODE }?,
    attribute key.pname { data.PITCHNAME }?,
    attribute key.sig { data.KEYSIGNATURE }?,
    attribute key.sig.mixed { text }?,
    attribute meter.count { data.NUMBER }?,
    attribute meter.sym { data.METERSIGN }?,
    attribute meter.unit { data.NUMBER }?,
    attribute octave.default { data.OCTAVE }?,
    attribute trans.diat { data.NUMBER }?,
    attribute trans.semi { data.NUMBER }?
}
[
  xml:id = "att.log.staffdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.staffdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.staffdef = att.log.staffdef.base, att.log.staffdef.mensural
}
[
  xml:id = "att.vis.staffdef.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.staffdef.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: It is a semantic error if the clef.shape,\x{a}" ~
        "          clef.line, key.sig, meter.count, and meter.unit attributes are not supplied or\x{a}" ~
        "          are not available from a scoredef ancestor. The layerscheme attribute indicates\x{a}" ~
        "          the number of layers and the stem direction. The lines attribute indicates the\x{a}" ~
        "          number of stafflines. The lines.color attribute is structured; that is, it\x{a}" ~
        "          should have the same number of space-separated RGB values as indicated by the\x{a}" ~
        "          lines attribute. A line can be made invisible by assigning it the same RGB value\x{a}" ~
        "          as the background, usually white. The tab.strings attribute lists a written\x{a}" ~
        '          pitch and octave for each open string, e.g. "e3 a3 d4 g4 b4 e5" for standard\x{a}' ~
        "          guitar tuning. It should contain the number of tokens indicated by the lines\x{a}" ~
        "          attribute. Chromatic alteration may be indicated with '-' (flat) and '#'\x{a}" ~
        "          (sharp). Double sharps and flats are not permitted. The spacing attribute should\x{a}" ~
        "          be used to record the absolute distance (as opposed to the relative distances\x{a}" ~
        "          recorded in scoredef elements) between this staff and the preceding one in the\x{a}" ~
        "          same system. This value is meaningless for the first staff in a system since the\x{a}" ~
        "          spacing.system attribute indicates the spacing between systems."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.staffdef.mensural =
    attribute mensur.form { "horizontal" | "vertical" }?,
    attribute mensur.loc { data.INTEGERPOSITIVE }?,
    attribute mensur.orient { "reversed" | "90CW" | "90CCW" }?,
    attribute mensur.size { data.SIZE }?
}
[
  xml:id = "att.vis.staffdef.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.staffdef.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.staffdef.base =
    attribute beam.rend { "acc" | "rit" | "norm" }?,
    attribute beam.slope { data.NUMBER }?,
    attribute clef.color { data.COLOR }?,
    attribute clef.visible { data.BOOLEAN }?,
    attribute dynam.dist { data.NUMBER }?,
    attribute grid.show { data.BOOLEAN }?,
    attribute harm.dist { data.NUMBER }?,
    attribute key.sig.show { data.BOOLEAN }?,
    attribute key.sig.showchange { data.BOOLEAN }?,
    attribute label.full { text }?,
    attribute label.abbr { text }?,
    attribute layerscheme { data.LAYERSCHEME }?,
    attribute lines { data.INTEGERPOSITIVE }?,
    attribute lines.color { xsd:NMTOKENS }?,
    attribute lines.visible { data.BOOLEAN }?,
    attribute lyric.align { data.NUMBER }?,
    attribute lyric.fam { data.FONTFAMILY }?,
    attribute lyric.name { data.FONTNAME }?,
    attribute lyric.size { data.NUMBER }?,
    attribute lyric.style { data.FONTSTYLE }?,
    attribute lyric.weight { data.FONTWEIGHT }?,
    attribute meter.rend { "denomsym" | "norm" | "invis" }?,
    attribute meter.sig.showchange { data.BOOLEAN }?,
    attribute multi.number { data.BOOLEAN }?,
    attribute ontheline { data.BOOLEAN }?,
    attribute pedal.rend { "line" | "term" }?,
    attribute reh.enclose { "box" | "circle" | "none" }?,
    attribute scale { data.NUMBER }?,
    attribute slur.rend { data.CURVERENDITION }?,
    attribute spacing { data.NUMBER }?,
    attribute text.dist { data.NUMBER }?,
    attribute text.fam { data.FONTFAMILY }?,
    attribute text.name { data.FONTNAME }?,
    attribute text.size { data.NUMBER }?,
    attribute text.style { data.FONTSTYLE }?,
    attribute text.weight { data.FONTWEIGHT }?,
    attribute tie.rend { data.CURVERENDITION }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.vis.staffdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.staffdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.staffdef = att.vis.staffdef.base, att.vis.staffdef.mensural
}
[
  xml:id = "att.anl.staffgrp"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.staffgrp" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.staffgrp = empty
}
[
  xml:id = "att.ges.staffgrp"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.staffgrp" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.staffgrp = attribute midi.div { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.log.staffgrp"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.staffgrp" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.staffgrp = empty
}
[
  xml:id = "att.vis.staffgrp"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.staffgrp" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: barthru indicates whether barlines go across\x{a}" ~
        "          the space between staves (yes) or are only drawn across the stafflines of each\x{a}" ~
        "          staff (no), label.full is used on the first page while label.abbr is used\x{a}" ~
        "          thereafter, symbol indicates the left-hand connecting symbol for the group, and\x{a}" ~
        "          the visible attribute indicates whether this group is to be printed. The brace\x{a}" ~
        "          and bracket attributes may be used (instead of additional staffgrp sub-elements)\x{a}" ~
        "          to indicate sub-groupings of staves."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.staffgrp =
    attribute barthru { data.BOOLEAN }?,
    attribute brace { text }?,
    attribute bracket { text }?,
    attribute label.abbr { text }?,
    attribute label.full { text }?,
    attribute symbol { "brace" | "bracket" | "line" }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.uneume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.uneume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: accid.cautionary cautionary accidental\x{a}" ~
        "          accid.editorial editorial accidental or musica ficta hfunc harmonic function,\x{a}" ~
        "          e.g. root, 3rd, 5th inth harmonic interval from pitch in same chord intm melodic\x{a}" ~
        "          interval from previous pitch mfunc melodic function, e.g. appogg., N.T. pclass\x{a}" ~
        "          pitch class psolfa solfa, e.g. do, re, mi, etc."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.uneume =
    att.common.anl,
    attribute accid.cautionary { data.ACCIDENTAL.EXPLICIT }?,
    attribute accid.editorial { data.ACCIDENTAL.EXPLICIT }?,
    attribute hfunc { text }?,
    attribute inth { text }?,
    attribute intm { text }?,
    attribute mfunc { text }?,
    attribute pclass { data.PITCHCLASS }?,
    attribute psolfa { text }?
}
[
  xml:id = "att.ges.uneume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.uneume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: Unused note attributes:\x{a}" ~
        "          accid.ges %data.ACCIDENTAL.IMPLICIT; #IMPLIED artic.ges %data.ARTICULATIONS;\x{a}" ~
        "          #IMPLIED detune CDATA #IMPLIED dur.ges CDATA #IMPLIED gliss %data.GLISSANDO;\x{a}" ~
        "          #IMPLIED grace %data.GRACE; #IMPLIED grace.time %data.PERCENT; #IMPLIED instr\x{a}" ~
        "          IDREF #IMPLIED oct.ges %data.OCTAVE; #IMPLIED pname.ges %data.PITCHNAME.GES;\x{a}" ~
        "          #IMPLIED pnum %data.PITCHNUMBER; #IMPLIED"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.uneume = empty
}
[
  xml:id = "att.log.uneume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.uneume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Unused note attributes: accid\x{a}" ~
        "          %data.ACCIDENTAL.EXPLICIT; #IMPLIED artic %data.ARTICULATIONS; #IMPLIED beam\x{a}" ~
        "          %data.BEAMS; #IMPLIED dots %data.AUGMENTDOT; #IMPLIED dur %data.DURATION;\x{a}" ~
        "          #IMPLIED fermata %data.PLACE; #IMPLIED lv %data.BOOLEAN; #IMPLIED oct\x{a}" ~
        "          %data.OCTAVE; %PROPAGATED; pname %data.PITCHNAME; %PROPAGATED; slur %data.SLURS;\x{a}" ~
        "          #IMPLIED tab.fret %data.FRETNUMBER; #IMPLIED tab.string %data.STRINGNUMBER;\x{a}" ~
        "          #IMPLIED tie %data.TIE; #IMPLIED tuplet %data.TUPLET; #IMPLIED"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.uneume =
    att.event,
    attribute form { data.UNEUMEFORM }?,
    attribute name { data.UNEUMENAME }?,
    attribute syl { text }?
}
[
  xml:id = "att.vis.uneume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.uneume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: Unused note attributes: accid.ho %data.NUMBER;\x{a}" ~
        "          #IMPLIED beam.with %data.PLACE; #IMPLIED coloration (inverse) #IMPLIED dot.ho\x{a}" ~
        "          %data.VISUALOFFSET; #IMPLIED dot.vo %data.VISUALOFFSET; #IMPLIED dot.x\x{a}" ~
        "          %data.NUMBER; #IMPLIED dot.y %data.NUMBER; #IMPLIED enclose.accid\x{a}" ~
        "          %data.ENCLOSURE; #IMPLIED enclose.note %data.ENCLOSURE; #IMPLIED slur.dir\x{a}" ~
        "          %data.SLURDIRECTION; #IMPLIED slur.rend (dotted|dashed) #IMPLIED tie.dir\x{a}" ~
        "          %data.TIEDIRECTION; #IMPLIED tie.rend (dotted|dashed) #IMPLIED stem.dir\x{a}" ~
        "          %data.STEMDIRECTION; #IMPLIED stem.len %data.NUMBER; #IMPLIED stem.mod\x{a}" ~
        "          %data.STEMMODIFIER; #IMPLIED stem.pos %data.STEMPOSITION; #IMPLIED stem.with\x{a}" ~
        "          %data.PLACE; #IMPLIED stem.x %data.NUMBER; #IMPLIED stem.y %data.NUMBER;\x{a}" ~
        "          #IMPLIED"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.uneume =
    att.color,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute headshape { data.HEADSHAPE }?,
    attribute ho { data.VISUALOFFSET }?,
    attribute size { data.SIZE }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.accid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.accid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.accid = att.common.anl
}
[
  xml:id = "att.ges.accid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.accid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.accid = empty
}
[
  xml:id = "att.log.accid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.accid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: %ACCIDENTAL.EXPLICIT is the super-set. The\x{a}" ~
        "          value attribute should really be restricted to the subset given by the form\x{a}" ~
        "          attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.accid =
    attribute form { "implicit" | "explicit" }?,
    attribute func { "caution" | "edit" }?,
    attribute value { data.ACCIDENTAL.EXPLICIT }
}
[
  xml:id = "att.vis.accid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.accid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.accid =
    att.color,
    att.xy,
    attribute enclose { data.ENCLOSURE }?,
    attribute ho { data.VISUALOFFSET }?,
    attribute place { "above" | "below" | "staff" }?,
    attribute vo { data.VISUALOFFSET }?
}
[
  xml:id = "att.anl.annot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.annot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.annot = attribute dur.anl { text }?
}
[
  xml:id = "att.ges.annot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.annot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.annot = empty
}
[
  xml:id = "att.log.annot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.annot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: % att.controlevent is expanded here in order\x{a}" ~
        "          to allow staff to be IMPLIED. Values for the type attribute can be taken from\x{a}" ~
        "          any convenient typology of annotation suitable to the work in hand; e.g.\x{a}" ~
        "          annotation, gloss, citation, digression, preliminary, temporary, etc. The tstamp\x{a}" ~
        "          attribute encodes the onset time of a musical feature in terms of musical time,\x{a}" ~
        "          i.e., beats. The tstamp.ges attribute may be used to record the onset time in\x{a}" ~
        "          pulses per quarter note (ppq, MusicXML divisions, or MIDI clicks) since the\x{a}" ~
        "          start of the measure, while the tstamp.real attribute records the onset time as\x{a}" ~
        "          a real-time offset, i.e., HH:MM:SS.ss, since the beginning of the\x{a}" ~
        "          file."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.annot =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute next { xsd:IDREFS }?,
    attribute prev { xsd:IDREFS }?,
    attribute staff { data.INTEGERPOSITIVE }?,
    attribute tstamp { data.BEAT }?,
    attribute tstamp.ges { data.INTEGERNONNEGATIVE }?,
    attribute tstamp.real { data.ISOTIME }?,
    att.startendid
}
[
  xml:id = "att.vis.annot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.annot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.annot = empty
}
[
  xml:id = "att.anl.arpeg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.arpeg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.arpeg = att.common.anl
}
[
  xml:id = "att.ges.arpeg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.arpeg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.arpeg = empty
}
[
  xml:id = "att.log.arpeg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.arpeg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: dir=nonarp indicates a non-arpeggiated chord.\x{a}" ~
        "          Arpeggiation across multiple staves requires 2 values in staff attribute; if\x{a}" ~
        "          there's more than 1 layer in either staff, 2 values are required in the layer\x{a}" ~
        "          attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.arpeg =
    att.controlevent,
    attribute dir { "up" | "down" | "nonarp" }?
}
[
  xml:id = "att.vis.arpeg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.arpeg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.arpeg =
    att.color,
    att.visualoffset,
    att.xy,
    attribute arrow { data.BOOLEAN }?
}
[
  xml:id = "att.anl.artic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.artic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.artic = att.common.anl
}
[
  xml:id = "att.ges.artic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.artic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.artic = empty
}
[
  xml:id = "att.log.artic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.artic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.artic = attribute value { data.ARTICULATION }
}
[
  xml:id = "att.vis.artic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.artic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.artic =
    att.color,
    att.visualoffset,
    att.xy,
    attribute enclose { data.ENCLOSURE }?,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.beam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.beam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.beam = att.common.anl
}
[
  xml:id = "att.ges.beam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.beam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.beam = empty
}
[
  xml:id = "att.log.beam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.beam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.beam =
    att.event,
    attribute with { data.PLACE }?
}
[
  xml:id = "att.vis.beam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.beam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: Secondary beams may be broken explicitly using\x{a}" ~
        "          the breaksec attribute. Its value should contain a space-separated list of\x{a}" ~
        "          rhythmic durations that form a single beat. For example,'8 8' indicates a\x{a}" ~
        "          division of the beam into 2 8th-note groups."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.beam =
    attribute breaksec { xsd:NMTOKENS }?,
    attribute rend { "acc" | "rit" | "norm" }?,
    attribute slope { data.NUMBER }?
}
[
  xml:id = "att.anl.beamspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.beamspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.beamspan = att.common.anl
}
[
  xml:id = "att.ges.beamspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.beamspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.beamspan = empty
}
[
  xml:id = "att.log.beamspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.beamspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.beamspan =
    att.controlevent,
    att.startendid,
    attribute with { data.PLACE }?
}
[
  xml:id = "att.vis.beamspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.beamspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.beamspan =
    attribute breaksec { text }?,
    attribute rend { "acc" | "rit" | "norm" }?,
    attribute slope { data.NUMBER }?
}
[
  xml:id = "att.anl.beatrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.beatrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.beatrpt = att.common.anl
}
[
  xml:id = "att.ges.beatrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.beatrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.beatrpt = empty
}
[
  xml:id = "att.log.beatrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.beatrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.beatrpt = att.event
}
[
  xml:id = "att.vis.beatrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.beatrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The expand attribute indicates whether to\x{a}" ~
        "          render the source measures or the usual repeated beat symbol. The rend attribute\x{a}" ~
        "          indicates the number of slashes required to render the appropriate beat repeat\x{a}" ~
        "          symbol when the beat is divided into even notes - 4ths or 8ths=1, 16ths=2,\x{a}" ~
        "          32nds=3, 64ths=4, 128ths=5. When the beat is comprised of mixed duration values,\x{a}" ~
        "          the symbol is always rendered as 2 slashes and 2 dots. See Read, pg.\x{a}" ~
        "          223-224."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.beatrpt =
    att.color,
    attribute altsym { xsd:IDREF }?,
    attribute expand { data.BOOLEAN }?,
    attribute rend { "4" | "8" | "16" | "32" | "64" | "128" | "mixed" }
}
[
  xml:id = "att.anl.bend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.bend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.bend = att.common.anl
}
[
  xml:id = "att.ges.bend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.bend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.bend = attribute amount { ".25" | ".5" | ".75" | "1" }?
}
[
  xml:id = "att.log.bend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.bend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.bend = att.controlevent, att.startendid
}
[
  xml:id = "att.vis.bend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.bend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The bulge or, alternatively, the bezier\x{a}" ~
        "          attribute, describes the shape of the bend. The bulge attribute describes the\x{a}" ~
        "          curve as a set of distance values above or below an imaginary line connecting\x{a}" ~
        "          the endpoints of the curve while the bezier attribute records the placement of\x{a}" ~
        "          Bezier control points as a series of space-separated xy coordinates, eg. 19 45\x{a}" ~
        "          -32 118. If the bulge or bezier attributes are present, the bend should be\x{a}" ~
        "          rendered as a curve. Otherwise, it should be rendered as a line. The bulge\x{a}" ~
        "          attribute must contain one or more values of type %NUMBER. The rend attribute\x{a}" ~
        "          records the typographical style of the curve or line while the ho and vo\x{a}" ~
        "          attributes describe the visual offset of the entire rendered bend. The endho,\x{a}" ~
        "          endvo and startho, startvo attribute pairs may be used to encode start and end\x{a}" ~
        "          points relative to their programmatic placement. For exact placement of the\x{a}" ~
        "          endpoints of the bend use the xy coordinate pairs."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.bend =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute bezier { xsd:NMTOKENS }?,
    attribute bulge { xsd:NMTOKENS }?,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute rend { data.CURVERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?
}
[
  xml:id = "att.anl.breath"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.breath" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.breath = att.common.anl
}
[
  xml:id = "att.ges.breath"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.breath" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.breath = empty
}
[
  xml:id = "att.log.breath"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.breath" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Currently, the dur attribute encodes the\x{a}" ~
        "          logical and visual durations of the directive. If cases arise where the logical\x{a}" ~
        "          and visual durations differ, it may be necessary to add a dur.vis attribute.\x{a}" ~
        "          Please note that the dur attribute is not a true duration, but rather a time\x{a}" ~
        "          stamp for the end point of the directive."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.breath = att.controlevent, att.startendid
}
[
  xml:id = "att.vis.breath"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.breath" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.breath =
    att.color,
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.btrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.btrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.btrem = att.common.anl
}
[
  xml:id = "att.ges.btrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.btrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.btrem = empty
}
[
  xml:id = "att.log.btrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.btrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The num attribute should be explicitly set for\x{a}" ~
        "          measured tremolandi. The stem modifier (slash or z) must also be explicity set\x{a}" ~
        "          on the child note or chord element for a complete visual\x{a}" ~
        "          representation."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.btrem =
    att.event,
    attribute form { "meas" | "unmeas" }?,
    attribute num { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.vis.btrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.btrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.btrem = attribute num.place { data.PLACE }?
}
[
  xml:id = "att.anl.chord"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.chord" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: hfunc = harmonic function, mfunc = melodic\x{a}" ~
        "          function."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.chord =
    att.common.anl,
    attribute hfunc { text }?,
    attribute mfunc { text }?
}
[
  xml:id = "att.ges.chord"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.chord" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: The artic.ges and dur.ges\x{a}" ~
        "          attributes record the articulation and duration information when the performed\x{a}" ~
        "          values differ from the written values. The dur.ges attribute (performed\x{a}" ~
        "          duration) may be expressed in several forms, such as\x{a}" ~
        "          measures[s]+beat[s].beatpart, ppq (MIDI clicks), Humdrum *recip values, or\x{a}" ~
        "          MusicXML 'divisions', etc. Because dur.ges isn't limited to the standard\x{a}" ~
        "          duration values, a dots.ges attribute is unnecessary."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.chord =
    attribute artic.ges { data.ARTICULATIONS }?,
    attribute detune { text }?,
    attribute dur.ges { text }?,
    attribute grace { data.GRACE }?,
    attribute grace.time { data.PERCENT }?,
    attribute instr { xsd:IDREF }?
}
[
  xml:id = "att.log.chord"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.chord" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The artic, dots, and dur attributes encode the\x{a}" ~
        "          *written* articulations, augmentation dots, and duration values."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.chord =
    att.event,
    attribute artic { data.ARTICULATIONS }?,
    attribute beam { data.BEAMS }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute fermata { data.PLACE }?,
    attribute lv { data.BOOLEAN }?,
    attribute slur { data.SLURS }?,
    attribute syl { text }?,
    attribute tie { data.TIE }?,
    attribute tuplet { data.TUPLET }?
}
[
  xml:id = "att.vis.chord"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.chord" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The altsym attribute indicates that the\x{a}" ~
        "          specified alternative visual symbol is to be displayed. The headshape attribute\x{a}" ~
        "          may be used to indicate a cluster notehead should be displayed instead of\x{a}" ~
        "          individual noteheads. See Read, p. 320-321 re: tone clusters. Processing of\x{a}" ~
        "          chords and notes will be easier if a distinction is made between articulations,\x{a}" ~
        "          which indicate sound quality, and text strings, such as numbers for fingering,\x{a}" ~
        "          etc. Only articulations should be encoded in the artic attribute; fingerings\x{a}" ~
        "          should be encoded using the <dir> element. Articulations may be\x{a}" ~
        "          encoded in order from the notehead outward; that is, away from the stem. See\x{a}" ~
        "          additional notes at a.vis.note. The slur, slur.dir, slur.rend, tie, tie.dir, and\x{a}" ~
        "          tie.rend attributes here are syntactic sugar for these attributes on each of the\x{a}" ~
        "          chord's individual notes. The values here apply to all the notes in the chord.\x{a}" ~
        "          If some notes are slurred or tied while others aren't, then the individual note\x{a}" ~
        "          attributes must be used. The coloration attribute should not be confused with\x{a}" ~
        "          visual color. Coloration is when a void notehead is displayed filled and vice\x{a}" ~
        "          versa. The dot.ho and dot.vo attributes record the offset of the dot from its\x{a}" ~
        '          "normal" position while the dot.x and dot.y attributes record the precise\x{a}' ~
        "          position of the dot. The %att.visualoffset entity is expanded here in order to\x{a}" ~
        "          disallow a vertical offset."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.chord =
    att.color,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute beam.with { data.PLACE }?,
    attribute coloration { "inverse" }?,
    attribute dot.ho { data.VISUALOFFSET }?,
    attribute dot.vo { data.VISUALOFFSET }?,
    attribute dot.x { data.NUMBER }?,
    attribute dot.y { data.NUMBER }?,
    attribute headshape { data.CLUSTER }?,
    attribute ho { data.VISUALOFFSET }?,
    attribute size { data.SIZE }?,
    attribute slur.dir { data.SLURDIRECTION }?,
    attribute slur.rend { "dotted" | "dashed" }?,
    attribute stem.dir { data.STEMDIRECTION }?,
    attribute stem.len { data.NUMBER }?,
    attribute stem.mod { data.STEMMODIFIER }?,
    attribute stem.pos { data.STEMPOSITION }?,
    attribute stem.with { data.PLACE }?,
    attribute stem.x { data.NUMBER }?,
    attribute stem.y { data.NUMBER }?,
    attribute tie.dir { data.TIEDIRECTION }?,
    attribute tie.rend { "dotted" | "dashed" }?,
    attribute to { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.clefchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.clefchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.clefchange = att.common.anl
}
[
  xml:id = "att.ges.clefchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.clefchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.clefchange = empty
}
[
  xml:id = "att.log.clefchange.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.clefchange.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.clefchange.base =
    attribute line { data.CLEFLINE }?,
    attribute octave.default { data.OCTAVE }?,
    attribute shape { data.CLEFSHAPE }?,
    attribute trans { data.CLEFTRAN }?
}
[
  xml:id = "att.log.clefchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.clefchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.clefchange = att.log.clefchange.base
}
[
  xml:id = "att.vis.clefchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.clefchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.clefchange =
    att.color,
    attribute altsym { xsd:IDREF }?
}
[
  xml:id = "att.anl.dir"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.dir" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.dir = att.common.anl
}
[
  xml:id = "att.ges.dir"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.dir" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.dir = attribute dur.ges { text }?
}
[
  xml:id = "att.log.dir"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.dir" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Currently, the dur attribute encodes the\x{a}" ~
        "          logical and visual durations of the directive. If cases arise where the logical\x{a}" ~
        "          and visual durations differ, it may be necessary to add a dur.vis attribute.\x{a}" ~
        "          Please note that the dur attribute is not a true duration, but rather a time\x{a}" ~
        "          stamp for the end point of the directive."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.dir =
    att.controlevent,
    att.startendid,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.dir"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.dir" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.dir =
    att.visualoffset,
    att.xy,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute place { data.PLACE }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.dynam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.dynam" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.dynam = att.common.anl
}
[
  xml:id = "att.ges.dynam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.dynam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.dynam =
    attribute dur.ges { text }?,
    attribute value { data.MIDIVALUE }?
}
[
  xml:id = "att.log.dynam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.dynam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the dynamic symbol or text while the dur.ges attribute\x{a}" ~
        "          encodes the performed duration. If logical and visual duration differ, it may be\x{a}" ~
        "          necessary to add a dur.vis attribute. Please note that the dur attribute is not\x{a}" ~
        "          a true duration, but rather a time stamp for the end point of the dynamic\x{a}" ~
        "          indication."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.dynam =
    att.controlevent,
    att.startendid,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.dynam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.dynam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.dynam =
    att.visualoffset,
    att.xy,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute place { data.PLACE }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.fermata"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.fermata" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.fermata = att.common.anl
}
[
  xml:id = "att.ges.fermata"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.fermata" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.fermata = attribute dur.ges { text }?
}
[
  xml:id = "att.log.fermata"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.fermata" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.fermata = att.controlevent, att.startendid
}
[
  xml:id = "att.vis.fermata"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.fermata" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.fermata =
    att.color,
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute form { "inv" | "norm" }?,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.ftrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.ftrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.ftrem = att.common.anl
}
[
  xml:id = "att.ges.ftrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.ftrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.ftrem = attribute form { "meas" | "unmeas" }?
}
[
  xml:id = "att.log.ftrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.ftrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.ftrem = att.event
}
[
  xml:id = "att.vis.ftrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.ftrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The rend attribute indicates the number of\x{a}" ~
        "          slashes required - 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4,\x{a}" ~
        "          128ths=5."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.ftrem =
    attribute rend { "4" | "8" | "16" | "32" | "64" | "128" }
}
[
  xml:id = "att.anl.gliss"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.gliss" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.gliss = att.common.anl
}
[
  xml:id = "att.ges.gliss"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.gliss" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.gliss = empty
}
[
  xml:id = "att.log.gliss"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.gliss" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.gliss = att.controlevent, att.startendid
}
[
  xml:id = "att.vis.gliss"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.gliss" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The text attribute may be used to record any\x{a}" ~
        "          text, such as 'gliss.' that accompanies the glissando mark."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.gliss =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute rend { data.LINERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?,
    attribute text { text }?
}
[
  xml:id = "att.anl.hairpin"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.hairpin" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.hairpin = att.common.anl
}
[
  xml:id = "att.ges.hairpin"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.hairpin" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: dur.ges represents the performed\x{a}" ~
        "          duration."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.hairpin = attribute dur.ges { text }?
}
[
  xml:id = "att.log.hairpin"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.hairpin" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the hairpin while the dur.ges attribute, if it is available,\x{a}" ~
        "          encodes the performed duration. If logical and visual duration differ, it may be\x{a}" ~
        "          necessary to add a dur.vis attribute. Please note that the dur attribute is not\x{a}" ~
        "          a true duration, but rather a time stamp for the end point of the\x{a}" ~
        "          hairpin."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.hairpin =
    att.controlevent,
    att.startendid,
    attribute dur { data.MEASUREBEAT }?,
    attribute form { "cres" | "dim" }
}
[
  xml:id = "att.vis.hairpin"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.hairpin" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The startho and startvo attributes record the\x{a}" ~
        "          horizontal and vertical offsets of the left end, endho and endvo record the\x{a}" ~
        "          horizontal and vertical offsets of the right end, and the width attribute\x{a}" ~
        "          records the width of the opening on the open end in staff inter-line units. The\x{a}" ~
        "          x1 and y1 attributes give the absolute coordinates of the left side of the\x{a}" ~
        "          hairpin while x2 and y2 record the coordinates of the right side."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.hairpin =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute place { data.PLACE },
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?,
    attribute width { data.NUMBER }?
}
[
  xml:id = "att.anl.halfmrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.halfmrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.halfmrpt = att.common.anl
}
[
  xml:id = "att.ges.halfmrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.halfmrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.halfmrpt = empty
}
[
  xml:id = "att.log.halfmrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.halfmrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.halfmrpt =
    att.event,
    attribute dur { data.DURATION }?
}
[
  xml:id = "att.vis.halfmrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.halfmrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The expand attribute indicates whether or not\x{a}" ~
        "          to render the source material. How can it be pointed to?"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.halfmrpt =
    att.color,
    att.visualoffset,
    attribute altsym { xsd:IDREF }?,
    attribute expand { data.BOOLEAN }?
}
[
  xml:id = "att.anl.harm"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.harm" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.harm = att.common.anl
}
[
  xml:id = "att.ges.harm"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.harm" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.harm = attribute dur.ges { text }?
}
[
  xml:id = "att.log.harm"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.harm" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the harmony while the dur.ges attribute, if it is available,\x{a}" ~
        "          encodes the performed duration. If logical and visual duration differ, it may be\x{a}" ~
        "          necessary to add a dur.vis attribute. Please note that the dur attribute here is\x{a}" ~
        "          not a true duration, but rather a time stamp for the end point of the\x{a}" ~
        "          directive."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.harm =
    att.controlevent,
    att.startendid,
    attribute chordref { xsd:IDREF }?,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.harm"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.harm" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: If the rendgrid attribute is set to 'grid',\x{a}" ~
        "          then the chord tablature grid defined in the chordtable should be rendered\x{a}" ~
        "          instead of the text contents of the harm element; if rendgrid equals 'gridname',\x{a}" ~
        "          both the harm element's text and the grid should be displayed; otherwise, only\x{a}" ~
        "          the 'name' of the chord, i.e., the text content of the harm element, e.g. 'Cmaj'\x{a}" ~
        "          or 'V7/III', should be rendered."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.harm =
    att.visualoffset,
    att.xy,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute extender { data.BOOLEAN }?,
    attribute place { data.PLACE }?,
    attribute rendgrid { "grid" | "gridname" }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.harppedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.harppedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.harppedal = att.common.anl
}
[
  xml:id = "att.ges.harppedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.harppedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.harppedal = attribute dur.ges { text }?
}
[
  xml:id = "att.log.harppedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.harppedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.harppedal =
    att.controlevent,
    att.startendid,
    [ a:defaultValue = "n" ] attribute c { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute d { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute e { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute f { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute g { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute a { "f" | "n" | "s" }?,
    [ a:defaultValue = "n" ] attribute b { "f" | "n" | "s" }?
}
[
  xml:id = "att.vis.harppedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.harppedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.harppedal =
    att.color,
    att.visualoffset,
    att.xy,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.lyrics"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.lyrics" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.lyrics = att.common.anl
}
[
  xml:id = "att.ges.lyrics"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.lyrics" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.lyrics = empty
}
[
  xml:id = "att.log.lyrics"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.lyrics" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: %att.controlevent is expanded here in order to\x{a}" ~
        "          allow only the staff and layer attributes from this class."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.lyrics =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute staff { data.INTEGERPOSITIVE }
}
[
  xml:id = "att.vis.lyrics"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.lyrics" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.lyrics =
    att.typography,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.measure"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.measure" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.measure = att.common.anl
}
[
  xml:id = "att.ges.measure"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.measure" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.measure = empty
}
[
  xml:id = "att.log.measure"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.measure" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The complete attribute allows the encoding of\x{a}" ~
        "          whether a measure matches the prevailing meter: a value of 'c' indicates a\x{a}" ~
        "          metrically complete measure, 'i' indicates a measure with not enough beats,\x{a}" ~
        "          while 'o' is for measures with too many beats. The control attribute indicates\x{a}" ~
        '          whether or not the barline is "controlling", that is, indicates a point of\x{a}' ~
        "          alignment across all the parts. Barlines within a score are always\x{a}" ~
        "          'controlling'; that is, they must 'line up'. Barlines within parts may or may\x{a}" ~
        "          not be 'controlling'. The left attribute indicates the function of the left\x{a}" ~
        "          barline. It is present here only for facilitation of translation from legacy\x{a}" ~
        "          encodings which use it. Usually, it can be safely ignored. The right attribute,\x{a}" ~
        "          on the other hand, indicates the function of the right barline and is\x{a}" ~
        "          structurally important. The n attribute may contain a name/name (label) for the\x{a}" ~
        "          measure (Read, p. 445). Often, this is an integer, but not always. For example,\x{a}" ~
        "          some measures, especially incomplete measures or those under an ending mark, may\x{a}" ~
        "          have labels that contain an integer plus a suffix, such as '12a'. Measures may\x{a}" ~
        "          even have labels, especially in editorial or analytical uses of MEI, that are\x{a}" ~
        "          entirely non-numeric strings. Measure numbers may be machine-generated. However,\x{a}" ~
        "          an explicit measure number will restart numbering with the given\x{a}" ~
        "          value."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.measure =
    attribute complete { "c" | "i" | "o" }?,
    attribute control { data.BOOLEAN }?,
    attribute left { data.BARRENDITION }?,
    attribute measref { xsd:IDREF }?,
    attribute right { data.BARRENDITION }?
}
[
  xml:id = "att.vis.measure"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.measure" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The taktplace attribute value must be a number\x{a}" ~
        "          between 1 and the number of stafflines. For example, a value of '5' puts the\x{a}" ~
        "          barline through the top line of a 5-line staff. The width attribute records a\x{a}" ~
        "          fixed width for the measure."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.measure =
    attribute barplace { data.BARPLACE }?,
    attribute taktplace { data.STAFFLOC }?,
    attribute width { data.NUMBER }?
}
[
  xml:id = "att.anl.mordent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mordent" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mordent = att.common.anl
}
[
  xml:id = "att.ges.mordent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mordent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mordent = empty
}
[
  xml:id = "att.log.mordent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mordent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: In the form attribute, 'norm' signals the\x{a}" ~
        "          normal form, that is, the written note, followed by its lower neighbor, with a\x{a}" ~
        "          return to the written note, while 'inv' indicates the inverted form, that is,\x{a}" ~
        "          the principal note, followed by its upper neighbor, with a return to the\x{a}" ~
        "          principal note. When the long attribute is set to 'yes', a double or long\x{a}" ~
        "          mordent, consisting of 5 notes, is indicated. Traditionally, the 'normal'\x{a}" ~
        "          mordent is written as a short wavy line with a vertical line through it and the\x{a}" ~
        "          inverted mordent is written without the vertical line. However, the meaning of\x{a}" ~
        "          these signs is sometimes reversed. See Read, p. 245-246. Another attribute in\x{a}" ~
        "          the visual domain would be necessary in order to be completely explicit about\x{a}" ~
        "          which visual symbol is actually to be rendered."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mordent =
    att.controlevent,
    att.startendid,
    attribute accidupper { data.ACCIDENTAL.EXPLICIT }?,
    attribute accidlower { data.ACCIDENTAL.EXPLICIT }?,
    attribute form { "inv" | "norm" }?,
    attribute long { data.BOOLEAN }?
}
[
  xml:id = "att.vis.mordent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mordent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mordent =
    att.color,
    att.visualoffset,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.mrest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mrest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The n attribute is used to explicitly\x{a}" ~
        "          encode this measure's position in a string of measures containing only mrest\x{a}" ~
        "          elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mrest = att.common.anl
}
[
  xml:id = "att.ges.mrest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mrest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mrest =
    attribute dur.ges { text }?,
    attribute instr { xsd:IDREF }?
}
[
  xml:id = "att.log.mrest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mrest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mrest =
    att.event,
    attribute fermata { data.PLACE }?
}
[
  xml:id = "att.vis.mrest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mrest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The altsym attribute indicates that the\x{a}" ~
        "          specified alternative visual symbol is to be displayed. When set to 'rest' the\x{a}" ~
        "          cutout attribute indicates that the staff lines are to be displayed but not the\x{a}" ~
        "          rest itself. When set to 'staff' even the staff lines should not be drawn for\x{a}" ~
        "          this measure. See _56 Songs You Like to Sing_, p. 32. The dur.vis attribute\x{a}" ~
        "          should be used to record the durational symbol used in the source."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mrest =
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute cutout { "rest" | "staff" }?,
    attribute dur.vis { data.DURATION }?,
    attribute size { data.SIZE }?
}
[
  xml:id = "att.anl.mrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The measref attribute is provided to\x{a}" ~
        "          explicitly indicate the measure whose contents are to be repeated here. The n\x{a}" ~
        "          attribute is used to explicitly encode this measure's position in a string of\x{a}" ~
        "          measures containing only mrpt elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mrpt =
    att.common.anl,
    attribute measref { xsd:IDREF }?
}
[
  xml:id = "att.ges.mrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mrpt = empty
}
[
  xml:id = "att.log.mrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mrpt = att.event
}
[
  xml:id = "att.vis.mrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The expand attribute indicates whether or not\x{a}" ~
        "          to render the source measure."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mrpt =
    att.color,
    attribute altsym { xsd:IDREF }?,
    attribute expand { data.BOOLEAN }?
}
[
  xml:id = "att.anl.mrpt2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mrpt2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The measref attribute is provided to\x{a}" ~
        "          explicitly indicate the measures whose contents are to be repeated\x{a}" ~
        "          here."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mrpt2 =
    att.common.anl,
    attribute measref { xsd:IDREFS }?
}
[
  xml:id = "att.ges.mrpt2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mrpt2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mrpt2 = empty
}
[
  xml:id = "att.log.mrpt2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mrpt2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mrpt2 = att.event
}
[
  xml:id = "att.vis.mrpt2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mrpt2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The expand attribute indicates whether or not\x{a}" ~
        "          to render the source measures."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mrpt2 =
    att.color,
    attribute altsym { xsd:IDREF }?,
    attribute expand { data.BOOLEAN }?
}
[
  xml:id = "att.anl.mspace"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.mspace" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The n attribute is used to explicitly\x{a}" ~
        "          encode this measure's position in a string of measures containing only mrest\x{a}" ~
        "          elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.mspace = att.common.anl
}
[
  xml:id = "att.ges.mspace"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.mspace" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.mspace =
    attribute dur.ges { text }?,
    attribute instr { xsd:IDREF }?
}
[
  xml:id = "att.log.mspace"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.mspace" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.mspace =
    att.event,
    attribute fermata { data.PLACE }?
}
[
  xml:id = "att.vis.mspace"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.mspace" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The altsym attribute indicates that the\x{a}" ~
        "          specified alternative visual symbol is to be displayed. When set to 'rest' the\x{a}" ~
        "          cutout attribute indicates that the staff lines are to be displayed but not the\x{a}" ~
        "          rest itself. When set to 'staff' even the staff lines should not be drawn for\x{a}" ~
        "          this measure. See _56 Songs You Like to Sing_, p. 32. The dur.vis attribute\x{a}" ~
        "          should be used to record the durational symbol used in the source."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.mspace =
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute cutout { "rest" | "staff" }?,
    attribute dur.vis { data.DURATION }?
}
[
  xml:id = "att.anl.multirest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.multirest" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.multirest = att.common.anl
}
[
  xml:id = "att.ges.multirest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.multirest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.multirest =
    attribute dur.ges { text }?,
    attribute instr { xsd:IDREF }?
}
[
  xml:id = "att.log.multirest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.multirest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The num attribute contains the number of\x{a}" ~
        "          measures of rest."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.multirest =
    att.event,
    attribute num { data.INTEGERPOSITIVE }
}
[
  xml:id = "att.vis.multirest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.multirest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: When the block attribute is used, combinations\x{a}" ~
        "          of the 1, 2, & 4 measure rest forms (Read, p. 104) should be rendered\x{a}" ~
        "          instead of the modern form."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.multirest =
    attribute altsym { xsd:IDREF }?,
    attribute block { data.BOOLEAN }?
}
[
  xml:id = "att.anl.multirpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.multirpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The meas attribute is provided to\x{a}" ~
        "          explicitly reference the measures where the source content exists."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.multirpt = att.common.anl
}
[
  xml:id = "att.ges.multirpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.multirpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.multirpt = empty
}
[
  xml:id = "att.log.multirpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.multirpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The num attribute contains the number of\x{a}" ~
        "          measures to be repeated."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.multirpt =
    att.event,
    attribute measref { xsd:IDREFS }?,
    attribute num { data.INTEGERPOSITIVE }
}
[
  xml:id = "att.vis.multirpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.multirpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The expand attribute indicates whether or not\x{a}" ~
        "          to render the source measures."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.multirpt =
    attribute altsym { xsd:IDREF }?,
    attribute expand { data.BOOLEAN }?
}
[
  xml:id = "att.anl.nota"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.nota" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: accid.cautionary cautionary accidental\x{a}" ~
        "          accid.editorial editorial accidental or musica ficta hfunc harmonic function,\x{a}" ~
        "          e.g. root, 3rd, 5th inth harmonic interval from pitch in same chord intm melodic\x{a}" ~
        "          interval from previous pitch mfunc melodic function, e.g. appogg., N.T. pclass\x{a}" ~
        "          pitch class psolfa solfa, e.g. do, re, mi, etc."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.nota =
    att.common.anl,
    attribute accid.cautionary { data.ACCIDENTAL.EXPLICIT }?,
    attribute accid.editorial { data.ACCIDENTAL.EXPLICIT }?,
    attribute hfunc { text }?,
    attribute inth { text }?,
    attribute intm { text }?,
    attribute mfunc { text }?,
    attribute pclass { data.PITCHCLASS }?,
    attribute psolfa { text }?
}
[
  xml:id = "att.ges.nota.tablature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.nota.tablature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: The artic.ges, dur.ges,\x{a}" ~
        "          oct.ges, pname.ges attributes record the articulation, duration, octave, and\x{a}" ~
        "          pitch name when the performed value differs from the written value. The\x{a}" ~
        "          accid.ges attribute may be used to record the implicit accidental, that is, the\x{a}" ~
        "          pitch alteration required by the key signature, for use in conversion to sound\x{a}" ~
        "          and for harmonic analysis. Therefore, only the flat, double flat, sharp and\x{a}" ~
        "          double sharp values are permitted. Unlike dur attributes elsewhere, the dur.ges\x{a}" ~
        "          attribute (performed duration) type is CDATA. This allows the expression of\x{a}" ~
        "          performance duration in user-defined terms, such as\x{a}" ~
        "          measures[s]:beat[s].beatpart, MIDI clicks, Humdrum *recip values, etc. Because\x{a}" ~
        "          dur.ges isn't limited to the standard duration values, a dots.ges attribute is\x{a}" ~
        "          unnecessary. See Read, p. 238-241, for a discussion of grace notes. The pnum\x{a}" ~
        "          attribute holds a pitch-to-number mapping, a base-40 or MIDI note number, for\x{a}" ~
        "          example."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.nota.tablature =
    attribute tab.fret { data.FRETNUMBER }?,
    attribute tab.string { data.STRINGNUMBER }?
}
[
  xml:id = "att.ges.nota.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.nota.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.nota.base =
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.INTEGERPOSITIVE }?,
    attribute accid.ges { data.ACCIDENTAL.IMPLICIT }?,
    attribute artic.ges { data.ARTICULATIONS }?,
    attribute detune { text }?,
    attribute dur.ges { text }?,
    attribute gliss { data.GLISSANDO }?,
    attribute grace { data.GRACE }?,
    attribute grace.time { data.PERCENT }?,
    attribute instr { xsd:IDREF }?,
    attribute oct.ges { data.OCTAVE }?,
    attribute pname.ges { data.PITCHNAME.GES }?,
    attribute pnum { data.PITCHNUMBER }?
}
[
  xml:id = "att.ges.nota"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.nota" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.nota = att.ges.nota.base, att.ges.nota.tablature
}
[
  xml:id = "att.log.nota"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.nota" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The pname, accid, oct, dur, dots, and artic\x{a}" ~
        "          attributes encode the *written* note name, accidental, octave, duration,\x{a}" ~
        "          articulations, augmentation dots, and articulations. The acci attribute records\x{a}" ~
        "          the notated accidental for the note, e.g. flat, sharp, natural, double flat,\x{a}" ~
        "          double sharp (both forms), natural+flat, natural+sharp, and the quarter tone\x{a}" ~
        "          accidentals. The beam attribute records the presence of a beam in which this\x{a}" ~
        "          note participates. Software may use this attribute or beam elements for\x{a}" ~
        "          rendering. The dots attribute records the number of augmentation dots required\x{a}" ~
        "          by a dotted duration. The slur, tie, lv (laissez vibrer), and tuplet attributes\x{a}" ~
        "          encode the presence of a slur, tie, lv, or tuplet in which this note\x{a}" ~
        "          participates. Software may render slur, tie, lv or tuplet indications based on\x{a}" ~
        "          these attributes or require separate slur, tie, generic curve, or tuplet\x{a}" ~
        "          elements for visual rendition. Tablature information can be recorded in the\x{a}" ~
        "          tab.fret and tab.string attributes. fermata = corona in the mensural\x{a}" ~
        "          repertoire."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.nota =
    att.event,
    attribute accid { data.ACCIDENTAL.EXPLICIT }?,
    attribute corona { data.PLACE }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION.MENSURAL }?,
    attribute lig { "recta" | "obliqua" }?,
    attribute oct { data.OCTAVE }?,
    attribute pname { data.PITCHNAME }?,
    attribute syl { text }?
}
[
  xml:id = "att.vis.nota"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.nota" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The distance between the accidental and the\x{a}" ~
        "          note it modifies should be recorded in the accid.ho attribute. The headshape\x{a}" ~
        "          attribute may be used to override the headshape normally used for the given\x{a}" ~
        "          duration. The enclose.accid and enclose.note attributes record the symbol to be\x{a}" ~
        "          used around the accidental and the entire note, respectively. For an example of\x{a}" ~
        "          cautionary accidentals enclosed in parentheses or brackets see Read, p. 131, ex.\x{a}" ~
        "          9-14. The coloration attribute may be used to indicate a reverse coloration,\x{a}" ~
        "          i.e., black instead of white or white instead of black. The dot.ho and dot.vo\x{a}" ~
        '          attributes record the offset of the dot from its "normal" position while the\x{a}' ~
        "          dot.x and dot.y attributes record the precise position of the dot. The\x{a}" ~
        "          %att.visualoffset entity is expanded here in order to disallow a vertical\x{a}" ~
        "          offset."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.nota =
    att.color,
    att.xy,
    attribute accid.ho { data.NUMBER }?,
    attribute altsym { xsd:IDREF }?,
    attribute beam.with { data.PLACE }?,
    attribute coloration { "inverse" }?,
    attribute colored { data.BOOLEAN }?,
    attribute dot.ho { data.VISUALOFFSET }?,
    attribute dot.vo { data.VISUALOFFSET }?,
    attribute dot.x { data.NUMBER }?,
    attribute dot.y { data.NUMBER }?,
    attribute enclose.accid { data.ENCLOSURE }?,
    attribute enclose.note { data.ENCLOSURE }?,
    attribute headshape { data.HEADSHAPE }?,
    attribute ho { data.VISUALOFFSET }?,
    attribute size { data.SIZE }?,
    attribute slur.dir { data.SLURDIRECTION }?,
    attribute slur.rend { "dotted" | "dashed" }?,
    attribute stem.dir { data.STEMDIRECTION }?,
    attribute stem.len { data.NUMBER }?,
    attribute stem.mod { data.STEMMODIFIER }?,
    attribute stem.pos { data.STEMPOSITION }?,
    attribute stem.with { data.PLACE }?,
    attribute stem.x { data.NUMBER }?,
    attribute stem.y { data.NUMBER }?,
    attribute tie.dir { data.TIEDIRECTION }?,
    attribute tie.rend { "dotted" | "dashed" }?,
    attribute to { data.TSTAMPOFFSET }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.note"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.note" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: accid.cautionary cautionary accidental\x{a}" ~
        "          accid.editorial editorial accidental or musica ficta hfunc harmonic function,\x{a}" ~
        "          e.g. root, 3rd, 5th inth harmonic interval from pitch in same chord intm melodic\x{a}" ~
        "          interval from previous pitch mfunc melodic function, e.g. appogg., N.T. pclass\x{a}" ~
        "          pitch class psolfa solfa, e.g. do, re, mi, etc."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.note =
    att.common.anl,
    attribute accid.cautionary { data.ACCIDENTAL.EXPLICIT }?,
    attribute accid.editorial { data.ACCIDENTAL.EXPLICIT }?,
    attribute hfunc { text }?,
    attribute inth { text }?,
    attribute intm { text }?,
    attribute mfunc { text }?,
    attribute pclass { data.PITCHCLASS }?,
    attribute psolfa { text }?
}
[
  xml:id = "att.ges.note.tablature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.note.tablature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: The artic.ges, dur.ges,\x{a}" ~
        "          oct.ges, pname.ges attributes record the articulation, duration, octave, and\x{a}" ~
        "          pitch name when the performed value differs from the written value. The\x{a}" ~
        "          accid.ges attribute may be used to record the implicit accidental, that is, the\x{a}" ~
        "          pitch alteration required by the key signature, for use in conversion to sound\x{a}" ~
        "          and for harmonic analysis. Therefore, only the flat, double flat, sharp and\x{a}" ~
        "          double sharp values are permitted. Unlike dur attributes elsewhere, the dur.ges\x{a}" ~
        "          attribute (performed duration) type is CDATA. This allows the expression of\x{a}" ~
        "          performance duration in user-defined terms, such as\x{a}" ~
        "          measures[s]:beat[s].beatpart, MIDI clicks, Humdrum *recip values, etc. Because\x{a}" ~
        "          dur.ges isn't limited to the standard duration values, a dots.ges attribute is\x{a}" ~
        "          unnecessary. See Read, p. 238-241, for a discussion of grace notes. The pnum\x{a}" ~
        "          attribute holds a pitch-to-number mapping, a base-40 or MIDI note number, for\x{a}" ~
        "          example. Tablature information can be recorded in the tab.fret and tab.string\x{a}" ~
        "          attributes."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.note.tablature = empty
}
[
  xml:id = "att.ges.note.base"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.note.base" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.note.base =
    attribute accid.ges { data.ACCIDENTAL.IMPLICIT }?,
    attribute artic.ges { data.ARTICULATIONS }?,
    attribute detune { text }?,
    attribute dur.ges { text }?,
    attribute gliss { data.GLISSANDO }?,
    attribute grace { data.GRACE }?,
    attribute grace.time { data.PERCENT }?,
    attribute instr { xsd:IDREF }?,
    attribute oct.ges { data.OCTAVE }?,
    attribute pname.ges { data.PITCHNAME.GES }?,
    attribute pnum { data.PITCHNUMBER }?,
    attribute tab.fret { data.FRETNUMBER }?,
    attribute tab.string { data.STRINGNUMBER }?
}
[
  xml:id = "att.ges.note"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.note" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.note = att.ges.note.base, att.ges.note.tablature
}
[
  xml:id = "att.log.note"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.note" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The pname, accid, oct, dur, dots, and artic\x{a}" ~
        "          attributes encode the *written* note name, accidental, octave, duration,\x{a}" ~
        "          articulations, augmentation dots, and articulations. The acci attribute records\x{a}" ~
        "          the notated accidental for the note, e.g. flat, sharp, natural, double flat,\x{a}" ~
        "          double sharp (both forms), natural+flat, natural+sharp, and the quarter tone\x{a}" ~
        "          accidentals. The beam attribute records the presence of a beam in which this\x{a}" ~
        "          note participates. Software may use this attribute or beam elements for\x{a}" ~
        "          rendering. The dots attribute records the number of augmentation dots required\x{a}" ~
        "          by a dotted duration. The slur, tie, lv (laissez vibrer), and tuplet attributes\x{a}" ~
        "          encode the presence of a slur, tie, lv, or tuplet in which this note\x{a}" ~
        "          participates. Software may render slur, tie, lv or tuplet indications based on\x{a}" ~
        "          these attributes or require separate slur, tie, generic curve, or tuplet\x{a}" ~
        "          elements for visual rendition."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.note =
    att.event,
    attribute accid { data.ACCIDENTAL.EXPLICIT }?,
    attribute artic { data.ARTICULATIONS }?,
    attribute beam { data.BEAMS }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute fermata { data.PLACE }?,
    attribute lv { data.BOOLEAN }?,
    attribute oct { data.OCTAVE }?,
    attribute pname { data.PITCHNAME }?,
    attribute slur { data.SLURS }?,
    attribute syl { text }?,
    attribute tie { data.TIE }?,
    attribute tuplet { data.TUPLET }?
}
[
  xml:id = "att.vis.note"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.note" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The distance between the accidental and the\x{a}" ~
        "          note it modifies should be recorded in the accid.ho attribute. The headshape\x{a}" ~
        "          attribute may be used to override the headshape normally used for the given\x{a}" ~
        "          duration. The enclose.accid and enclose.note attributes record the symbol to be\x{a}" ~
        "          used around the accidental and the entire note, respectively. For an example of\x{a}" ~
        "          cautionary accidentals enclosed in parentheses or brackets see Read, p. 131, ex.\x{a}" ~
        "          9-14. The coloration attribute may be used to indicate a reverse coloration,\x{a}" ~
        "          i.e., black instead of white or white instead of black. The dot.ho and dot.vo\x{a}" ~
        '          attributes record the offset of the dot from its "normal" position while the\x{a}' ~
        "          dot.x and dot.y attributes record the precise position of the dot. The\x{a}" ~
        "          %att.visualoffset entity is expanded here in order to disallow a vertical\x{a}" ~
        "          offset."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.note =
    att.color,
    att.xy,
    attribute accid.ho { data.NUMBER }?,
    attribute altsym { xsd:IDREF }?,
    attribute beam.with { data.PLACE }?,
    attribute coloration { "inverse" }?,
    attribute dot.ho { data.VISUALOFFSET }?,
    attribute dot.vo { data.VISUALOFFSET }?,
    attribute dot.x { data.NUMBER }?,
    attribute dot.y { data.NUMBER }?,
    attribute enclose.accid { data.ENCLOSURE }?,
    attribute enclose.note { data.ENCLOSURE }?,
    attribute headshape { data.HEADSHAPE }?,
    attribute ho { data.VISUALOFFSET }?,
    attribute size { data.SIZE }?,
    attribute slur.dir { data.SLURDIRECTION }?,
    attribute slur.rend { "dotted" | "dashed" }?,
    attribute stem.dir { data.STEMDIRECTION }?,
    attribute stem.len { data.NUMBER }?,
    attribute stem.mod { data.STEMMODIFIER }?,
    attribute stem.pos { data.STEMPOSITION }?,
    attribute stem.with { data.PLACE }?,
    attribute stem.x { data.NUMBER }?,
    attribute stem.y { data.NUMBER }?,
    attribute tie.dir { data.TIEDIRECTION }?,
    attribute tie.rend { "dotted" | "dashed" }?,
    attribute to { data.TSTAMPOFFSET }?,
    attribute visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.octave"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.octave" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.octave = att.common.anl
}
[
  xml:id = "att.ges.octave"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.octave" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.octave = attribute dur.ges { text }?
}
[
  xml:id = "att.log.octave"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.octave" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the octave displacement while the dur.ges attribute, if it is\x{a}" ~
        "          available, encodes the performed duration. If logical and visual duration\x{a}" ~
        "          differ, it may be necessary to add a dur.vis attribute. Please note that the dur\x{a}" ~
        "          attribute here is not a true duration, but rather a time stamp for the end point\x{a}" ~
        "          of the octave displacement. The dur attribute is NOT REQUIRED because the octave\x{a}" ~
        "          displacement can be visually instantaneous. The place attribute indicates\x{a}" ~
        "          direction of displacement and display location and therefore is REQUIRED. The\x{a}" ~
        "          dis attribute states the amount of displacement while coll (Read, p. 47-48)\x{a}" ~
        "          encodes whether the octave displacement should be performed simultaneously with\x{a}" ~
        "          the written notes."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.octave =
    att.controlevent,
    att.startendid,
    attribute coll { "coll" }?,
    attribute dis { "8" | "15" | "22" },
    attribute dur { data.MEASUREBEAT }?,
    attribute place { data.PLACE }
}
[
  xml:id = "att.vis.octave"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.octave" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.octave =
    att.xy,
    att.visualoffset,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute rend { data.LINERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.ossia"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.ossia" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.ossia = att.common.anl
}
[
  xml:id = "att.ges.ossia"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.ossia" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.ossia = empty
}
[
  xml:id = "att.log.ossia"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.ossia" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.ossia = empty
}
[
  xml:id = "att.vis.ossia"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.ossia" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.ossia = empty
}
[
  xml:id = "att.anl.pad"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.pad" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.pad = empty
}
[
  xml:id = "att.ges.pad"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.pad" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.pad = empty
}
[
  xml:id = "att.log.pad"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.pad" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The num attribute is the amount of horizontal\x{a}" ~
        "          space to be added, expressed in inter-line staff units."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.pad =
    att.event,
    attribute num { data.NUMBER }
}
[
  xml:id = "att.vis.pad"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.pad" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.pad = empty
}
[
  xml:id = "att.anl.pedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.pedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.pedal = att.common.anl
}
[
  xml:id = "att.ges.pedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.pedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.pedal = empty
}
[
  xml:id = "att.log.pedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.pedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.pedal =
    att.controlevent,
    att.startendid,
    attribute dir { "down" | "up" | "half" }
}
[
  xml:id = "att.vis.pedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.pedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: When style is set to 'line', the pedal mark is\x{a}" ~
        "          rendered with a continuous line. When it's set to pedstar, a pedal down is\x{a}" ~
        '          rendered with "Ped.", a pedal up is rendered as "*", and a pedal "bounce" is\x{a}' ~
        '          rendered with "Ped. *". When set to altpedstar pedal up and down indications are\x{a}' ~
        '          the same as with pedstar but a bounce is rendered with "Ped." only.'
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.pedal =
    att.color,
    att.xy,
    att.visualoffset,
    attribute place { "below" }?,
    attribute style { "line" | "pedstar" | "altpedstar" }?
}
[
  xml:id = "att.anl.phrase"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.phrase" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The join attribute should be used for\x{a}" ~
        "          linking visually separate phrase marks, sometimes necessary due to system\x{a}" ~
        "          breaks, that form a single musical phrase."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.phrase =
    att.common.anl,
    attribute join { xsd:IDREFS }?
}
[
  xml:id = "att.ges.phrase"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.phrase" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.phrase = empty
}
[
  xml:id = "att.log.phrase"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.phrase" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Phrase may either use tstamp and duration or\x{a}" ~
        "          startid and endid attributes. It is a semantic error not to specify one of these\x{a}" ~
        "          attribute combinations."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.phrase =
    att.controlevent,
    att.startendid,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.phrase"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.phrase" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The place attribute records general, relative\x{a}" ~
        "          placement only. The bulge or, alternatively, the bezier attribute, describes the\x{a}" ~
        "          shape of the phrase mark. The bulge attribute describes the curve as a set of\x{a}" ~
        "          distance values above or below an imaginary line connecting the endpoints of the\x{a}" ~
        "          curve while the bezier attribute records the placement of Bezier control points\x{a}" ~
        "          as a series of space-separated xy coordinates, eg. 19 45 -32 118. The bulge\x{a}" ~
        "          attribute must contain one or more values of type %NUMBER. The vo attribute is\x{a}" ~
        "          the vertical offset (from its normal position) of the entire rendered phrase\x{a}" ~
        "          mark."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.phrase =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute bezier { xsd:NMTOKENS }?,
    attribute bulge { xsd:NMTOKENS }?,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute place { data.PLACE }?,
    attribute rend { data.CURVERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?
}
[
  xml:id = "att.anl.reh"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.reh" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.reh = att.common.anl
}
[
  xml:id = "att.ges.reh"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.reh" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.reh = empty
}
[
  xml:id = "att.log.reh"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.reh" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: %att.controlevent is expanded here in order to\x{a}" ~
        "          disallow the plist and layer attributes. reh may use either a tstamp or start\x{a}" ~
        "          attribute. It is a semantic error not to include one of these attributes. The\x{a}" ~
        "          a.startendid entity is expanded here in order to disallow the end\x{a}" ~
        "          attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.reh =
    attribute next { xsd:IDREFS }?,
    attribute prev { xsd:IDREFS }?,
    attribute staff { data.INTEGERPOSITIVE },
    attribute start { xsd:IDREF }?,
    attribute tstamp { data.BEAT }?,
    attribute tstamp.ges { data.INTEGERNONNEGATIVE }?,
    attribute tstamp.real { data.ISOTIME }?
}
[
  xml:id = "att.vis.reh"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.reh" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.reh =
    att.color,
    att.typography,
    att.visualoffset,
    att.xy,
    attribute enclose { "box" | "circle" | "none" }?,
    attribute place { "above" }?
}
[
  xml:id = "att.anl.rest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.rest" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.rest = att.common.anl
}
[
  xml:id = "att.ges.rest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.rest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: The dur.ges attribute records\x{a}" ~
        "          the performed duration of the rest when it differs from the written\x{a}" ~
        "          duration."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.rest =
    attribute dur.ges { text }?,
    attribute instr { xsd:IDREF }?
}
[
  xml:id = "att.log.rest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.rest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.rest =
    att.event,
    attribute beam { data.BEAMS }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute fermata { data.PLACE }?,
    attribute tuplet { data.TUPLET }?
}
[
  xml:id = "att.vis.rest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.rest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The altsym attribute indicates that the\x{a}" ~
        "          specified alternative visual symbol is to be displayed. See Read, ex. 7-14 for\x{a}" ~
        "          vertical offset example. The line attribute must contain a value from 1 to the\x{a}" ~
        "          number of stafflines. The value indicates the line upon which the rest stands.\x{a}" ~
        "          The spaces attribute states how many spaces are covered by the rest."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.rest =
    att.color,
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute beam.with { data.PLACE }?,
    attribute dot.ho { data.VISUALOFFSET }?,
    attribute dot.vo { data.VISUALOFFSET }?,
    attribute dot.x { data.NUMBER }?,
    attribute dot.y { data.NUMBER }?,
    attribute size { data.SIZE }?
}
[
  xml:id = "att.anl.pausa"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.pausa" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.pausa = att.common.anl
}
[
  xml:id = "att.ges.pausa"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.pausa" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain (performance) attributes: The dur.ges attribute records\x{a}" ~
        "          the performed duration of the rest when it differs from the written\x{a}" ~
        "          duration."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.pausa =
    attribute dur.ges { text }?,
    attribute instr { xsd:IDREF }?,
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.log.pausa"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.pausa" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: fermata = corona in the mensural\x{a}" ~
        "          repertoire."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.pausa =
    att.event,
    attribute beam { data.BEAMS }?,
    attribute corona { data.PLACE }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION.MENSURAL }?,
    attribute tuplet { data.TUPLET }?
}
[
  xml:id = "att.vis.pausa"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.pausa" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The altsym attribute indicates that the\x{a}" ~
        "          specified alternative visual symbol is to be displayed. See Read, ex. 7-14 for\x{a}" ~
        "          vertical offset example. The line attribute must contain a value from 1 to the\x{a}" ~
        "          number of stafflines. The value indicates the line upon which the rest stands.\x{a}" ~
        "          The spaces attribute states how many spaces are covered by the rest."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.pausa =
    att.color,
    att.visualoffset,
    att.xy,
    attribute altsym { xsd:IDREF }?,
    attribute beam.with { data.PLACE }?,
    attribute colored { data.BOOLEAN }?,
    attribute dot.ho { data.VISUALOFFSET }?,
    attribute dot.vo { data.VISUALOFFSET }?,
    attribute dot.x { data.NUMBER }?,
    attribute dot.y { data.NUMBER }?,
    attribute line { data.INTEGERPOSITIVE }?,
    attribute size { data.SIZE }?,
    attribute spaces { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.anl.slur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.slur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Analytical domain attributes: The join attribute should be used for\x{a}" ~
        "          linking visually separate phrase marks, sometimes necessary due to system\x{a}" ~
        "          breaks, that form a single musical phrase."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.slur =
    att.common.anl,
    attribute join { xsd:IDREFS }?
}
[
  xml:id = "att.ges.slur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.slur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.slur = empty
}
[
  xml:id = "att.log.slur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.slur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the slur. If logical and visual duration differ, it may be\x{a}" ~
        "          necessary to add a dur.vis attribute. Please note that the dur attribute is not\x{a}" ~
        "          a true duration, but rather a time stamp for the end point of the slur.\x{a}" ~
        "          Durations of longer than one measure may give the number of measures followed by\x{a}" ~
        '          the timestamp, e.g. "1m+3". Values within the current measure may be expressed\x{a}' ~
        '          as "0m+3" or as simply "3". Slur may either use tstamp and dur or startid and\x{a}' ~
        "          endid attributes. It is a semantic error not to specify one of these attribute\x{a}" ~
        "          combinations."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.slur =
    att.controlevent,
    att.startendid,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.slur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.slur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The bulge or, alternatively, the bezier\x{a}" ~
        "          attribute, describes the shape of the slur/phrase mark. The bulge attribute\x{a}" ~
        "          describes the curve as a set of distance values above or below an imaginary line\x{a}" ~
        "          connecting the endpoints of the curve while the bezier attribute records the\x{a}" ~
        "          placement of Bezier control points as a series of space-separated xy\x{a}" ~
        "          coordinates, eg. 19 45 -32 118. The bulge attribute must contain one or more\x{a}" ~
        "          values of type %NUMBER. The vo attribute is the vertical offset (from its normal\x{a}" ~
        "          position) of the entire rendered slur/phrase mark."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.slur =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute bezier { xsd:NMTOKENS }?,
    attribute bulge { xsd:NMTOKENS }?,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute place { data.PLACE }?,
    attribute rend { data.CURVERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?
}
[
  xml:id = "att.anl.space"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.space" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.space = att.common.anl
}
[
  xml:id = "att.ges.space"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.space" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.space = attribute dur.ges { text }?
}
[
  xml:id = "att.log.space"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.space" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Logical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.space =
    att.event,
    attribute beam { data.BEAMS }?,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute fermata { data.PLACE }?,
    attribute tuplet { data.TUPLET }?
}
[
  xml:id = "att.vis.space"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.space" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.space = attribute compressable { data.BOOLEAN }?
}
[
  xml:id = "att.anl.syl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.syl" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.syl = att.common.anl
}
[
  xml:id = "att.ges.syl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.syl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.syl = empty
}
[
  xml:id = "att.log.syl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.syl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Lyric syllable connectors: s (_s_pace) = word\x{a}" ~
        "          separator d (_d_ash) = syllable separator u (_u_nderscore) = syllable extension\x{a}" ~
        "          t (_t_ilde) = syllable elision wordpos attribute records the position of the\x{a}" ~
        "          syllable in a word"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.syl =
    attribute con { "s" | "d" | "u" | "t" }?,
    attribute wordpos { "i" | "m" | "t" }?
}
[
  xml:id = "att.vis.syl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.syl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The ho attribute allows any lyric syllable to\x{a}" ~
        "          be horizontally offset from its normal (centered below the note)\x{a}" ~
        "          position."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.syl =
    att.typography,
    att.visualoffset,
    att.xy,
    attribute halign { "left" | "right" | "center" | "justify" }?,
    attribute rend { data.TEXTRENDITION }?
}
[
  xml:id = "att.anl.tempo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.tempo" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.tempo = att.common.anl
}
[
  xml:id = "att.ges.tempo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.tempo" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: The midi attribute must contain the number of\x{a}" ~
        "          quarter notes per minute in the range from 10 to 1000. The value attribute is\x{a}" ~
        "          for a beats-per-minute value."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.tempo =
    attribute midi { data.MIDITEMPO }?,
    attribute value { data.TEMPOVALUE }?
}
[
  xml:id = "att.log.tempo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.tempo" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur.vis attribute encodes visual duration.\x{a}" ~
        "          (Read, p. 276-281) If logical and visual durations differ, it may be necessary\x{a}" ~
        "          to add a dur attribute. Please note that the dur attribute here is expressed in\x{a}" ~
        "          musical time, i.e. beats or other time stamp. Therefore, it is not a true\x{a}" ~
        "          duration, but rather a time stamp for the end point of the directive. The\x{a}" ~
        "          a.startendid entity is expanded here in order to disallow the end\x{a}" ~
        "          attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.tempo =
    att.controlevent,
    attribute start { xsd:IDREF }?
}
[
  xml:id = "att.vis.tempo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.tempo" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.tempo =
    att.visualoffset,
    att.xy,
    attribute dur.vis { text }?,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute place { data.PLACE }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.tie"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.tie" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.tie = att.common.anl
}
[
  xml:id = "att.ges.tie"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.tie" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.tie = empty
}
[
  xml:id = "att.log.tie"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.tie" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The a.startendid entity is expanded here in\x{a}" ~
        "          order to make startid and endid attributes required."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.tie =
    att.controlevent,
    attribute endid { xsd:IDREF },
    attribute startid { xsd:IDREF }
}
[
  xml:id = "att.vis.tie"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.tie" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The bulge or, alternatively, the bezier\x{a}" ~
        "          attribute, describes the shape of the tie. The bulge attribute describes the\x{a}" ~
        "          curve as a set of distance values above or below an imaginary line connecting\x{a}" ~
        "          the endpoints of the curve while the bezier attribute records the placement of\x{a}" ~
        "          Bezier control points as a series of space-separated xy coordinates, eg. 19 45\x{a}" ~
        "          -32 118. The bulge attribute must contain one or more values of type %NUMBER.\x{a}" ~
        "          The vo attribute is the vertical offset (from its normal position) of the entire\x{a}" ~
        "          rendered tie."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.tie =
    att.color,
    att.visualoffset,
    att.xy,
    att.xy2,
    attribute bezier { xsd:NMTOKENS }?,
    attribute bulge { xsd:NMTOKENS }?,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute endvo { data.VISUALOFFSET }?,
    attribute rend { data.CURVERENDITION }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?,
    attribute startvo { data.VISUALOFFSET }?
}
[
  xml:id = "att.anl.trill"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.trill" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.trill = att.common.anl
}
[
  xml:id = "att.ges.trill"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.trill" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Gestural domain attributes: The dur.ges attribute records the performed\x{a}" ~
        "          duration."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.trill = empty
}
[
  xml:id = "att.log.trill"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.trill" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the trill. If logical and visual duration differ, it may be\x{a}" ~
        "          necessary to add a dur.vis attribute. Please note that the dur attribute is not\x{a}" ~
        "          a true duration, but rather a time stamp for the end point of the directive.\x{a}" ~
        "          Alternatively, startid and endid attributes may be used. An accidental for the\x{a}" ~
        "          trill may be supplied in the accid attribute."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.trill =
    att.controlevent,
    att.startendid,
    attribute accid { data.ACCIDENTAL.EXPLICIT }?,
    attribute dur { data.MEASUREBEAT }?
}
[
  xml:id = "att.vis.trill"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.trill" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.trill =
    att.color,
    att.visualoffset,
    att.xy,
    attribute endho { data.VISUALOFFSET }?,
    attribute endto { data.TSTAMPOFFSET }?,
    attribute place { data.PLACE }?,
    attribute startho { data.VISUALOFFSET }?,
    attribute startto { data.TSTAMPOFFSET }?
}
[
  xml:id = "att.anl.tuplet"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.tuplet" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.tuplet = att.common.anl
}
[
  xml:id = "att.ges.tuplet"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.tuplet" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.tuplet = empty
}
[
  xml:id = "att.log.tuplet"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.tuplet" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute is the time taken up by the\x{a}" ~
        "          tuplet. If dur is omitted, the default is to calculate the total duration of the\x{a}" ~
        "          included notes and use the next shorter un-dotted value. The dots attribute may\x{a}" ~
        "          be used for dotted durations. The num and numbase attributes express a ratio.\x{a}" ~
        "          They may be used for explicit labelling of the tuplet, i.e. '3' for an 8th-note\x{a}" ~
        "          triplet, '3:2' for a quarter-note triplet, etc. The rendering of the ratio,\x{a}" ~
        "          however, is dependent on the num.format attribute described below."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.tuplet =
    att.event,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute num { data.INTEGERPOSITIVE }?,
    attribute numbase { data.DURATION }?,
    attribute with { data.PLACE }?
}
[
  xml:id = "att.vis.tuplet"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.tuplet" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The bracket.place attribute is used to state\x{a}" ~
        "          where the bracket will be placed in relation to the noteheads while the\x{a}" ~
        "          num.place attribute gives the placement of the number or ratio label for the\x{a}" ~
        "          tuplet (if num.visible is 'yes'). The num.visible, bracket.visible, and\x{a}" ~
        "          dur.visible attributes indicate whether the numbers, bracket, and duration are\x{a}" ~
        "          visible. The num.format attribute controls how the num:numbase ratio is to be\x{a}" ~
        "          displayed. software defaults: bracket.visible 'yes' num.visible 'yes'"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.tuplet =
    attribute bracket.place { data.PLACE }?,
    attribute bracket.visible { data.BOOLEAN }?,
    attribute dur.visible { data.BOOLEAN }?,
    attribute num.format { "count" | "ratio" }?,
    attribute num.place { data.PLACE }?,
    attribute num.visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.tupletspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.tupletspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.tupletspan = att.common.anl
}
[
  xml:id = "att.ges.tupletspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.tupletspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.tupletspan = empty
}
[
  xml:id = "att.log.tupletspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.tupletspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The dur attribute encodes the logical and\x{a}" ~
        "          visual duration of the tuplet. Unlike other control events where the dur\x{a}" ~
        "          attribute is expressed as a time stamp, dur here is a true duration."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.tupletspan =
    att.controlevent,
    att.startendid,
    attribute dots { data.AUGMENTDOT }?,
    attribute dur { data.DURATION }?,
    attribute num { data.RATIO }?,
    attribute numbase { data.DURATION }?,
    attribute with { data.PLACE }?
}
[
  xml:id = "att.vis.tupletspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.tupletspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: software defaults: bracket.visible 'yes' What\x{a}" ~
        "          about triplets? num.visible 'yes'"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.tupletspan =
    attribute bracket.place { data.PLACE }?,
    attribute bracket.visible { data.BOOLEAN }?,
    attribute dur.visible { data.BOOLEAN }?,
    attribute num.format { "count" | "ratio" }?,
    attribute num.place { data.PLACE }?,
    attribute num.visible { data.BOOLEAN }?
}
[
  xml:id = "att.anl.turn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.turn" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.turn = att.common.anl
}
[
  xml:id = "att.ges.turn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.turn" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.turn = empty
}
[
  xml:id = "att.log.turn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.turn" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: Accidentals for the turn may be supplied in\x{a}" ~
        "          the accidupper and accidlower attributes. The a.startendid entity is expanded\x{a}" ~
        "          here in order to disallow the end attribute. When the delayed attribute is set\x{a}" ~
        "          to 'yes', the turn begins on the second half of the beat. See Read, p.\x{a}" ~
        "          246."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.turn =
    att.controlevent,
    attribute accidupper { data.ACCIDENTAL.EXPLICIT }?,
    attribute accidlower { data.ACCIDENTAL.EXPLICIT }?,
    attribute delayed { data.BOOLEAN }?,
    attribute form { "inv" | "norm" }?,
    attribute start { xsd:IDREF }?
}
[
  xml:id = "att.vis.turn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.turn" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.turn =
    att.color,
    att.visualoffset,
    att.xy,
    attribute place { data.PLACE }?
}
[
  xml:id = "att.anl.verse"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.verse" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Analytical domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.verse = att.common.anl
}
[
  xml:id = "att.ges.verse"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.verse" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.verse = empty
}
[
  xml:id = "att.log.verse"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.verse" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The n attribute should be used for verse\x{a}" ~
        "          numbers. Numbers need not be consecutive; they may be expressed as ranges, e.g.\x{a}" ~
        "          2-3,6. A value of 'true' may be used in the refrain attribute in order to\x{a}" ~
        "          indicate a common, usually centered, refrain (Mup User's Guide, p. 44). The\x{a}" ~
        "          rhythm attribute may be used to specify a rhythm for the lyrics that differs\x{a}" ~
        "          from that of the notes on the staff."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.verse =
    attribute refrain { data.BOOLEAN }?,
    attribute rhythm { text }?
}
[
  xml:id = "att.vis.verse"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.verse" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual domain attributes: The a.visualoffset entity is expanded here in\x{a}" ~
        "          order to disallow ho."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.verse =
    att.typography,
    att.xy,
    attribute to { data.TSTAMPOFFSET }?,
    attribute vo { data.VISUALOFFSET }?
}
[
  xml:id = "att.midi.event"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.midi.event" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Attributes common to MIDI events. %att.controlevent is expanded here in\x{a}" ~
        "          order to allow only the staff, layer, and tstamp attributes from this class.\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.midi.event =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute staff { data.INTEGERPOSITIVE }?,
    attribute tstamp { data.BEAT }?
}
[
  xml:id = "att.anl.midi"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.anl.midi" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The corresp attribute may point to logical events, i.e., notes, rests,\x{a}" ~
        "          etc., to which the MIDI data is analogous. Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.anl.midi = att.common.anl
}
[
  xml:id = "att.ges.midi"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.ges.midi" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Gestural domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.ges.midi = empty
}
[
  xml:id = "att.log.midi"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.log.midi" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Logical domain attributes: The midi element may provide values for layer\x{a}" ~
        "          and staff attributes for a group of MIDI events. Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.log.midi =
    attribute layer { data.INTEGERPOSITIVE }?,
    attribute staff { data.INTEGERPOSITIVE }?
}
[
  xml:id = "att.vis.midi"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "att.vis.midi" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Visual domain attributes:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  att.vis.midi = empty
}
[
  xml:id = "model.addressLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.addressLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.addressLike = address
}
[
  xml:id = "model.annotLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.annotLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.annotLike = annot
}
[
  xml:id = "model.availabilityPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.availabilityPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.availabilityPart =
    (acqsource, (accessdesc, price?)*)*,
    userestrict?,
    sysreq?
}
[
  xml:id = "model.transcriptionLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.transcriptionLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.transcriptionLike =
    add
    | corr
    | damage
    | del
    | orig
    | reg
    | restore
    | sic
    | supplied
    | unclear
}
[
  xml:id = "model.editLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.editLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.editLike = choice | handshift | gap | subst
}
[
  xml:id = "model.editorialLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.editorialLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.editorialLike = abbr | expan
}
[
  xml:id = "model.choicePart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.choicePart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.choicePart =
    corr | orig | reg | sic | unclear | model.editorialLike
}
[
  xml:id = "model.biblLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.biblLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.biblLike = bibl
}
[
  xml:id = "model.biblPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.biblPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.biblPart = edition
}
[
  xml:id = "model.dateLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.dateLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.dateLike = date
}
[
  xml:id = "model.divLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.divLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.divLike = \div
}
[
  xml:id = "model.editorialdeclPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.editorialdeclPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.editorialdeclPart =
    correction | interpretation | normalization | segmentation | stdvals
}
[
  xml:id = "model.emphLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.emphLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.emphLike = title
}
[
  xml:id = "model.encodingPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.encodingPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.encodingPart =
    appinfo?, projectdesc?, samplingdecl?, editorialdecl?
}
[
  xml:id = "model.figureLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.figureLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.figureLike = fig
}
[
  xml:id = "model.frontPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.frontPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.frontPart = titlepage
}
[
  xml:id = "model.graphicLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.graphicLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.graphicLike = graphic
}
[
  xml:id = "model.headLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.headLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.headLike = head
}
[
  xml:id = "model.lLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.lLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.lLike = l
}
[
  xml:id = "model.labelLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.labelLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.labelLike = label
}
[
  xml:id = "model.listLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.listLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.listLike = \list
}
[
  xml:id = "model.locrefLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.locrefLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Location/referencing elements. This entity must be declared before the\x{a}" ~
        "          model.textphraseLike and model.textphraseLike.limited entities."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.locrefLike = extptr | extref | ptr | ref
}
[
  xml:id = "model.measurementLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.measurementLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.measurementLike = num
}
[
  xml:id = "model.milestoneLike.text"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.milestoneLike.text" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.milestoneLike.text = lb | pb
}
[
  xml:id = "model.nameLike.agent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.nameLike.agent" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.nameLike.agent = name | corpname | persname
}
[
  xml:id = "model.nameLike.place"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.nameLike.place" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.nameLike.place = geogname | repository
}
[
  xml:id = "model.nameLike.label"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.nameLike.label" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.nameLike.label = periodname | stylename
}
[
  xml:id = "model.pLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.pLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.pLike = p
}
[
  xml:id = "model.quoteLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.quoteLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.quoteLike = blockquote
}
[
  xml:id = "model.rendLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.rendLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.rendLike = rend | stack
}
[
  xml:id = "model.tableLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.tableLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.tableLike = table
}
[
  xml:id = "model.textphraseLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.textphraseLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Phrase-level text elements. Since these elements can occur in more than\x{a}" ~
        "          one module, they're declared in the meiShared DTD."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.textphraseLike =
    model.locrefLike
    | model.addressLike
    | model.biblLike
    | model.editorialLike
    | model.nameLike.agent
    | model.nameLike.place
    | model.nameLike.label
    | model.dateLike
    | model.rendLike
    | model.milestoneLike.text
    | model.measurementLike
    | model.emphLike
    | identifier
}
[
  xml:id = "model.textphraseLike.limited"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.textphraseLike.limited" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Anchored text sub-elements. These occur as part of the representation of\x{a}" ~
        "          the score, as opposed to the textual matter which accompanies it. %\x{a}" ~
        "          model.anchoredtext is equivalent to % model.textphraseLike without the pb\x{a}" ~
        "          element."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.textphraseLike.limited =
    model.locrefLike
    | model.addressLike
    | model.editorialLike
    | model.biblLike
    | model.nameLike.agent
    | model.nameLike.place
    | model.nameLike.label
    | model.dateLike
    | model.rendLike
    | model.measurementLike
    | model.emphLike
    | model.annotLike
    | identifier
    | lb
}
[
  xml:id = "model.paracontentPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.paracontentPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Paragraph content model. A paragraph may contain inline elements and all\x{a}" ~
        "          the other block-level elements except lg and itself. The % model.textphrase and\x{a}" ~
        "          % model.edit entities must be declared prior to the model.paracontent\x{a}" ~
        "          entity."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.paracontentPart =
    model.quoteLike
    | model.listLike
    | model.tableLike
    | model.textphraseLike
    | model.editLike
    | model.transcriptionLike
    | model.figureLike
}
[
  xml:id = "model.textcomponentLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.textcomponentLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Block level text elements. These elements are declared in the meiShared\x{a}" ~
        "          DTD."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.textcomponentLike =
    model.quoteLike
    | model.listLike
    | model.pLike
    | model.tableLike
    | model.figureLike
    | lg
}
[
  xml:id = "model.physdescPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.physdescPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.physdescPart =
    condition
    | dimensions
    | exhibithist
    | extent
    | handlist
    | inscription
    | physmedium
    | physloc
    | provenance
    | repository
    | titlepage
    | treatmenthist
    | treatmentsched
}
[
  xml:id = "model.profiledescPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.profiledescPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.profiledescPart = creation?, langusage?, classification?
}
[
  xml:id = "model.headerPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.headerPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.headerPart = encodingdesc?, profiledesc?
}
[
  xml:id = "model.chordtableLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.chordtableLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.chordtableLike = chordtable
}
[
  xml:id = "model.endingLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.endingLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.endingLike = ending
}
[
  xml:id = "model.harmLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.harmLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.harmLike = harm
}
[
  xml:id = "model.instrdefLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.instrdefLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.instrdefLike = instrdef
}
[
  xml:id = "model.keyaccidLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.keyaccidLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.keyaccidLike = keyaccid
}
[
  xml:id = "model.keysigLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.keysigLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.keysigLike = keysig
}
[
  xml:id = "model.layerLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.layerLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.layerLike = layer
}
[
  xml:id = "model.layerdefLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.layerdefLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.layerdefLike = layerdef
}
[
  xml:id = "model.measureLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.measureLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.measureLike = measure
}
[
  xml:id = "model.mdivLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.mdivLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.mdivLike = mdiv
}
[
  xml:id = "model.midiLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.midiLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Unless the meiMIDI entity's value is INCLUDE, the model.midi class of\x{a}" ~
        "          elements is not available. To activate them, the meiMIDI entity must be set to\x{a}" ~
        "          INCLUDE in the internal DTD subset or in the meiModifications.ent file. This\x{a}" ~
        "          entity must be declared before the model.controlevents entity."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.midiLike = midi
}
[
  xml:id = "model.milestoneLike.music"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.milestoneLike.music" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.milestoneLike.music = pb | sb
}
[
  xml:id = "model.noteModifierLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.noteModifierLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.noteModifierLike = accid | artic | syl | verse
}
[
  xml:id = "model.notaModifierLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.notaModifierLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.notaModifierLike = accid | artic | syl | verse
}
[
  xml:id = "model.neumeModifierLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.neumeModifierLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.neumeModifierLike = accid | artic | verse
}
[
  xml:id = "model.ornamentLike.cmn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.ornamentLike.cmn" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.ornamentLike.cmn = mordent | trill | turn
}
[
  xml:id = "model.ossiaLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.ossiaLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.ossiaLike = ossia
}
[
  xml:id = "model.partLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.partLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.partLike = part
}
[
  xml:id = "model.partsLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.partsLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.partsLike = parts
}
[
  xml:id = "model.pgmetaLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.pgmetaLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.pgmetaLike = fw*, pgdesc?
}
[
  xml:id = "model.pgmetaLike.score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.pgmetaLike.score" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.pgmetaLike.score = pghead1?, pghead2?, pgfoot1?, pgfoot2?
}
[
  xml:id = "model.pubstmtPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.pubstmtPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.pubstmtPart =
    geogname
    | model.addressLike
    | respstmt
    | model.dateLike
    | identifier
    | availability
}
[
  xml:id = "model.scoreLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.scoreLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.scoreLike = score
}
[
  xml:id = "model.scoredefLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.scoredefLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.scoredefLike = scoredef
}
[
  xml:id = "model.sectionLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.sectionLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.sectionLike = section
}
[
  xml:id = "model.staffLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.staffLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.staffLike = staff
}
[
  xml:id = "model.staffdefLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.staffdefLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.staffdefLike = staffdef
}
[
  xml:id = "model.staffgrpLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.staffgrpLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.staffgrpLike = staffgrp
}
[
  xml:id = "model.symboltableLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.symboltableLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.symboltableLike = symboltable
}
[
  xml:id = "model.controleventLike.instruments"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.controleventLike.instruments" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.controleventLike.instruments = harppedal | pedal
}
[
  xml:id = "model.controleventLike.common"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.controleventLike.common" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.controleventLike.common =
    dir | dynam | model.harmLike | phrase | reh | slur | tempo
}
[
  xml:id = "model.controleventLike.cmn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.controleventLike.cmn" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.controleventLike.cmn =
    arpeg
    | beamspan
    | breath
    | fermata
    | hairpin
    | lyrics
    | octave
    | model.ornamentLike.cmn
    | model.controleventLike.instruments
    | tie
    | tupletspan
}
[
  xml:id = "model.controleventLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.controleventLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Control events modify or otherwise depend on the existence of notated\x{a}" ~
        "          events."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.controleventLike =
    model.controleventLike.common
    | _DUMMYmodel.controleventLike.neume
    | _DUMMYmodel.controleventLike.neume-mensural
    | _DUMMYmodel.controleventLike.mensural
    | _DUMMYmodel.controleventLike.mensural-cmn
    | model.controleventLike.cmn
}
[
  xml:id = "model.eventLike.common"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.common" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.common = clefchange | custos | pad | space
}
[
  xml:id = "model.eventLike.neume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.neume" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.neume = ineume | uneume | syllable
}
[
  xml:id = "model.eventLike.neume-mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.neume-mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.neume-mensural =
    ligature | mensurchange | proportchange
}
[
  xml:id = "model.eventLike.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.mensural = nota | pausa
}
[
  xml:id = "model.eventLike.cmn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.cmn" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.cmn =
    beam
    | bend
    | beatrpt
    | btrem
    | chord
    | ftrem
    | gliss
    | halfmrpt
    | note
    | rest
    | tuplet
}
[
  xml:id = "model.eventLike.cmn.measureFilling"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike.cmn.measureFilling" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike.cmn.measureFilling =
    mrest | mrpt | mrpt2 | mspace | multirest | multirpt
}
[
  xml:id = "model.eventLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.eventLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'Notated events. Sometimes referred to as "logical" events. The mrest,\x{a}' ~
        "          mrpt, mspace, multirest, and multirpt elements are not included in this list\x{a}" ~
        "          since in the measure element's content model they are alternatives to the\x{a}" ~
        "          elements listed here. They are, however, part of the att.events class."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.eventLike =
    model.eventLike.common
    | model.eventLike.neume
    | model.eventLike.neume-mensural
    | _DUMMYmodel.eventLike.neume-cmn
    | model.eventLike.mensural
    | model.eventLike.cmn
}
[
  xml:id = "model.graphicprimitiveLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.graphicprimitiveLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Graphic primitives: curves, lines, symbols (made up of curves, lines,\x{a}" ~
        "          symbols, or anchored text), and anchoredtext"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.graphicprimitiveLike = curve | line | symbol | anchoredtext
}
[
  xml:id = "model.facsimileLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.facsimileLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Unless the meiFac entity's value is INCLUDE, the model.facsimile class of\x{a}" ~
        "          elements is not available. To activate them, the meiFac entity must be set to\x{a}" ~
        "          INCLUDE in the internal DTD subset or in the meiModifications.ent\x{a}" ~
        "          file."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.facsimileLike = facsimile
}
[
  xml:id = "model.alignLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.alignLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.alignLike = timeline
}
[
  xml:id = "model.apparatusLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.apparatusLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Unless the meiCritApp entity's value is INCLUDE, the app tag and its rdg\x{a}" ~
        "          sub-elements are not available. To activate them, the meiCrit entity must be set\x{a}" ~
        "          to INCLUDE in the internal DTD subset or in the meiModifications.ent\x{a}" ~
        "          file."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.apparatusLike = app
}
[
  xml:id = "model.clefchangePart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.clefchangePart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "By default the content model of the clefchange element is\x{a}" ~
        "          empty."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.clefchangePart = clef*
}
[
  xml:id = "model.layerPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.layerPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Notated events at the layer level" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.layerPart =
    model.eventLike
    | model.controleventLike
    | model.midiLike
    | model.annotLike
    | model.editLike
    | model.transcriptionLike
    | model.eventLike.cmn.measureFilling
}
[
  xml:id = "model.measurePart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.measurePart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Measure content model (all)" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.measurePart =
    (model.staffLike
     | model.layerLike
     | model.layerPart
     | model.apparatusLike
     | model.editLike
     | model.transcriptionLike)*
    | model.eventLike.cmn.measureFilling?
}
[
  xml:id = "model.staffdefPart.multiplyDefinable"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.staffdefPart.multiplyDefinable" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Multiple clefs" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.staffdefPart.multiplyDefinable = clef | mensur | proport
}
[
  xml:id = "model.rdgPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.rdgPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Reading content model" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.rdgPart =
    model.scoredefLike
    | model.staffgrpLike
    | model.staffdefLike
    | (model.sectionLike, model.endingLike*)
    | model.divLike
    | (model.measureLike*, model.milestoneLike.music?)*
    | (model.layerLike | model.eventLike | syl)*
    | ((model.staffLike | model.editLike | model.transcriptionLike)*,
       model.ossiaLike*,
       (model.controleventLike | model.midiLike | model.annotLike)*,
       model.graphicprimitiveLike*)
    | model.apparatusLike
}
[
  xml:id = "model.scorePart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.scorePart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Score content model (all)" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.scorePart =
    (model.measureLike | model.milestoneLike.music)* | model.staffLike*
}
[
  xml:id = "model.scorecomponentLike"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.scorecomponentLike" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.scorecomponentLike =
    model.scoredefLike
    | model.staffgrpLike
    | model.staffdefLike
    | (model.sectionLike, model.endingLike*)
    | model.divLike
    | model.scorePart
    | model.apparatusLike
}
[
  xml:id = "model.staffPart"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "model.staffPart" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Staff content model (all)" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  model.staffPart =
    (model.layerLike
     | model.milestoneLike.music
     | model.layerPart
     | model.controleventLike
     | model.midiLike
     | model.measureLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.apparatusLike)*
}
[
  xml:id = "abbr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "abbr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "abbr (abbreviation) contains an abbreviation of any sort. The type\x{a}" ~
        "          attribute may be used to classify the abbreviation according to some convenient\x{a}" ~
        "          typology. Sample values include: suspension the abbreviation provides the first\x{a}" ~
        "          letter(s) of the word or phrase, omitting the remainder. contraction the\x{a}" ~
        "          abbreviation omits some letter(s) in the middle. brevigraph the abbreviation\x{a}" ~
        "          comprises a special symbol or mark. superscription the abbreviation includes\x{a}" ~
        "          writing above the line. acronym the abbreviation comprises the initial letters\x{a}" ~
        "          of the words of a phrase. title the abbreviation is for a title of address (Dr,\x{a}" ~
        "          Ms, Mr, ...) organization the abbreviation is for the name of an organization.\x{a}" ~
        "          geographic the abbreviation is for a geographic name. This tag is the mirror\x{a}" ~
        "          image of the <expan> tag; both allow the encoder to transcribe\x{a}" ~
        "          both an abbreviation and its expansion. In <abbr>, however, the\x{a}" ~
        "          original is transcribed as the content of the element and the expansion as an\x{a}" ~
        "          attribute value; <expan> reverses this. The choice between the two\x{a}" ~
        "          is up to the user. The <abbr> tag is not required; if appropriate,\x{a}" ~
        "          the encoder may transcribe abbreviations in the source text silently, without\x{a}" ~
        "          tagging them. If abbreviations are not transcribed directly but expanded\x{a}" ~
        "          silently, then the MEI header should so indicate. The cert attribute signifies\x{a}" ~
        "          the degree of certainty ascribed to the expansion of the abbreviation. The expan\x{a}" ~
        "          attribute gives an expansion of the abbreviation. The resp attribute contains an\x{a}" ~
        "          ID reference to an element containing the name of the editor or transcriber\x{a}" ~
        "          responsible for supplying the expansion of the abbreviation. Used by:\x{a}" ~
        "          model.editorialLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  abbr = element abbr { attlist.abbr, content.abbr }
  [
    xml:id = "content.abbr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.abbr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.abbr =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.abbr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.abbr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.abbr &=
      att.common,
      att.edit,
      att.facsimile,
      att.lang,
      att.trans,
      att.typed,
      attribute expan { text }?
  }
}
[
  xml:id = "expan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "expan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "expan (expansion) contains the expansion of an abbreviation. The type\x{a}" ~
        "          attribute may be used to classify the abbreviation according to some convenient\x{a}" ~
        "          typology. See example values above. This tag is the mirror image of the\x{a}" ~
        "          <abbr> tag; both allow the encoder to transcribe both an\x{a}" ~
        "          abbreviation and its expansion. In <abbr>, however, the original\x{a}" ~
        "          is transcribed as the content of the element and the expansion as an attribute\x{a}" ~
        "          value; <expan> reverses this. The choice between the two is up to\x{a}" ~
        "          the user. The <expan> tag is not required; if appropriate, the\x{a}" ~
        "          encoder may expand abbreviations in the source text silently, without tagging\x{a}" ~
        "          them. If this is done, the MEI header should so indicate. The abbr attribute\x{a}" ~
        "          gives the abbreviation in its unexpanded form. The cert attribute signifies the\x{a}" ~
        "          degree of certainty ascribed to the expansion of the abbreviation. The resp\x{a}" ~
        "          attribute contains an ID reference to an element containing the name of the\x{a}" ~
        "          editor or transcriber responsible for supplying the expansion of the\x{a}" ~
        "          abbreviation held as the content of the <expan> element. Used by:\x{a}" ~
        "          model.editorialLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  expan = element expan { attlist.expan, content.expan }
  [
    xml:id = "content.expan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.expan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.expan =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.expan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.expan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.expan &=
      att.common,
      att.edit,
      att.facsimile,
      att.lang,
      att.trans,
      att.typed,
      attribute abbr { text }?
  }
}
[
  xml:id = "address"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "address" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A postal address Used by: model.addressLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  address = element address { attlist.address, content.address }
  [
    xml:id = "content.address"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.address" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.address = addressline+
  }
  [
    xml:id = "attlist.address"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.address" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.address &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "addressline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "addressline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Single line of an address Used by: address Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  addressline =
    element addressline { attlist.addressline, content.addressline }
  [
    xml:id = "content.addressline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.addressline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.addressline =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.addressline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.addressline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.addressline &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "bibl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "bibl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Bibliographic reference. May function as a hypertext reference to an\x{a}" ~
        "          external electronic resource. A more structured content model, similar to TEI's\x{a}" ~
        "          biblFull, requires new elements that function like those in the meiHead DTD, but\x{a}" ~
        "          that do not duplicate their names. Used by: model.biblLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  bibl = element bibl { attlist.bibl, content.bibl }
  [
    xml:id = "content.bibl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.bibl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.bibl = (text | model.biblPart | model.textphraseLike)*
  }
  [
    xml:id = "attlist.bibl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.bibl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.bibl &=
      att.common,
      att.facsimile,
      att.lang,
      att.link.common,
      att.link.external
  }
}
[
  xml:id = "blockquote"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "blockquote" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Blockquote contains a text phrase or passage attributed to a source\x{a}" ~
        "          external to the text. The source for the quote may be included in the optional\x{a}" ~
        "          bibl sub-element. Used by: model.textcomponentLike model.paracontentPart Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  blockquote =
    element blockquote { attlist.blockquote, content.blockquote }
  [
    xml:id = "content.blockquote"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.blockquote" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.blockquote = model.textcomponentLike+, model.biblLike?
  }
  [
    xml:id = "attlist.blockquote"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.blockquote" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.blockquote &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "corpname"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "corpname" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Identifies an organization or group of people that acts as an entity. May\x{a}" ~
        "          contain name parts in corpname sub-elements since corpname is included in\x{a}" ~
        "          model.textphraseLike. Used by: model.nameLike.agent Module:\x{a}" ~
        "          meiNamesDates"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  corpname = element corpname { attlist.corpname, content.corpname }
  [
    xml:id = "content.corpname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.corpname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.corpname =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.corpname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.corpname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.corpname &=
      att.bibl,
      att.common,
      att.facsimile,
      att.lang,
      att.name,
      att.typed,
      attribute role { text }?
  }
}
[
  xml:id = "date"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "date" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Date contains a date in any format. Used by: model.dateLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  date = element date { attlist.date, content.date }
  [
    xml:id = "content.date"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.date" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.date = (text | model.textphraseLike)*
  }
  [
    xml:id = "attlist.date"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.date" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.date &=
      att.bibl, att.common, att.date, att.facsimile, att.lang
  }
}
[
  xml:id = "extptr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "extptr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An empty linking element that uses attributes to connect the MEI document\x{a}" ~
        "          to an external electronic object. Don't confuse this element with the ptr\x{a}" ~
        "          element, which is an internal link for movement from one place in the MEI\x{a}" ~
        "          document to another in the same document. Used by: model.locrefLike Module:\x{a}" ~
        "          meiPtrRefs"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  extptr = element extptr { attlist.extptr, content.extptr }
  [
    xml:id = "content.extptr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.extptr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.extptr = empty
  }
  [
    xml:id = "attlist.extptr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.extptr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.extptr &= att.common, att.link.common, att.link.external
  }
}
[
  xml:id = "extref"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "extref" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A linking element that can include text and subelements as part of its\x{a}" ~
        "          reference to an electronic object that is external to the MEI document. Don't\x{a}" ~
        "          confuse this element with the ref element, which is an internal link for\x{a}" ~
        "          movement from one place in the MEI document to another in the same document.\x{a}" ~
        "          Used by: model.locrefLike Module: meiPtrRefs"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  extref = element extref { attlist.extref, content.extref }
  [
    xml:id = "content.extref"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.extref" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.extref = (text | model.textphraseLike)*
  }
  [
    xml:id = "attlist.extref"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.extref" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.extref &=
      att.common, att.lang, att.link.common, att.link.external
  }
}
[
  xml:id = "fig"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "fig" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An illustration. Used by: model.figureLike Module: meiFigures"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  fig = element fig { attlist.fig, content.fig }
  [
    xml:id = "content.fig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.fig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.fig = caption?, figdesc?, model.graphicLike*
  }
  [
    xml:id = "attlist.fig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.fig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.fig &=
      att.common,
      att.facsimile,
      att.link.common,
      att.link.external,
      att.xy
  }
}
[
  xml:id = "caption"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "caption" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A label which accompanies an illustration or a table. Used by: figure\x{a}" ~
        "          Module: meiFigures"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  caption = element caption { attlist.caption, content.caption }
  [
    xml:id = "content.caption"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.caption" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.caption =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.caption"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.caption" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.caption &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "graphic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "graphic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Indicates the location of an inline graphic, illustration, or figure.\x{a}" ~
        "          Used by: model.graphicLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  graphic = element graphic { attlist.graphic, content.graphic }
  [
    xml:id = "content.graphic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.graphic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.graphic = empty
  }
  [
    xml:id = "attlist.graphic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.graphic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.graphic &=
      att.common,
      att.facsimile,
      att.link.external,
      attribute height { data.INTEGERPOSITIVE }?,
      attribute units { text }?,
      attribute width { data.INTEGERPOSITIVE }?
  }
}
[
  xml:id = "figdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "figdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains a brief prose description of the appearance or content of a\x{a}" ~
        "          graphic figure, for use when documenting an image without displaying it. Best\x{a}" ~
        "          practice suggests the use of controlled vocabulary. Don't confuse this element\x{a}" ~
        "          with a figure caption. A caption is text primarily intended for display with an\x{a}" ~
        "          illustration. It may or may not function as a description of the illustration.\x{a}" ~
        "          Used by: figure Module: meiFigures"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  figdesc = element figdesc { attlist.figdesc, content.figdesc }
  [
    xml:id = "content.figdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.figdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.figdesc =
      (text
       | model.graphicprimitiveLike
       | model.textcomponentLike
       | model.annotLike)*
  }
  [
    xml:id = "attlist.figdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.figdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.figdesc &= att.common, att.lang
  }
}
[
  xml:id = "geogname"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "geogname" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Geographic name. The proper noun designation for a place, natural\x{a}" ~
        "          feature, or political jurisdiction. May contain name sub-parts in geogname\x{a}" ~
        "          sub-elements since geogname is included in model.textphrase. Used by:\x{a}" ~
        "          model.nameLike.place model.pubstmtPart Module: meiNamesDates"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  geogname = element geogname { attlist.geogname, content.geogname }
  [
    xml:id = "content.geogname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.geogname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.geogname =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.geogname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.geogname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.geogname &=
      att.bibl, att.common, att.facsimile, att.lang, att.name, att.typed
  }
}
[
  xml:id = "head"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "head" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains any heading, for example, the title of a text division, or the\x{a}" ~
        "          heading of a list. A head is not allowed to contain a sub-head in order to\x{a}" ~
        "          encourage the proper nesting of div elements. Used by: model.headLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  head = element head { attlist.head, content.head }
  [
    xml:id = "content.head"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.head" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.head =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.head"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.head" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.head &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "identifier"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "identifier" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Bibliographic, e.g., International Standard Book/Music Number, Library of\x{a}" ~
        "          Congress Control Number, Publisher's Number, or personal identifier. Used by:\x{a}" ~
        "          model.textphraseLike model.textphraseLike.limited model.pubstmtPart Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  identifier =
    element identifier { attlist.identifier, content.identifier }
  [
    xml:id = "content.identifier"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.identifier" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.identifier =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.identifier"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.identifier" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.identifier &= att.bibl, att.common, att.facsimile, att.typed
  }
}
[
  xml:id = "lb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "lb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Text line break. The n attribute should be used to record a label for the\x{a}" ~
        "          line, i.e. most likely a line number. See comment on verse element for\x{a}" ~
        "          description of func attribute. Used by: model.milestoneLike.text\x{a}" ~
        "          model.textphraseLike.limited Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  lb = element lb { attlist.lb, content.lb }
  [
    xml:id = "content.lb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.lb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.lb = empty
  }
  [
    xml:id = "attlist.lb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.lb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.lb &=
      att.common,
      att.facsimile,
      att.typed,
      attribute func { "line" | "group" }?,
      attribute source { xsd:IDREF }?
  }
}
[
  xml:id = "lg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "lg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Line group usually contains verse although it may be used for any section\x{a}" ~
        "          of text that is organized as a group of lines. Used by: model.textcomponentLike\x{a}" ~
        "          Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  lg = element lg { attlist.lg, content.lg }
  [
    xml:id = "content.lg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.lg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.lg = model.headLike?, model.lLike+
  }
  [
    xml:id = "attlist.lg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.lg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.lg &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "l"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "l" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Line contains a single line of text. The n attribute should be used to\x{a}" ~
        "          record a label for the line, i.e. most likely a line number. Used by:\x{a}" ~
        "          model.lLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  l = element l { attlist.l, content.l }
  [
    xml:id = "content.l"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.l" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.l =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.l"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.l" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.l &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "list"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "list" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "List. N.B. A definition list should be encoded as a 2-column table. Used\x{a}" ~
        "          by: model.listLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  \list = element list { attlist.list, content.list }
  [
    xml:id = "content.list"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.list" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.list = model.headLike?, item+
  }
  [
    xml:id = "attlist.list"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.list" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.list &=
      att.common,
      att.facsimile,
      att.lang,
      att.xy,
      attribute form { "simple" | "marked" | "ordered" }?
  }
}
[
  xml:id = "item"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "item" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Single item in a list Used by: list Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  item = element item { attlist.item, content.item }
  [
    xml:id = "content.item"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.item" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.item =
      (text
       | model.textcomponentLike
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.item"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.item" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.item &= att.common, att.facsimile
  }
}
[
  xml:id = "name"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "name" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains the name of an individual, such as 'Henry VIII, King of\x{a}" ~
        "          England', a corporate body, such as 'The Beatles', a geographical place or a\x{a}" ~
        "          generative mechanical process. The identifier and date elements are declared in\x{a}" ~
        "          the meiShared DTD. They are available here in order to record any identifiers or\x{a}" ~
        "          dates, associated with the name, i.e., birth and death in the case of persons or\x{a}" ~
        "          creation and dissolution in the case of a corporate entity or place. When name\x{a}" ~
        "          parts are needed, use name sub-elements. The recommended values for the type\x{a}" ~
        "          attribute are: pers, corp, place, process. The role attribute may be used to\x{a}" ~
        "          record the function of the person, corporate body, etc. Used by:\x{a}" ~
        "          model.nameLike.agent Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  name = element name { attlist.name, content.name }
  [
    xml:id = "content.name"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.name" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.name =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.name"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.name" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.name &=
      att.bibl,
      att.common,
      att.facsimile,
      att.lang,
      att.name,
      att.typed,
      attribute role { text }?
  }
}
[
  xml:id = "num"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "num" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A number in any form Used by: model.measurementLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  num = element num { attlist.num, content.num }
  [
    xml:id = "content.num"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.num" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.num =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.num"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.num" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.num &=
      att.common,
      att.facsimile,
      att.lang,
      attribute units { text }?
  }
}
[
  xml:id = "p"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "p" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Paragraph Used by: model.textcomponentLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  p = element p { attlist.p, content.p }
  [
    xml:id = "content.p"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.p" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.p = (text | model.paracontentPart)*
  }
  [
    xml:id = "attlist.p"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.p" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.p &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "pb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Page break. Meta-data about an accompanying page image may be recorded in\x{a}" ~
        "          the pgdesc element. The n attribute records the page number in the source. It\x{a}" ~
        "          need not be an integer, e.g. 'iv', or 'p17-3'. The logical page number can be\x{a}" ~
        "          calculated by counting previous pb ancestor elements. The source attribute is\x{a}" ~
        "          provided for linking to the bibliographic description of the source(s) that\x{a}" ~
        "          contains the page break. When used in a score context, a page break implies an\x{a}" ~
        "          accompanying system break. Permitting the following attributes will make it\x{a}" ~
        "          possible to record layout changes at a pagebreak rather than forcing a new\x{a}" ~
        "          section element: botmar %data.NUMBER; #IMPLIED height %data.NUMBER; #IMPLIED\x{a}" ~
        "          leftmar %data.NUMBER; #IMPLIED rightmar %data.NUMBER; #IMPLIED topmar\x{a}" ~
        "          %data.NUMBER; #IMPLIED spacing.system CDATA #IMPLIED width %data.NUMBER;\x{a}" ~
        "          #IMPLIED Used by: model.milestoneLike.text model.milestoneLike.music Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pb = element pb { attlist.pb, content.pb }
  [
    xml:id = "content.pb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pb = model.pgmetaLike
  }
  [
    xml:id = "attlist.pb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pb &=
      att.common,
      att.facsimile,
      att.link.common,
      att.link.external,
      attribute func { "verso" | "recto" }?,
      attribute source { xsd:IDREFS }?
  }
}
[
  xml:id = "pgdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pgdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains a brief prose description of the appearance or description of\x{a}" ~
        "          the content of a physical page. Best practice suggests the use of controlled\x{a}" ~
        "          vocabulary. Don't confuse this element with a figure caption. A caption is text\x{a}" ~
        "          primarily intended for display with an illustration. It may or may not function\x{a}" ~
        "          as a description of the illustration. Perhaps a better model is\x{a}" ~
        "          (%model.locrefLike;)* with which one could force page- level meta-data to the\x{a}" ~
        "          header where it could be encoded in notesstmt elements. Used by: pb Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pgdesc = element pgdesc { attlist.pgdesc, content.pgdesc }
  [
    xml:id = "content.pgdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pgdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pgdesc =
      (text
       | model.graphicprimitiveLike
       | model.textcomponentLike
       | model.annotLike
       | model.locrefLike)*
  }
  [
    xml:id = "attlist.pgdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pgdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pgdesc &= att.common, att.lang
  }
}
[
  xml:id = "periodname"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "periodname" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A label for a period of time, such as 'Baroque' or '3rd Style period'.\x{a}" ~
        "          Used by: model.nameLike.label Module: meiNamesDates"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  periodname =
    element periodname { attlist.periodname, content.periodname }
  [
    xml:id = "content.periodname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.periodname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.periodname =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.periodname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.periodname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.periodname &=
      att.bibl, att.common, att.facsimile, att.lang, att.name, att.typed
  }
}
[
  xml:id = "persname"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "persname" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Designation for an individual, including any or all of that individual's\x{a}" ~
        "          forenames, surnames, honorific titles, and added names. May contain name parts\x{a}" ~
        "          in persname sub-elements since persname is included in model.textphrase. Used\x{a}" ~
        "          by: model.nameLike.agent Module: meiNamesDates"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  persname = element persname { attlist.persname, content.persname }
  [
    xml:id = "content.persname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.persname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.persname =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.persname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.persname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.persname &=
      att.bibl,
      att.common,
      att.facsimile,
      att.lang,
      att.name,
      att.typed,
      attribute role { text }?
  }
}
[
  xml:id = "ptr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ptr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An empty internal linking element that uses attributes to provide for\x{a}" ~
        "          movement from one place in a MEI document to another place in the same document.\x{a}" ~
        "          Unlike the ref element, the ptr element cannot contain text or subelements to\x{a}" ~
        "          describe the referenced object. Don't confuse this element with extptr which is\x{a}" ~
        "          used to connect the MEI document to an external electronic object. Used by:\x{a}" ~
        "          model.locrefLike Module: meiPtrRefs"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ptr = element ptr { attlist.ptr, content.ptr }
  [
    xml:id = "content.ptr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ptr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ptr = empty
  }
  [
    xml:id = "attlist.ptr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ptr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ptr &= att.common, att.link.common, att.link.internal
  }
}
[
  xml:id = "ref"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ref" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An internal linking element that provides for movement from one place in\x{a}" ~
        "          a MEI document to another point in the same document. Unlike the ptr element,\x{a}" ~
        "          ref may contain text and subelements to describe the destination. Don't confuse\x{a}" ~
        "          this element with extref which provides for linking to an electronic object that\x{a}" ~
        "          is external to the MEI document. Used by: model.locrefLike Module:\x{a}" ~
        "          meiPtrRefs"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ref = element ref { attlist.ref, content.ref }
  [
    xml:id = "content.ref"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ref" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ref = (text | model.textphraseLike)*
  }
  [
    xml:id = "attlist.ref"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ref" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ref &=
      att.common, att.lang, att.link.common, att.link.internal
  }
}
[
  xml:id = "rend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "rend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Special visual rendering of text. A positive value for rotation rotates\x{a}" ~
        "          the text in a counter-clockwise fashion, while negative values produce clockwise\x{a}" ~
        "          rotation. The altrend attribute can be used to extend the values of the rend\x{a}" ~
        "          attribute. One or the other of the rend and altrend attributes is required. Used\x{a}" ~
        "          by: model.rendLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  rend = element rend { attlist.rend, content.rend }
  [
    xml:id = "content.rend"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.rend" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.rend =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.rend"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.rend" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.rend &=
      att.color,
      att.common,
      att.lang,
      att.typography,
      attribute altrend { text }?,
      attribute halign { "left" | "right" | "center" | "justify" }?,
      attribute rend { data.TEXTRENDITION }?,
      attribute rotation { data.DEGREES }?,
      attribute valign { "top" | "middle" | "bottom" | "baseline" }?
  }
}
[
  xml:id = "repository"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "repository" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Institution which holds a bibliographic item. Sub-units of the\x{a}" ~
        "          institution may be marked with nested repository elements. Used by:\x{a}" ~
        "          model.nameLike.place Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  repository =
    element repository { attlist.repository, content.repository }
  [
    xml:id = "content.repository"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.repository" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.repository = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.repository"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.repository" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.repository &=
      att.bibl, att.common, att.facsimile, att.lang, att.name, att.typed
  }
}
[
  xml:id = "stack"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "stack" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Stacked text, e.g. an inline table with a single column. Used by:\x{a}" ~
        "          model.rendLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  stack = element stack { attlist.stack, content.stack }
  [
    xml:id = "content.stack"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.stack" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.stack = (text | model.textphraseLike)*
  }
  [
    xml:id = "attlist.stack"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.stack" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.stack &=
      att.common,
      att.facsimile,
      att.lang,
      attribute delim { text }?,
      attribute align { "left" | "right" | "center" | "rightdigit" }?
  }
}
[
  xml:id = "stylename"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "stylename" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A label for a characteristic style of writing or performance, such as\x{a}" ~
        "          'bebop' or 'rock-n-roll'. May be used independently of periodname. Used by:\x{a}" ~
        "          model.nameLike.label Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  stylename = element stylename { attlist.stylename, content.stylename }
  [
    xml:id = "content.stylename"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.stylename" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.stylename =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.stylename"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.stylename" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.stylename &=
      att.bibl, att.common, att.facsimile, att.lang, att.name, att.typed
  }
}
[
  xml:id = "table"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "table" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Visual layout in tabular form Used by: model.tableLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  table = element table { attlist.table, content.table }
  [
    xml:id = "content.table"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.table" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.table = caption?, tr+
  }
  [
    xml:id = "attlist.table"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.table" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.table &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "tr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "tr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Table row Used by: table Module: meiShared" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  tr = element tr { attlist.tr, content.tr }
  [
    xml:id = "content.tr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.tr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.tr = (th | td)+
  }
  [
    xml:id = "attlist.tr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.tr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.tr &= att.common, att.facsimile, att.lang, att.xy
  }
}
[
  xml:id = "th"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "th" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Table cell containing header information Used by: table Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  th = element th { attlist.th, content.th }
  [
    xml:id = "content.th"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.th" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.th =
      (text
       | model.textcomponentLike
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.th"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.th" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.th &=
      att.common,
      att.facsimile,
      att.lang,
      att.xy,
      attribute colspan { data.INTEGERPOSITIVE }?,
      attribute rowspan { data.INTEGERPOSITIVE }?
  }
}
[
  xml:id = "td"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "td" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Table cell containing data Used by: tr Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  td = element td { attlist.td, content.td }
  [
    xml:id = "content.td"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.td" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.td =
      (text
       | model.textcomponentLike
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.td"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.td" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.td &=
      att.common,
      att.facsimile,
      att.lang,
      att.xy,
      attribute colspan { data.INTEGERPOSITIVE }?,
      attribute rowspan { data.INTEGERPOSITIVE }?
  }
}
[
  xml:id = "title"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "title" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Title of a bibliographic entity. The type attribute may be used to\x{a}" ~
        "          classify the title according to some convenient typology. Sample values include:\x{a}" ~
        "          main main title subordinate subtitle, title of part parallel alternate title,\x{a}" ~
        "          often in another language, by which the work is also known abbreviated\x{a}" ~
        "          abbreviated form of title uniform uniform title The type attribute is provided\x{a}" ~
        "          for convenience in analysing titles and processing them according to their type;\x{a}" ~
        "          where such specialized processing is not necessary, there is no need for such\x{a}" ~
        "          analysis, and the entire title, including subtitles and any parallel titles, may\x{a}" ~
        "          be enclosed within a single <title> element. The level attribute\x{a}" ~
        "          indicates whether this is the title of an article, monograph, journal, series,\x{a}" ~
        "          or unpublished material. Title parts may be encoded in title sub-elements since\x{a}" ~
        "          title is included in model.textphrase. Used by: model.emphLike Module:\x{a}" ~
        "          meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  title = element title { attlist.title, content.title }
  [
    xml:id = "content.title"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.title" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.title =
      (text
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.title"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.title" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.title &=
      att.common,
      att.facsimile,
      att.lang,
      att.typed,
      attribute level { "a" | "m" | "j" | "s" | "u" }?
  }
}
[
  xml:id = "titlepage"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "titlepage" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The titlepage element contains a transcription of the title page of a\x{a}" ~
        "          text. It may be used within the physdesc element when no other transcription is\x{a}" ~
        "          provided. Used by: model.frontPart model.physdescPart Module:\x{a}" ~
        "          meiEditTrans"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  titlepage = element titlepage { attlist.titlepage, content.titlepage }
  [
    xml:id = "content.titlepage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.titlepage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.titlepage =
      (model.textcomponentLike | model.milestoneLike.text)+
  }
  [
    xml:id = "attlist.titlepage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.titlepage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.titlepage &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "timeline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "timeline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Timeline provides a set of ordered points in time to which musical\x{a}" ~
        "          elements can be linked in order to create a temporal alignment of those\x{a}" ~
        "          elements. The origin attribute designates the origin of the timeline, i.e. the\x{a}" ~
        "          time at which it begins. It must point to one of the when elements in its\x{a}" ~
        "          content. Units specifies the unit of time corresponding to the value of the\x{a}" ~
        "          interval attribute of the timeline or of its constituent points in time. The\x{a}" ~
        "          mediacontent attribute is provided in order to link the timeline to a particular\x{a}" ~
        "          external media file, such as an audio file. The medialength attribute specifies\x{a}" ~
        "          the length of the external media file in terms of the units attribute. Used by:\x{a}" ~
        "          model.alignLike Module: meiLinkAlign"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  timeline = element timeline { attlist.timeline, content.timeline }
  [
    xml:id = "content.timeline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.timeline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.timeline = when*
  }
  [
    xml:id = "attlist.timeline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.timeline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.timeline &=
      att.common,
      attribute mediacontent { data.URI }?,
      attribute medialength { data.INTEGERPOSITIVE }?,
      attribute origin { xsd:IDREF },
      attribute units { xsd:NMTOKEN }?
  }
}
[
  xml:id = "when"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "when" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The when element indicates a point in time either absolutely (using the\x{a}" ~
        "          absolute attribute), or relative to other elements in the same timeline element\x{a}" ~
        "          (using the interval and since attributes). The absolute attribute provides an\x{a}" ~
        "          absolute value for the time associated with this point. It is required for the\x{a}" ~
        "          element designated as the origin by the parent timeline. Unit specifies the unit\x{a}" ~
        "          of time in which the @interval value is expressed, if this is not inherited from\x{a}" ~
        "          the parent timeline. Interval specifies a positive numeric time interval. The\x{a}" ~
        "          since attribute identifies the reference point for determining the time of the\x{a}" ~
        "          current when element, which is obtained by adding the interval to the time of\x{a}" ~
        "          the reference point. It should point to another when element in the same\x{a}" ~
        "          timeline. If this attribute is omitted, and the absolute attribute is not\x{a}" ~
        "          specified, then the reference point is understood to be the preceding when\x{a}" ~
        "          element. Used by: timeline Module: meiLinkAlign"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  when = element when { attlist.when, content.when }
  [
    xml:id = "content.when"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.when" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.when = empty
  }
  [
    xml:id = "attlist.when"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.when" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.when &=
      att.common,
      attribute absolute { text }?,
      attribute interval { data.NUMBERPOSITIVE }?,
      attribute since { xsd:IDREF }?,
      attribute unit { xsd:NMTOKEN }?
  }
}
[
  xml:id = "line"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "line" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Line. The x,y and x2,y2 attributes identify the two terminal points of\x{a}" ~
        "          the line. Text content of the line element, e.g. 'gliss.', may be rendered with\x{a}" ~
        "          the line. If the startid or endid attributes are present, then the x,y and x2,y2\x{a}" ~
        "          coordinates are relative to the xy coordinates of the referenced element(s).\x{a}" ~
        "          Otherwise, they are assumed to be absolute page coordinate references. Used by:\x{a}" ~
        "          model.graphicprimitiveLike Module: meiUserSym"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  line = element line { attlist.line, content.line }
  [
    xml:id = "content.line"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.line" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.line = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.line"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.line" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.line &=
      att.common.anl,
      att.color,
      att.common,
      att.facsimile,
      att.startendid,
      att.typed,
      att.xy.required,
      att.xy2.required,
      attribute rend { data.LINERENDITION }?
  }
}
[
  xml:id = "curve"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "curve" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Curve. The x1,y1 and x2,y2 attributes identify the two terminal points of\x{a}" ~
        "          the curve. If the startid or endid attributes are present, then the x,y and\x{a}" ~
        "          x2,y2 coordinates are relative to the xy coordinates of the referenced\x{a}" ~
        "          element(s). Otherwise, they are assumed to be absolute page coordinate\x{a}" ~
        "          references. The bulge or, alternatively, the bezier attribute, describe the\x{a}" ~
        "          shape of the curve. The bulge attribute describes the curve as a set of distance\x{a}" ~
        "          values above or below an imaginary line connecting the endpoints of the curve\x{a}" ~
        "          while the bezier attribute records the placement of Bezier control points as a\x{a}" ~
        "          series of space-separated xy coordinate pairs, eg. 19 45 -32 118. The bulge\x{a}" ~
        "          attribute must contain one or more values of the %NUMBER type. Either the bezier\x{a}" ~
        "          attribute or the bulge and xy coordinates are required. Used by:\x{a}" ~
        "          model.graphicprimitiveLike Module: meiUserSym"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  curve = element curve { attlist.curve, content.curve }
  [
    xml:id = "content.curve"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.curve" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.curve = empty
  }
  [
    xml:id = "attlist.curve"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.curve" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.curve &=
      att.common.anl,
      att.color,
      att.common,
      att.facsimile,
      att.startendid,
      att.typed,
      att.xy.required,
      att.xy2.required,
      attribute bezier { xsd:NMTOKENS }?,
      attribute bulge { xsd:NMTOKENS }?,
      attribute rend { data.CURVERENDITION }?
  }
}
[
  xml:id = "symbol"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "symbol" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A reference to a previously defined symbol. The x and y attributes\x{a}" ~
        '          identify the starting point, e.g. "hotspot" of the symbol. If the startid\x{a}' ~
        "          attribute is present, then the xy coordinates are relative to the xy coordinates\x{a}" ~
        "          of the referenced element. Otherwise, they are assumed to be absolute page\x{a}" ~
        "          coordinate references. The ref attribute must contain the id of a symboldef\x{a}" ~
        "          element. The scale attribute indicates that the printed output must be scaled by\x{a}" ~
        "          the specified percentage. Used by: model.graphicprimitiveLike Module:\x{a}" ~
        "          meiUserSym"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  symbol = element symbol { attlist.symbol, content.symbol }
  [
    xml:id = "content.symbol"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.symbol" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.symbol = empty
  }
  [
    xml:id = "attlist.symbol"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.symbol" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.symbol &=
      att.common.anl,
      att.color,
      att.common,
      att.facsimile,
      att.typed,
      att.xy.required,
      attribute ref { xsd:IDREF },
      attribute scale { data.PERCENT }?,
      attribute startid { xsd:IDREF }?
  }
}
[
  xml:id = "anchoredtext"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "anchoredtext" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Page-anchored text. The content model here is similar to paragraph\x{a}" ~
        "          without %model.textcomponent and %n.pb sub-elements. If the startid attribute is\x{a}" ~
        "          present, then the xy coordinates are relative to the xy coordinates of the\x{a}" ~
        "          referenced element. Otherwise, they are assumed to be absolute page coordinate\x{a}" ~
        "          references. Used by: model.graphicprimitiveLike Module: meiShared"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  anchoredtext =
    element anchoredtext { attlist.anchoredtext, content.anchoredtext }
  [
    xml:id = "content.anchoredtext"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.anchoredtext" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.anchoredtext =
      (text
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.anchoredtext"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.anchoredtext" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.anchoredtext &=
      att.common.anl,
      att.common,
      att.facsimile,
      att.lang,
      att.typed,
      att.xy.required,
      attribute startid { xsd:IDREF }?
  }
}
[
  xml:id = "group"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "group" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The group element enables the gathering of multiple documents into a\x{a}" ~
        "          single file. Because its model contains the music element, each of the documents\x{a}" ~
        "          can have its own front and back matter. Used by: music group Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  group = element group { attlist.group, content.group }
  [
    xml:id = "content.group"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.group" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.group = (music | group), (music | group)*
  }
  [
    xml:id = "attlist.group"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.group" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.group &= att.common
  }
}
[
  xml:id = "body"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "body" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The body element contains the actual music data. When the music can be\x{a}" ~
        "          broken into high-level, discrete, linear segments, such as movements in the case\x{a}" ~
        "          of a symphony, there may be multiple mdiv elements within the body. This is the\x{a}" ~
        "          highest level indication of the structure of the music. The model\x{a}" ~
        "          <!ENTITY % content.body ''> <!ELEMENT %n.body;\x{a}" ~
        "          (%n.mdiv;)*> allows the body element to be empty, which might be useful\x{a}" ~
        "          in some editing/creation situations. Used by: music Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  body = element body { attlist.body, content.body }
  [
    xml:id = "content.body"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.body" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.body = model.mdivLike+
  }
  [
    xml:id = "attlist.body"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.body" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.body &= att.common
  }
}
[
  xml:id = "mdiv"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mdiv" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The mdiv element may contain one or both of 2 possible views of the\x{a}" ~
        "          music. The score view is the traditional full and open score while the parts\x{a}" ~
        "          view contains each performer's view of the score; that is, his part. These 2\x{a}" ~
        "          views are necessary because it is not always possible or desirable to generate\x{a}" ~
        "          one from the other. The score and parts elements are placed here and not\x{a}" ~
        "          directly within the body element because score and part characteristics may\x{a}" ~
        "          change from mdiv to mdiv. For example, the 2nd movement of a symphony may\x{a}" ~
        "          require different performing forces (and therefore different score and part\x{a}" ~
        "          layout) than the other movements. Another possible model is <!ELEMENT\x{a}" ~
        "          mdiv (score?, parts?, sourcedesc*)> which allows meta-data to accompany\x{a}" ~
        "          an mdiv. However, this creates a dependency between the meiBase DTD and the\x{a}" ~
        "          meiHead DTD. The mdiv may be recursively nested in order to represent music\x{a}" ~
        "          which exhibits this kind of structure. For example, an opera is normally divided\x{a}" ~
        "          into acts, which are in turn divided into scenes. This may be represented by the\x{a}" ~
        "          following markup: <mdiv> <- the opera <mdiv>\x{a}" ~
        "          <- act I <mdiv> <- scene i <mdiv>\x{a}" ~
        "          <- scene ii </mdiv> <mdiv> <- act II\x{a}" ~
        "          <mdiv> <- scene i <mdiv> <- scene ii\x{a}" ~
        "          </mdiv> </mdiv> Used by: body mdiv Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mdiv = element mdiv { attlist.mdiv, content.mdiv }
  [
    xml:id = "content.mdiv"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mdiv" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mdiv =
      (model.scoreLike?, model.partsLike?) | model.mdivLike*
  }
  [
    xml:id = "attlist.mdiv"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mdiv" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mdiv &= att.common, att.facsimile, att.typed
  }
}
[
  xml:id = "score"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "score" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Full score view of the mdiv. Since the measure element is optional, a\x{a}" ~
        "          score may consist entirely of pagebreaks, each of which points to a page image.\x{a}" ~
        "          The pb element is declared in the meiShared DTD. Div elements are allowed\x{a}" ~
        "          preceding and following sections of music data in order to accommodate blocks of\x{a}" ~
        "          explanatory text. Used by: model.scoreLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  score = element score { attlist.score, content.score }
  [
    xml:id = "content.score"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.score" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.score = model.scorecomponentLike*
  }
  [
    xml:id = "attlist.score"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.score" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.score &=
      att.common,
      att.typed,
      att.log.score,
      att.vis.score,
      att.ges.score,
      att.anl.score
  }
}
[
  xml:id = "scoredef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "scoredef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for score meta-information. Used by: model.scoredefLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  scoredef = element scoredef { attlist.scoredef, content.scoredef }
  [
    xml:id = "content.scoredef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.scoredef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.scoredef =
      model.alignLike*,
      model.chordtableLike?,
      model.symboltableLike?,
      model.keysigLike?,
      model.pgmetaLike.score,
      (model.staffgrpLike? | model.staffdefLike?)
  }
  [
    xml:id = "attlist.scoredef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.scoredef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.scoredef &=
      att.common,
      att.log.scoredef,
      att.vis.scoredef,
      att.ges.scoredef,
      att.anl.scoredef
  }
}
[
  xml:id = "parts"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "parts" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Parts view of the mdiv. Used by: partsLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  parts = element parts { attlist.parts, content.parts }
  [
    xml:id = "content.parts"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.parts" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.parts = model.partLike*
  }
  [
    xml:id = "attlist.parts"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.parts" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.parts &=
      att.common,
      att.typed,
      att.log.parts,
      att.vis.parts,
      att.ges.parts,
      att.anl.parts
  }
}
[
  xml:id = "part"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "part" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A part is an alternative visual rendition of the score from a particular\x{a}" ~
        "          performer's point of view. Part elements are not used in the score to indicate\x{a}" ~
        "          voice leading. Next attributes on event elements should be used for this\x{a}" ~
        "          purpose. Part elements are useful for encoding individual parts when there is no\x{a}" ~
        "          score, such as early music part books, when the music has non-aligning barlines,\x{a}" ~
        "          when different layout, such as page turns, are needed for the score and parts,\x{a}" ~
        "          or for accommodating software that requires part-by-part encoding. When assembly\x{a}" ~
        "          of the parts into a score is desired and there are non-aligning barlines,\x{a}" ~
        "          barlines which indicate points of alignment across all the parts should be\x{a}" ~
        "          marked as 'controlling', while non-aligning ones should be marked as 'non-\x{a}" ~
        "          controlling'. The pb sub-element is declared in the meiShared DTD. Used by:\x{a}" ~
        "          model.partLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  part = element part { attlist.part, content.part }
  [
    xml:id = "content.part"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.part" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.part = model.scorecomponentLike*
  }
  [
    xml:id = "attlist.part"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.part" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.part &=
      att.common,
      att.typed,
      att.log.part,
      att.vis.part,
      att.ges.part,
      att.anl.part
  }
}
[
  xml:id = "chordtable"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chordtable" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Chord/tablature look-up table. A table may be shared between mei\x{a}" ~
        "          instances through the use of an external parsed entity containing the look-up\x{a}" ~
        "          table to be shared. Used by: model.chordtableLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chordtable =
    element chordtable { attlist.chordtable, content.chordtable }
  [
    xml:id = "content.chordtable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chordtable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chordtable = chorddef+
  }
  [
    xml:id = "attlist.chordtable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chordtable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chordtable &= att.common
  }
}
[
  xml:id = "chorddef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chorddef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Chord/tablature definition. An individual chord in the chord table. An id\x{a}" ~
        "          isn't required here but harm elements can only reference a particular chorddef\x{a}" ~
        "          via an id. Therefore, if a chorddef will ever be referenced, an id is necessary.\x{a}" ~
        "          The pos (position) attribute is provided in order to create displayable chord\x{a}" ~
        "          tablature grids. (Read, p. 409-410) Used by: chordtable Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chorddef = element chorddef { attlist.chorddef, content.chorddef }
  [
    xml:id = "content.chorddef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chorddef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chorddef = chordmember*, barre*
  }
  [
    xml:id = "attlist.chorddef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chorddef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chorddef &=
      att.common,
      attribute pos { text }?
  }
}
[
  xml:id = "chordmember"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chordmember" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Chord member. An individual pitch in a chord. The fing and fret\x{a}" ~
        "          attributes are provided in order to create displayable chord tablature grids.\x{a}" ~
        "          The inth (harmonic interval) attribute gives the number of 1/2 steps above the\x{a}" ~
        "          bass. Of course, for the bass note itself, inth should be set to '0'. The inth\x{a}" ~
        '          attribute may be used to provide "playable" chords. Used by: chordmember\x{a}' ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chordmember =
    element chordmember { attlist.chordmember, content.chordmember }
  [
    xml:id = "content.chordmember"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chordmember" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chordmember = empty
  }
  [
    xml:id = "attlist.chordmember"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chordmember" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chordmember &=
      att.common,
      attribute accid { data.ACCIDENTAL.IMPLICIT }?,
      attribute fing { "x" | "o" | "1" | "2" | "3" | "4" | "5" }?,
      attribute fret { "1" | "2" | "3" | "4" | "5" }?,
      attribute inth { data.INTEGERNONNEGATIVE }?,
      attribute pname { data.PITCHNAME }
  }
}
[
  xml:id = "barre"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "barre" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An indication of fingering in a chord tablature grid. The from and to\x{a}" ~
        "          attributes should contain the id of a chordmember element. Used by: chorddef\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  barre = element barre { attlist.barre, content.barre }
  [
    xml:id = "content.barre"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.barre" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.barre = empty
  }
  [
    xml:id = "attlist.barre"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.barre" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.barre &=
      att.common,
      attribute fret { "1" | "2" | "3" | "4" | "5" },
      attribute from { xsd:IDREF },
      attribute to { xsd:IDREF }
  }
}
[
  xml:id = "symboltable"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "symboltable" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Symboltable contains individual, user-defined symbols. Like a chord\x{a}" ~
        "          table, a symboltable may be shared between mei instances through the use of an\x{a}" ~
        "          external parsed entity containing the symboltable to be shared. Used by:\x{a}" ~
        "          model.symboltableLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  symboltable =
    element symboltable { attlist.symboltable, content.symboltable }
  [
    xml:id = "content.symboltable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.symboltable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.symboltable = symboldef+
  }
  [
    xml:id = "attlist.symboltable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.symboltable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.symboltable &= att.common
  }
}
[
  xml:id = "symboldef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "symboldef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Declaration of an individual symbol. The elements referred to by the\x{a}" ~
        "          %model.primitives entity are declared in the meiShared DTD. Used by: symboltable\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  symboldef = element symboldef { attlist.symboldef, content.symboldef }
  [
    xml:id = "content.symboldef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.symboldef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.symboldef = model.graphicprimitiveLike+
  }
  [
    xml:id = "attlist.symboldef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.symboldef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.symboldef &= att.common
  }
}
[
  xml:id = "instrdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "instrdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Default MIDI instrument declaration. This element provides a starting or\x{a}" ~
        "          default instrument declaration for a staff, a group of staves, or a layer. MIDI\x{a}" ~
        "          prog elements may then change the instrument as necessary. Used by: instrdefLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  instrdef = element instrdef { attlist.instrdef, content.instrdef }
  [
    xml:id = "content.instrdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.instrdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.instrdef = empty
  }
  [
    xml:id = "attlist.instrdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.instrdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.instrdef &=
      att.common,
      attribute midi.channel { data.MIDICHANNEL }?,
      attribute midi.duty { data.PERCENT }?,
      attribute midi.instr { data.MIDIVALUE }?,
      attribute midi.instrname { text }?,
      attribute midi.port { data.MIDIVALUE }?,
      attribute midi.track { data.INTEGERPOSITIVE }?
  }
}
[
  xml:id = "pghead1"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pghead1" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A running header on the first page. This element is a specialized form of\x{a}" ~
        "          the fw element for capturing the table-formatted textual data that often appears\x{a}" ~
        "          on the first page of printed music. It may also be used for similarly formatted\x{a}" ~
        "          material in manuscripts. The pgheadN and pgfootN elements should *not* be used\x{a}" ~
        "          to encode textual notes! Auto- generated page numbers may be indicated with a\x{a}" ~
        "          processing instruction. Used by: model.pgmetaLike.score Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pghead1 = element pghead1 { attlist.pghead1, content.pghead1 }
  [
    xml:id = "content.pghead1"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pghead1" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pghead1 = model.tableLike*
  }
  [
    xml:id = "attlist.pghead1"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pghead1" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pghead1 &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "pghead2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pghead2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A running header on the pages following the first. This element is a\x{a}" ~
        "          specialized form of the fw element. The pgheadN and pgfootN elements should\x{a}" ~
        "          *not* be used to encode textual notes! Auto-generated page numbers may be\x{a}" ~
        "          indicated with a processing instruction. Used by: model.pgmetaLike.score\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pghead2 = element pghead2 { attlist.pghead2, content.pghead2 }
  [
    xml:id = "content.pghead2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pghead2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pghead2 = model.tableLike*
  }
  [
    xml:id = "attlist.pghead2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pghead2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pghead2 &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "pgfoot1"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pgfoot1" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A running footer on the first page. This element is a specialized form of\x{a}" ~
        "          the fw element. Auto-generated page numbers may be indicated with a processing\x{a}" ~
        "          instruction. The pgheadN and pgfootN elements should *not* be used to encode\x{a}" ~
        "          textual notes! Used by: model.pgmetaLike.score Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pgfoot1 = element pgfoot1 { attlist.pgfoot1, content.pgfoot1 }
  [
    xml:id = "content.pgfoot1"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pgfoot1" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pgfoot1 = model.tableLike*
  }
  [
    xml:id = "attlist.pgfoot1"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pgfoot1" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pgfoot1 &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "pgfoot2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pgfoot2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A running header on the pages following the first. This element is a\x{a}" ~
        "          specialized form of the fw element. Auto-generated page numbers may be indicated\x{a}" ~
        "          with a processing instruction. The pgheadN and pgfootN elements should *not* be\x{a}" ~
        "          used to encode textual notes! Used by: model.pgmetaLike.score Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pgfoot2 = element pgfoot2 { attlist.pgfoot2, content.pgfoot2 }
  [
    xml:id = "content.pgfoot2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pgfoot2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pgfoot2 = model.tableLike*
  }
  [
    xml:id = "attlist.pgfoot2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pgfoot2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pgfoot2 &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "label"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "label" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Staff, staffgrp, or grpsym label Used by: model.labelLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  label = element label { attlist.label, content.label }
  [
    xml:id = "content.label"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.label" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.label =
      (text
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.label"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.label" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.label &=
      att.common,
      att.facsimile,
      attribute source { xsd:IDREF }?
  }
}
[
  xml:id = "staffgrp"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "staffgrp" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A group of staves. Bracketed staff groups may contain other bracketed or\x{a}" ~
        "          braced staff groups or single staves. See Read, p. 35-38, examples p. 434, 438.\x{a}" ~
        "          System is the more proper name for this concept (Read, p. 37-38). Split staffgrp\x{a}" ~
        "          into bracket and brace elements? Used by: staffgrpLike staffgrp\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  staffgrp = element staffgrp { attlist.staffgrp, content.staffgrp }
  [
    xml:id = "content.staffgrp"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.staffgrp" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.staffgrp =
      model.labelLike*,
      model.instrdefLike*,
      (model.staffgrpLike | model.staffdefLike)+,
      grpsym*
  }
  [
    xml:id = "attlist.staffgrp"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.staffgrp" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.staffgrp &=
      att.common,
      att.facsimile,
      att.log.staffgrp,
      att.vis.staffgrp,
      att.ges.staffgrp,
      att.anl.staffgrp
  }
}
[
  xml:id = "grpsym"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "grpsym" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Group symbol, i.e., a brace or bracket. This element may be used instead\x{a}" ~
        "          of the staffgrp element's symbol attribute when exact placement or editorial\x{a}" ~
        "          details for the brace must be recorded. Used by: staffgrp Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  grpsym = element grpsym { attlist.grpsym, content.grpsym }
  [
    xml:id = "content.grpsym"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.grpsym" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.grpsym = model.labelLike*
  }
  [
    xml:id = "attlist.grpsym"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.grpsym" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.grpsym &=
      att.common,
      att.facsimile,
      att.log.grpsym,
      att.vis.grpsym,
      att.ges.grpsym,
      att.anl.grpsym
  }
}
[
  xml:id = "staff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "staff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Staff. The n attribute is a connection back to the appropriate staffdef\x{a}" ~
        "          element. If the n attribute is omitted, encoding order is presumed to match the\x{a}" ~
        "          staff order. Of course, if data is supplied for only a subset of staves, the n\x{a}" ~
        "          attribute must be supplied. Used by: model.staffLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  staff = element staff { attlist.staff, content.staff }
  [
    xml:id = "content.staff"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.staff" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.staff = model.staffPart
  }
  [
    xml:id = "attlist.staff"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.staff" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.staff &=
      att.common,
      att.facsimile,
      att.log.staff,
      att.vis.staff,
      att.ges.staff,
      att.anl.staff
  }
}
[
  xml:id = "staffdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "staffdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for staff meta-information. Used by: model.rdgPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  staffdef = element staffdef { attlist.staffdef, content.staffdef }
  [
    xml:id = "content.staffdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.staffdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.staffdef =
      model.labelLike*,
      model.keysigLike?,
      (model.instrdefLike
       | model.layerdefLike
       | model.staffdefPart.multiplyDefinable)*
  }
  [
    xml:id = "attlist.staffdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.staffdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.staffdef &=
      att.common,
      att.log.staffdef,
      att.vis.staffdef,
      att.ges.staffdef,
      att.anl.staffdef
  }
}
[
  xml:id = "clef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "clef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The clef element must be used when a staff employs multiple simultaneous\x{a}" ~
        "          clefs. Used by: model.clefchangePart model.staffdefPart.multiplyDefinable\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  clef = element clef { attlist.clef, content.clef }
  [
    xml:id = "content.clef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.clef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.clef = empty
  }
  [
    xml:id = "attlist.clef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.clef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.clef &=
      att.common,
      att.facsimile,
      att.anl.clef,
      att.ges.clef,
      att.log.clef,
      att.vis.clef
  }
}
[
  xml:id = "layer"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "layer" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Layer (voice). The n attribute should be used to establish a connection\x{a}" ~
        '          back to the appropriate layerdef element. Usually, the topmost layer is "1",\x{a}' ~
        '          next is "2", etc. *regardless of voicing*). If the n attribute is omitted,\x{a}' ~
        "          encoding order is presumed to match the layer order. Of course, if data is\x{a}" ~
        "          supplied for only a subset of layers, the n attribute must be supplied. Used by:\x{a}" ~
        "          model.layerLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  layer = element layer { attlist.layer, content.layer }
  [
    xml:id = "content.layer"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.layer" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.layer = model.layerPart*
  }
  [
    xml:id = "attlist.layer"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.layer" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.layer &=
      att.common,
      att.facsimile,
      att.log.layer,
      att.vis.layer,
      att.ges.layer,
      att.anl.layer
  }
}
[
  xml:id = "layerdef"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "layerdef" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for layer (e.g. voice) meta-information. Used by: layerdefLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  layerdef = element layerdef { attlist.layerdef, content.layerdef }
  [
    xml:id = "content.layerdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.layerdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.layerdef = model.instrdefLike*
  }
  [
    xml:id = "attlist.layerdef"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.layerdef" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.layerdef &=
      att.common,
      att.log.layerdef,
      att.vis.layerdef,
      att.ges.layerdef,
      att.anl.layerdef
  }
}
[
  xml:id = "section"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "section" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The section element contains actual music data. The pb sub-element is\x{a}" ~
        "          declared in the meiShared DTD. The linking attributes are available here so that\x{a}" ~
        "          this element can point to external media objects or to related internal\x{a}" ~
        "          elements, such as annotations. Used by: model.rdgPart section Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  section = element section { attlist.section, content.section }
  [
    xml:id = "content.section"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.section" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.section = model.scorecomponentLike*
  }
  [
    xml:id = "attlist.section"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.section" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.section &=
      att.common,
      att.facsimile,
      att.typed,
      att.link.common,
      att.link.external,
      att.link.internal,
      att.log.section,
      att.vis.section,
      att.ges.section,
      att.anl.section
  }
}
[
  xml:id = "ending"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ending" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Alternative ending. The scoredef element is allowed so that an ending may\x{a}" ~
        "          have its own meta-data without the overhead of child <section>s.\x{a}" ~
        "          Div sub-elements are not allowed within ending in order to avoid collisions with\x{a}" ~
        "          the brackets that are usually displayed over endings. The pb sub-element is\x{a}" ~
        "          declared in the meiShared DTD. Endings may *not* contain endings. Used by:\x{a}" ~
        "          model.endingLike ending Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ending = element ending { attlist.ending, content.ending }
  [
    xml:id = "content.ending"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ending" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ending = model.scorecomponentLike*
  }
  [
    xml:id = "attlist.ending"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ending" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ending &=
      att.common,
      att.facsimile,
      att.typed,
      att.link.common,
      att.link.external,
      att.link.internal,
      att.anl.ending,
      att.ges.ending,
      att.log.ending,
      att.vis.ending
  }
}
[
  xml:id = "fw"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "fw" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Forme work, e.g. header and footer. This element is intended for capture\x{a}" ~
        "          of header/footer material that is non-repeating; that is, it occurs on isolated\x{a}" ~
        "          pages. For running headers and footers use pgheadN and pgfootN elements.\x{a}" ~
        "          Auto-generated page numbers may be included with a processing instruction. Used\x{a}" ~
        "          by: model.pgmetaLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  fw = element fw { attlist.fw, content.fw }
  [
    xml:id = "content.fw"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.fw" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.fw =
      (text
       | model.textcomponentLike
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.fw"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.fw" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.fw &= att.common, att.facsimile, att.lang, att.typed
  }
}
[
  xml:id = "sb"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "sb" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "System break. Allowing staffdef content, i.e., <!ENTITY %\x{a}" ~
        "          content.sb ''> <!ELEMENT %n.sb; (staffdef)*>, here would\x{a}" ~
        "          make it possible to record layout changes without requiring these changes to be\x{a}" ~
        "          made at section boundaries. However, it would also allow meter and key changes,\x{a}" ~
        "          which is probably undesirable. Used by: model.milestoneLike.music\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  sb = element sb { attlist.sb, content.sb }
  [
    xml:id = "content.sb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.sb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.sb = custos?
  }
  [
    xml:id = "attlist.sb"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.sb" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.sb &=
      att.common,
      att.facsimile,
      att.log.sb,
      att.vis.sb,
      att.ges.sb,
      att.anl.sb
  }
}
[
  xml:id = "custos"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "custos" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Custos Used by: model.eventLike.common Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  custos = element custos { attlist.custos, content.custos }
  [
    xml:id = "content.custos"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.custos" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.custos = empty
  }
  [
    xml:id = "attlist.custos"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.custos" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.custos &=
      att.common,
      att.facsimile,
      att.log.custos,
      att.vis.custos,
      att.ges.sb,
      att.anl.sb
  }
}
[
  xml:id = "barline"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "barline" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The barline element may be used instead of the measure element. It has\x{a}" ~
        "          the same attributes as measure. However, it is only available when the\x{a}" ~
        "          meiMensural or meiBarlines entity has been set to INCLUDE. Used by:\x{a}" ~
        "          model.eventLike.mensural-cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  barline = element barline { attlist.barline, content.barline }
  [
    xml:id = "content.barline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.barline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.barline = empty
  }
  [
    xml:id = "attlist.barline"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.barline" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.barline &=
      att.common,
      att.facsimile,
      att.link.common,
      att.link.internal,
      att.link.external,
      att.log.barline,
      att.vis.barline,
      att.ges.barline,
      att.anl.barline
  }
}
[
  xml:id = "ligature"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ligature" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The ligature element is provided for the encoding of mensural notation.\x{a}" ~
        "          It is only available when the meiMensural entity has been set to INCLUDE. Used\x{a}" ~
        "          by: model.eventLike.neume-mensural Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ligature = element ligature { attlist.ligature, content.ligature }
  [
    xml:id = "content.ligature"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ligature" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ligature = model.eventLike* | (accid | artic | verse)*
  }
  [
    xml:id = "attlist.ligature"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ligature" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ligature &=
      att.common,
      att.facsimile,
      att.log.ligature,
      att.vis.ligature,
      att.ges.ligature,
      att.anl.ligature
  }
}
[
  xml:id = "dot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "dot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The dot element is provided for the encoding of mensural notation. It is\x{a}" ~
        "          only available when the meiMensural entity has been set to INCLUDE. The dot\x{a}" ~
        "          element may be used for dots of augmentation or division. Used by:\x{a}" ~
        "          model.eventLike.mensural-cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  dot = element dot { attlist.dot, content.dot }
  [
    xml:id = "content.dot"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.dot" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.dot = empty
  }
  [
    xml:id = "attlist.dot"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.dot" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.dot &=
      att.common,
      att.facsimile,
      att.log.dot,
      att.vis.dot,
      att.ges.dot,
      att.anl.dot
  }
}
[
  xml:id = "mensur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mensur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The mensur element is provided for the encoding of mensural notation. It\x{a}" ~
        "          is only available when the meiMensural or meiNeumes entity has been set to\x{a}" ~
        "          INCLUDE. Used by: model.staffdefPart.multiplyDefinable Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mensur = element mensur { attlist.mensur, content.mensur }
  [
    xml:id = "content.mensur"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mensur" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mensur = empty
  }
  [
    xml:id = "attlist.mensur"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mensur" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mensur &=
      att.common,
      att.facsimile,
      att.log.mensur,
      att.vis.mensur,
      att.ges.mensur,
      att.anl.mensur
  }
}
[
  xml:id = "mensurchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mensurchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Mensuration change. This element is only available when meiMensural is\x{a}" ~
        "          set to INCLUDE. Used by: model.eventLike.neume-mensural Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mensurchange =
    element mensurchange { attlist.mensurchange, content.mensurchange }
  [
    xml:id = "content.mensurchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mensurchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mensurchange = mensur+
  }
  [
    xml:id = "attlist.mensurchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mensurchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mensurchange &= att.common, att.facsimile
  }
}
[
  xml:id = "proport"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "proport" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Proportion. This element is only available when meiMensural is set to\x{a}" ~
        "          INCLUDE. Used by: model.staffdefPart.multiplyDefinable Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  proport = element proport { attlist.proport, content.proport }
  [
    xml:id = "content.proport"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.proport" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.proport = empty
  }
  [
    xml:id = "attlist.proport"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.proport" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.proport &=
      att.common,
      att.facsimile,
      att.log.proport,
      att.vis.proport,
      att.ges.proport,
      att.anl.proport
  }
}
[
  xml:id = "proportchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "proportchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Proportion change. This element is only available when meiMensural is set\x{a}" ~
        "          to INCLUDE. Used by: model.eventLike.neume-mensural Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  proportchange =
    element proportchange {
      attlist.proportchange, content.proportchange
    }
  [
    xml:id = "content.proportchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.proportchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.proportchange = proport+
  }
  [
    xml:id = "attlist.proportchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.proportchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.proportchange &= att.common, att.facsimile
  }
}
[
  xml:id = "keysig"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "keysig" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Key signature. This element may be used as an alternative to the key.*\x{a}" ~
        "          attributes (especially key.sig.mixed) on scoredef and staffdef. Used by:\x{a}" ~
        "          model.keysigLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  keysig = element keysig { attlist.keysig, content.keysig }
  [
    xml:id = "content.keysig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.keysig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.keysig = model.keyaccidLike*
  }
  [
    xml:id = "attlist.keysig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.keysig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.keysig &=
      att.common,
      att.facsimile,
      attribute accid { data.ACCIDENTAL.IMPLICIT }?,
      attribute mode { data.MODE }?,
      attribute pname { data.PITCHNAME }?
  }
}
[
  xml:id = "keyaccid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "keyaccid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Accidental in a key signature. It is a semantic error not to provide x\x{a}" ~
        "          and y or staffloc attributes. Used by: model.keyaccidLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  keyaccid = element keyaccid { attlist.keyaccid, content.keyaccid }
  [
    xml:id = "content.keyaccid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.keyaccid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.keyaccid = empty
  }
  [
    xml:id = "attlist.keyaccid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.keyaccid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.keyaccid &=
      att.common,
      att.facsimile,
      att.xy,
      attribute enclose { data.ENCLOSURE }?,
      attribute form { "implicit" | "explicit" }?,
      attribute oct { data.OCTAVE }?,
      attribute pname { data.PITCHNAME },
      attribute staffloc { data.STAFFLOC }?,
      attribute value { data.ACCIDENTAL.EXPLICIT }
  }
}
[
  xml:id = "keychange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "keychange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Key change. This element is only available when meiMensural is set to\x{a}" ~
        "          INCLUDE. Used by: model.eventLike.mensural-cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  keychange = element keychange { attlist.keychange, content.keychange }
  [
    xml:id = "content.keychange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.keychange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.keychange = model.keyaccidLike*
  }
  [
    xml:id = "attlist.keychange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.keychange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.keychange &= att.common, att.facsimile
  }
}
[
  xml:id = "measure"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "measure" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'Measure. "In Western notation a vertical line drawn through the staff to\x{a}' ~
        "          mark off metrical units. Hence also the metrical unit thus indicated, which in\x{a}" ~
        "          American usage is called 'measure'. English usage often relies on context alone\x{a}" ~
        "          to make the distinction clear (e.g. 'up to the double bar', 'the end of the\x{a}" ~
        """          bar'), but 'bar-line' is also common." (New Grove) In MEI, the measure element\x{a}""" ~
        "          is also a linking element that uses attributes to connect the MEI document to an\x{a}" ~
        "          external electronic object or to another location within the MEI instance. Any\x{a}" ~
        "          number of alternative encodings for the measure (ossia) can be included. Used\x{a}" ~
        "          by: model.measureLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  measure = element measure { attlist.measure, content.measure }
  [
    xml:id = "content.measure"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.measure" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.measure =
      model.staffdefLike*,
      (model.measurePart
       | model.ossiaLike
       | model.controleventLike
       | model.midiLike
       | model.annotLike
       | model.graphicprimitiveLike)*
  }
  [
    xml:id = "attlist.measure"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.measure" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.measure &=
      att.common,
      att.facsimile,
      att.typed,
      att.link.common,
      att.link.internal,
      att.link.external,
      att.log.measure,
      att.vis.measure,
      att.ges.measure,
      att.anl.measure
  }
}
[
  xml:id = "ossia"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ossia" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'The term "ossia" indicates an alternative, usually simpler, version of a\x{a}' ~
        "          measure *present in the source being transcribed*. An ossia may be treated as a\x{a}" ~
        "          substitute for the measure, in which case it is rendered on the current staff,\x{a}" ~
        "          or it may be rendered in addition to the measure's contents, in which case it is\x{a}" ~
        "          rendered above the staff on a reduced-size staff. Used by: model.ossiaLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ossia = element ossia { attlist.ossia, content.ossia }
  [
    xml:id = "content.ossia"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ossia" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ossia =
      model.staffdefLike*,
      (model.measurePart
       | model.ossiaLike
       | model.controleventLike
       | model.midiLike
       | model.annotLike
       | model.graphicprimitiveLike)*
  }
  [
    xml:id = "attlist.ossia"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ossia" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ossia &=
      att.common,
      att.facsimile,
      att.log.ossia,
      att.vis.ossia,
      att.ges.ossia,
      att.anl.ossia
  }
}
[
  xml:id = "beam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "beam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Beam. A container for a series of explicitly beamed events (Read, p.\x{a}" ~
        "          80-94) which begins and ends entirely within a measure. For beams which cross\x{a}" ~
        "          the barline, use the beamspan element. Beaming may be indicated for an entire\x{a}" ~
        "          score, part or section by using the beamgroup attribute on these elements.\x{a}" ~
        "          Secondary beams may be broken explicitly using the breaksec attribute. Stem\x{a}" ~
        "          direction determines whether beams are centered between notes with alternating\x{a}" ~
        "          stems (Read, p. 88-89). Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  beam = element beam { attlist.beam, content.beam }
  [
    xml:id = "content.beam"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.beam" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.beam =
      (beam | chord | clefchange | note | pad | rest | space | tuplet)+
  }
  [
    xml:id = "attlist.beam"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.beam" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.beam &=
      att.common,
      att.facsimile,
      att.log.beam,
      att.vis.beam,
      att.ges.beam,
      att.anl.beam
  }
}
[
  xml:id = "beatrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "beatrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A repeated single beat (Read, p. 223-224) Used by: model.eventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  beatrpt = element beatrpt { attlist.beatrpt, content.beatrpt }
  [
    xml:id = "content.beatrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.beatrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.beatrpt = empty
  }
  [
    xml:id = "attlist.beatrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.beatrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.beatrpt &=
      att.common,
      att.facsimile,
      att.log.beatrpt,
      att.vis.beatrpt,
      att.ges.beatrpt,
      att.anl.beatrpt
  }
}
[
  xml:id = "chord"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chord" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Chord, a simultaneous sounding of 2 or more notes in the same voice *with\x{a}" ~
        "          the same duration*. (Read, p. 69) Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chord = element chord { attlist.chord, content.chord }
  [
    xml:id = "content.chord"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chord" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chord = (note | artic)*
  }
  [
    xml:id = "attlist.chord"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chord" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chord &=
      att.common,
      att.facsimile,
      att.log.chord,
      att.vis.chord,
      att.ges.chord,
      att.anl.chord
  }
}
[
  xml:id = "clefchange"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "clefchange" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Mid-measure clef change. Coming as it does, in the middle of a measure, a\x{a}" ~
        "          clef change is an event. Used by: model.eventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  clefchange =
    element clefchange { attlist.clefchange, content.clefchange }
  [
    xml:id = "content.clefchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.clefchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.clefchange = model.clefchangePart
  }
  [
    xml:id = "attlist.clefchange"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.clefchange" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.clefchange &=
      att.common,
      att.event,
      att.facsimile,
      att.log.clefchange,
      att.vis.clefchange,
      att.ges.clefchange,
      att.anl.clefchange
  }
}
[
  xml:id = "mrest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mrest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Complete measure rest in any meter (Read, p. 97-98). The numbering of\x{a}" ~
        "          consecutive measures of rest may be controlled via the multi.number attribute on\x{a}" ~
        "          the scoredef or staffdef elements. Used by: model.eventLike.cmn.measureFilling\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mrest = element mrest { attlist.mrest, content.mrest }
  [
    xml:id = "content.mrest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mrest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mrest = empty
  }
  [
    xml:id = "attlist.mrest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mrest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mrest &=
      att.common,
      att.facsimile,
      att.log.mrest,
      att.vis.mrest,
      att.ges.mrest,
      att.anl.mrest
  }
}
[
  xml:id = "mspace"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mspace" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Complete measure of space in any meter. The numbering of consecutive\x{a}" ~
        "          measures of space may be controlled via the multi.number attribute on the\x{a}" ~
        "          scoredef or staffdef elements. Used by: model.eventLike.cmn.measureFilling\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mspace = element mspace { attlist.mspace, content.mspace }
  [
    xml:id = "content.mspace"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mspace" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mspace = empty
  }
  [
    xml:id = "attlist.mspace"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mspace" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mspace &=
      att.common,
      att.facsimile,
      att.log.mspace,
      att.vis.mspace,
      att.ges.mspace,
      att.anl.mspace
  }
}
[
  xml:id = "mrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A repeated measure (Read, p. 224-225). The numbering of consecutive\x{a}" ~
        "          measures of rest may be controlled via the multi.number attribute on the\x{a}" ~
        "          scoredef or staffdef elements. Used by: model.eventLike.cmn.measureFilling\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mrpt = element mrpt { attlist.mrpt, content.mrpt }
  [
    xml:id = "content.mrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mrpt = empty
  }
  [
    xml:id = "attlist.mrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mrpt &=
      att.common,
      att.facsimile,
      att.log.mrpt,
      att.vis.mrpt,
      att.ges.mrpt,
      att.anl.mrpt
  }
}
[
  xml:id = "mrpt2"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mrpt2" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "2-measure repeat sign Used by: model.eventLike.cmn.measureFilling\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mrpt2 = element mrpt2 { attlist.mrpt2, content.mrpt2 }
  [
    xml:id = "content.mrpt2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mrpt2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mrpt2 = empty
  }
  [
    xml:id = "attlist.mrpt2"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mrpt2" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mrpt2 &=
      att.common,
      att.facsimile,
      att.log.mrpt2,
      att.vis.mrpt2,
      att.ges.mrpt2,
      att.anl.mrpt2
  }
}
[
  xml:id = "halfmrpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "halfmrpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Half-measure repeat sign Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  halfmrpt = element halfmrpt { attlist.halfmrpt, content.halfmrpt }
  [
    xml:id = "content.halfmrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.halfmrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.halfmrpt = model.eventLike*
  }
  [
    xml:id = "attlist.halfmrpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.halfmrpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.halfmrpt &=
      att.common,
      att.facsimile,
      att.log.halfmrpt,
      att.vis.halfmrpt,
      att.ges.halfmrpt,
      att.anl.halfmrpt
  }
}
[
  xml:id = "multirest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "multirest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Multiple measures of rest. Used by: model.eventLike.cmn.measureFilling\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  multirest = element multirest { attlist.multirest, content.multirest }
  [
    xml:id = "content.multirest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.multirest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.multirest = empty
  }
  [
    xml:id = "attlist.multirest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.multirest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.multirest &=
      att.common,
      att.facsimile,
      att.log.multirest,
      att.vis.multirest,
      att.ges.multirest,
      att.anl.multirest
  }
}
[
  xml:id = "multirpt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "multirpt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Multiple repeated measures. Read (p. 225-226) says repeats of more than 2\x{a}" ~
        "          measures should be written out using repeat signs. Used by:\x{a}" ~
        "          model.eventLike.cmn.measureFilling Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  multirpt = element multirpt { attlist.multirpt, content.multirpt }
  [
    xml:id = "content.multirpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.multirpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.multirpt = empty
  }
  [
    xml:id = "attlist.multirpt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.multirpt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.multirpt &=
      att.common,
      att.facsimile,
      att.log.multirpt,
      att.vis.multirpt,
      att.ges.multirpt,
      att.anl.multirpt
  }
}
[
  xml:id = "note"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "note" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Note (Read, p. 63), a single pitched event. The note element is allowed\x{a}" ~
        "          to contain other events for situations where a single written note may be\x{a}" ~
        "          representative of a group of performed notes. The accid and artic sub-elements\x{a}" ~
        "          may be used instead of the note element's attributes when accid and artic\x{a}" ~
        "          represent first-class objects, e.g. when they require attributes, such as x and\x{a}" ~
        "          y location attributes. Similarly, the syl sub-element may be used instead of the\x{a}" ~
        "          syl attribute. The verse sub-element may be used to group text syllables by\x{a}" ~
        "          verse. Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  note = element note { attlist.note, content.note }
  [
    xml:id = "content.note"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.note" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.note =
      (model.eventLike
       | model.noteModifierLike
       | model.apparatusLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.note"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.note" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.note &=
      att.common,
      att.facsimile,
      att.log.note,
      att.vis.note,
      att.ges.note,
      att.anl.note
  }
}
[
  xml:id = "accid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "accid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Accidental. This element provides an alternative to the acci attributes\x{a}" ~
        "          on the note element. The element should be used when specific display info, such\x{a}" ~
        "          as size or color, needs to be recorded for the accidental. The func attribute\x{a}" ~
        "          can be used to differentiate different functions, such as 'cautionary' or\x{a}" ~
        "          'editorial'. Used by: model.noteModifierLike model.notaModifierLike\x{a}" ~
        "          model.neumeModifierLike model.eventLike.mensural-cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  accid = element accid { attlist.accid, content.accid }
  [
    xml:id = "content.accid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.accid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.accid = empty
  }
  [
    xml:id = "attlist.accid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.accid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.accid &=
      att.common,
      att.facsimile,
      att.typography,
      att.log.accid,
      att.vis.accid,
      att.ges.accid,
      att.anl.accid
  }
}
[
  xml:id = "artic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "artic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Articulation. This element provides an alternative to the artic\x{a}" ~
        "          attributes on the note and chord elements. The element should be used when when\x{a}" ~
        "          specific display info, such as size or color, needs to be recorded for the\x{a}" ~
        "          articulation. Used by: model.noteModifierLike model.notaModifierLike\x{a}" ~
        "          model.neumeModifierLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  artic = element artic { attlist.artic, content.artic }
  [
    xml:id = "content.artic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.artic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.artic = empty
  }
  [
    xml:id = "attlist.artic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.artic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.artic &=
      att.common,
      att.facsimile,
      att.typography,
      att.log.artic,
      att.vis.artic,
      att.ges.artic,
      att.anl.artic
  }
}
[
  xml:id = "btrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "btrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Bowed tremolo (Read, p. 393-394) is a rapid alternation on a single pitch\x{a}" ~
        "          or chord. This element should also be used for wind double and triple tonguing\x{a}" ~
        "          and for flutter tonguing when these are expressed as tremolandi. Used by:\x{a}" ~
        "          model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  btrem = element btrem { attlist.btrem, content.btrem }
  [
    xml:id = "content.btrem"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.btrem" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.btrem = chord | note
  }
  [
    xml:id = "attlist.btrem"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.btrem" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.btrem &=
      att.common,
      att.facsimile,
      att.log.btrem,
      att.vis.btrem,
      att.ges.btrem,
      att.anl.btrem
  }
}
[
  xml:id = "ftrem"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ftrem" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Fingered tremolo (Read, p. 235-238) is a rapid alternation between a pair\x{a}" ~
        "          of notes (or chords or perhaps between a note and a chord) that are (usually)\x{a}" ~
        "          farther apart than a major second. For rapid alternation between notes on the\x{a}" ~
        "          same pitch (bowed tremolo, double & triple tonguing, and flutter\x{a}" ~
        "          tonguing) use the btrem element. Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ftrem = element ftrem { attlist.ftrem, content.ftrem }
  [
    xml:id = "content.ftrem"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ftrem" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ftrem =
      (chord, (chord | note))
      | (note, (chord | note))
  }
  [
    xml:id = "attlist.ftrem"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ftrem" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ftrem &=
      att.common,
      att.facsimile,
      att.log.ftrem,
      att.vis.ftrem,
      att.ges.ftrem,
      att.anl.ftrem
  }
}
[
  xml:id = "pad"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pad" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Used to create additional visual space between notational elements. Used\x{a}" ~
        "          by: model.eventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pad = element pad { attlist.pad, content.pad }
  [
    xml:id = "content.pad"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pad" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pad = empty
  }
  [
    xml:id = "attlist.pad"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pad" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pad &=
      att.common, att.log.pad, att.vis.pad, att.ges.pad, att.anl.pad
  }
}
[
  xml:id = "rest"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "rest" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Rest (Read, p. 96-102), i.e. a non-sounding event, found in the source\x{a}" ~
        "          being transcribed. Do not confuse this element with the space element which is\x{a}" ~
        "          used as an aid for visual alignment. Used by: model.eventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  rest = element rest { attlist.rest, content.rest }
  [
    xml:id = "content.rest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.rest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.rest = empty
  }
  [
    xml:id = "attlist.rest"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.rest" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.rest &=
      att.common,
      att.facsimile,
      att.log.rest,
      att.vis.rest,
      att.ges.rest,
      att.anl.rest
  }
}
[
  xml:id = "space"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "space" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A placeholder used to fill an incomplete measure, layer, etc. most often\x{a}" ~
        "          so that the combined duration of the events equals the number of beats in the\x{a}" ~
        "          measure. Used by: model.eventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  space = element space { attlist.space, content.space }
  [
    xml:id = "content.space"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.space" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.space = empty
  }
  [
    xml:id = "attlist.space"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.space" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.space &=
      att.common,
      att.facsimile,
      att.log.space,
      att.vis.space,
      att.ges.space,
      att.anl.space
  }
}
[
  xml:id = "tuplet"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "tuplet" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Tuplet (Read, p. 187-215), bowed tremolo (Read, p. 394) & double,\x{a}" ~
        "          triple, or flutter tonguing (Read, p. 348-349). The beam sub-element is allowed\x{a}" ~
        "          so that custom beaming may be indicated, i.e. a septuplet may be divided into a\x{a}" ~
        "          group of 3 plus a group of 4 notes. Used by: model.eventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  tuplet = element tuplet { attlist.tuplet, content.tuplet }
  [
    xml:id = "content.tuplet"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.tuplet" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.tuplet =
      (beam | chord | clefchange | note | pad | rest | space | tuplet)+
  }
  [
    xml:id = "attlist.tuplet"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.tuplet" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.tuplet &=
      att.common,
      att.facsimile,
      att.log.tuplet,
      att.vis.tuplet,
      att.ges.tuplet,
      att.anl.tuplet
  }
}
[
  xml:id = "annot"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "annot" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The annot element provides a way to group participating *events* and/or\x{a}" ~
        "          *control events*, the notes that form a descending bass line or phrase marks,\x{a}" ~
        "          for example, and provide a label for or comment regarding the group. An\x{a}" ~
        "          enumerated list of event IDs may be given in the plist attribute. Alternatively,\x{a}" ~
        "          if only the start and/or end events in a group are to be marked, then use the\x{a}" ~
        "          startid and endid attributes. An editorial or analytical comment or observation,\x{a}" ~
        "          encoded elsewhere, such as in the front or back matter, in score text elements,\x{a}" ~
        "          or in an external document may be pointed to using the link.common,\x{a}" ~
        "          link.internal, or link.external attributes. Alternatively, the observation may\x{a}" ~
        "          be included directly within the annot element. The annot element, along with\x{a}" ~
        "          other elements with %att.link.external attributes, may also be used to link/\x{a}" ~
        "          synchronize elements within the MEI file to external media such as images or\x{a}" ~
        "          sound recordings. The ID of the MEI element(s) to be linked from should be\x{a}" ~
        "          encoded in the plist attribute while the link to the external media may be\x{a}" ~
        "          encoded in the href or entityref attributes or in the body of the annotation\x{a}" ~
        "          using extref or extptr elements. Used by: model.annotLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  annot = element annot { attlist.annot, content.annot }
  [
    xml:id = "content.annot"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.annot" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.annot =
      (text
       | model.textcomponentLike
       | model.textphraseLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.annot"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.annot" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.annot &=
      att.common,
      att.facsimile,
      att.lang,
      att.typed,
      att.log.annot,
      att.vis.annot,
      att.ges.annot,
      att.anl.annot,
      att.link.common,
      att.link.internal,
      att.link.external,
      attribute resp { xsd:IDREF }?,
      attribute source { xsd:IDREFS }?
  }
}
[
  xml:id = "arpeg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "arpeg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Arpeggiation, roll (Read, p. 241-243). Used by:\x{a}" ~
        "          model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  arpeg = element arpeg { attlist.arpeg, content.arpeg }
  [
    xml:id = "content.arpeg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.arpeg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.arpeg = empty
  }
  [
    xml:id = "attlist.arpeg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.arpeg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.arpeg &=
      att.common,
      att.facsimile,
      att.log.arpeg,
      att.vis.arpeg,
      att.ges.arpeg,
      att.anl.arpeg
  }
}
[
  xml:id = "beamspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "beamspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Alternative element for encoding beams, especially useful for beams which\x{a}" ~
        "          extend across barlines. Used by: model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  beamspan = element beamspan { attlist.beamspan, content.beamspan }
  [
    xml:id = "content.beamspan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.beamspan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.beamspan = empty
  }
  [
    xml:id = "attlist.beamspan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.beamspan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.beamspan &=
      att.common,
      att.facsimile,
      att.log.beamspan,
      att.vis.beamspan,
      att.ges.beamspan,
      att.anl.beamspan
  }
}
[
  xml:id = "bend"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "bend" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Bend (stretching a string to make it sound higher than normal). The bend\x{a}" ~
        "          element can also be used for scoop, plop, falloff, and doit performance effects.\x{a}" ~
        "          It should *not* be used for l.v. (laissez vibrer) indications. Precise\x{a}" ~
        "          performance data that differs from the logical events in a measure may be\x{a}" ~
        "          recorded within the bend element. Used by: model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  bend = element bend { attlist.bend, content.bend }
  [
    xml:id = "content.bend"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.bend" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.bend = (note | rest | tuplet)*
  }
  [
    xml:id = "attlist.bend"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.bend" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.bend &=
      att.common,
      att.facsimile,
      att.log.bend,
      att.vis.bend,
      att.ges.bend,
      att.anl.bend
  }
}
[
  xml:id = "breath"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "breath" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The breathmark element is a specialized form of, i.e., syntactic sugar\x{a}" ~
        '          for, dir/@type="breathmark" with "," as its PCDATA content. Used by:\x{a}' ~
        "          model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  breath = element breath { attlist.breath, content.breath }
  [
    xml:id = "content.breath"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.breath" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.breath = empty
  }
  [
    xml:id = "attlist.breath"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.breath" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.breath &=
      att.common,
      att.facsimile,
      att.log.breath,
      att.vis.breath,
      att.ges.breath,
      att.anl.breath
  }
}
[
  xml:id = "dir"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "dir" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Directives, e.g. text expressions that are on the score (typically above,\x{a}" ~
        "          below, or between staves), but not on the staff and not encoded elsewhere, such\x{a}" ~
        "          as in tempo or dynam elements. Examples include text strings, such as\x{a}" ~
        "          'affettuoso' or fingerings and music symbols, such as segno and coda symbols,\x{a}" ~
        "          fermatas over a barline, etc. Unlike generic text elements, directives can be\x{a}" ~
        "          control elements. That is, they can be used as pointers to other events. The\x{a}" ~
        "          %model.textphraseLike.limited entity is employed here instead of\x{a}" ~
        "          %model.textphrase in order to disallow use of the pb sub-element. Used by:\x{a}" ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  dir = element dir { attlist.dir, content.dir }
  [
    xml:id = "content.dir"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.dir" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.dir =
      (text
       | model.textphraseLike.limited
       | model.graphicprimitiveLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.dir"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.dir" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.dir &=
      att.common,
      att.facsimile,
      att.lang,
      att.typed,
      att.log.dir,
      att.vis.dir,
      att.ges.dir,
      att.anl.dir
  }
}
[
  xml:id = "dynam"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "dynam" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The dynam element may be used for instantaneous or continuous textual\x{a}" ~
        "          dynamics, e.g. 'p', 'mf', or 'cresc. poco a poco'. See Read, p. 250-255. The\x{a}" ~
        "          hairpin element should be used for graphical dynamic markings. The\x{a}" ~
        "          %model.textphraseLike.limited entity is employed here instead of\x{a}" ~
        "          %model.textphrase in order to disallow use of the pb sub-element. Used by:\x{a}" ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  dynam = element dynam { attlist.dynam, content.dynam }
  [
    xml:id = "content.dynam"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.dynam" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.dynam =
      (text
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.dynam"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.dynam" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.dynam &=
      att.common,
      att.facsimile,
      att.log.dynam,
      att.vis.dynam,
      att.ges.dynam,
      att.anl.dynam
  }
}
[
  xml:id = "fermata"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "fermata" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The fermata element is a specialized form of, i.e., syntactic sugar for,\x{a}" ~
        '          dir/@type="fermata" with &ferm; or &uferm; as its PCDATA\x{a}' ~
        "          content. Used by: model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  fermata = element fermata { attlist.fermata, content.fermata }
  [
    xml:id = "content.fermata"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.fermata" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.fermata = empty
  }
  [
    xml:id = "attlist.fermata"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.fermata" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.fermata &=
      att.common,
      att.facsimile,
      att.log.fermata,
      att.vis.fermata,
      att.ges.fermata,
      att.anl.fermata
  }
}
[
  xml:id = "gliss"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "gliss" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Glissando (Read, p. 243-245, 397-398). Sometimes called a 'slide'. More\x{a}" ~
        "          precise performance data may be recorded within the gliss element. Used by:\x{a}" ~
        "          model.eventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  gliss = element gliss { attlist.gliss, content.gliss }
  [
    xml:id = "content.gliss"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.gliss" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.gliss = (note | rest | tuplet)*
  }
  [
    xml:id = "attlist.gliss"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.gliss" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.gliss &=
      att.common,
      att.facsimile,
      att.log.gliss,
      att.vis.gliss,
      att.ges.gliss,
      att.anl.gliss
  }
}
[
  xml:id = "hairpin"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "hairpin" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Hairpin indicates continuous dynamics expressed on the score as graphics,\x{a}" ~
        "          e.g. < and >. See Read, p. 250-255. Used by:\x{a}" ~
        "          model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  hairpin = element hairpin { attlist.hairpin, content.hairpin }
  [
    xml:id = "content.hairpin"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.hairpin" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.hairpin = empty
  }
  [
    xml:id = "attlist.hairpin"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.hairpin" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.hairpin &=
      att.common,
      att.facsimile,
      att.log.hairpin,
      att.vis.hairpin,
      att.ges.hairpin,
      att.anl.hairpin
  }
}
[
  xml:id = "harm"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "harm" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Indication of harmony, e.g. chord names, tablature grids, harmonic\x{a}" ~
        "          analysis, figured bass. Read, p. 411. The %model.textphraseLike.limited entity\x{a}" ~
        "          is employed here instead of %model.textphrase in order to disallow the use of\x{a}" ~
        "          the pb sub-element. Used by: model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  harm = element harm { attlist.harm, content.harm }
  [
    xml:id = "content.harm"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.harm" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.harm =
      (text
       | model.textphraseLike.limited
       | model.graphicprimitiveLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.harm"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.harm" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.harm &=
      att.common,
      att.facsimile,
      att.log.harm,
      att.vis.harm,
      att.ges.harm,
      att.anl.harm
  }
}
[
  xml:id = "harppedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "harppedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Harp pedal diagram Used by: model.controleventLike.instruments\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  harppedal = element harppedal { attlist.harppedal, content.harppedal }
  [
    xml:id = "content.harppedal"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.harppedal" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.harppedal = empty
  }
  [
    xml:id = "attlist.harppedal"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.harppedal" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.harppedal &=
      att.common,
      att.facsimile,
      att.log.harppedal,
      att.vis.harppedal,
      att.ges.harppedal,
      att.anl.harppedal
  }
}
[
  xml:id = "lyrics"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "lyrics" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Lyrics. The staff attribute gives the staff to which the lyrics are\x{a}" ~
        "          attached. The rhythm of the lyrics will be taken from the notes of that staff.\x{a}" ~
        "          If there is more than 1 layer on that staff, the layer attribute may be used to\x{a}" ~
        "          indicate the layer from which the rhythm should be taken. Used by:\x{a}" ~
        "          model.controleventLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  lyrics = element lyrics { attlist.lyrics, content.lyrics }
  [
    xml:id = "content.lyrics"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.lyrics" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.lyrics = verse+
  }
  [
    xml:id = "attlist.lyrics"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.lyrics" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.lyrics &=
      att.common,
      att.facsimile,
      att.lang,
      att.log.lyrics,
      att.vis.lyrics,
      att.ges.lyrics,
      att.anl.lyrics
  }
}
[
  xml:id = "verse"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "verse" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Lyric verse. The lb element is allowed here in order to facilitate\x{a}" ~
        "          karaoke applications. The func attribute on lb may be used to distinguish true\x{a}" ~
        "          line ends from line group ends for these applications. Used by:\x{a}" ~
        "          model.noteModifierLike model.notaModifierLike model.neumeModifierLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  verse = element verse { attlist.verse, content.verse }
  [
    xml:id = "content.verse"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.verse" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.verse = (dir | dynam | tempo | space)*, syl+, lb*
  }
  [
    xml:id = "attlist.verse"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.verse" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.verse &=
      att.common,
      att.facsimile,
      att.lang,
      att.log.verse,
      att.vis.verse,
      att.ges.verse,
      att.anl.verse
  }
}
[
  xml:id = "syl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "syl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Individual lyric syllable. Used by: model.noteModifierLike\x{a}" ~
        "          model.notaModifierLike model.rdgPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  syl = element syl { attlist.syl, content.syl }
  [
    xml:id = "content.syl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.syl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.syl =
      (text
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.syl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.syl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.syl &=
      att.common,
      att.facsimile,
      att.log.syl,
      att.vis.syl,
      att.ges.syl,
      att.anl.syl
  }
}
[
  xml:id = "mordent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mordent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Events may be contained within mordent in order to record precise\x{a}" ~
        "          performance data. (Read, p. 245-246) Used by: model.ornamentLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mordent = element mordent { attlist.mordent, content.mordent }
  [
    xml:id = "content.mordent"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.mordent" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.mordent = model.eventLike*
  }
  [
    xml:id = "attlist.mordent"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mordent" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mordent &=
      att.common,
      att.facsimile,
      att.log.mordent,
      att.vis.mordent,
      att.ges.mordent,
      att.anl.mordent
  }
}
[
  xml:id = "octave"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "octave" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Octave displacement. Used by: model.controleventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  octave = element octave { attlist.octave, content.octave }
  [
    xml:id = "content.octave"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.octave" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.octave = empty
  }
  [
    xml:id = "attlist.octave"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.octave" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.octave &=
      att.common,
      att.facsimile,
      att.log.octave,
      att.vis.octave,
      att.ges.octave,
      att.anl.octave
  }
}
[
  xml:id = "pedal"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pedal" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Piano pedal mark (Read, p. 317-318). Used by:\x{a}" ~
        "          model.controleventLike.instruments Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pedal = element pedal { attlist.pedal, content.pedal }
  [
    xml:id = "content.pedal"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pedal" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pedal = empty
  }
  [
    xml:id = "attlist.pedal"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pedal" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pedal &=
      att.common,
      att.facsimile,
      att.log.pedal,
      att.vis.pedal,
      att.ges.pedal,
      att.anl.pedal
  }
}
[
  xml:id = "phrase"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "phrase" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'Phrase mark, used for a "unified melodic idea" (Read, p. 265). Used by:\x{a}' ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  phrase = element phrase { attlist.phrase, content.phrase }
  [
    xml:id = "content.phrase"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.phrase" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.phrase = empty
  }
  [
    xml:id = "attlist.phrase"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.phrase" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.phrase &=
      att.common,
      att.facsimile,
      att.log.phrase,
      att.vis.phrase,
      att.ges.phrase,
      att.anl.phrase
  }
}
[
  xml:id = "reh"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "reh" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Rehearsal mark (Read, p. 443). The content model uses a subset of\x{a}" ~
        "          %model.textphraseLike.limited. If the entire rehearsal mark is boxed or circled,\x{a}" ~
        "          the enclose attribute is preferred over a rend sub-element. Used by:\x{a}" ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  reh = element reh { attlist.reh, content.reh }
  [
    xml:id = "content.reh"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.reh" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.reh = (text | lb | model.rendLike)*
  }
  [
    xml:id = "attlist.reh"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.reh" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.reh &=
      att.common,
      att.facsimile,
      att.log.reh,
      att.vis.reh,
      att.ges.reh,
      att.anl.reh
  }
}
[
  xml:id = "slur"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "slur" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Slur, 2 notes performed legato (Read, p. 265-266). The slur element will\x{a}" ~
        "          use either tstamp, duration, and place attributes or start, end, and bulge\x{a}" ~
        "          attributes. It is a semantic error not to specify one of these groups of\x{a}" ~
        "          attributes. The slur and tie elements may be used instead of the slur.* and\x{a}" ~
        "          tie.* attributes provided on chord and note elements when 1) they are required\x{a}" ~
        "          by software, or 2) multiple, alternative slurs are needed. Normally, a slur has\x{a}" ~
        "          only 2 participating events - the starting and ending notes/chords. Used by:\x{a}" ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  slur = element slur { attlist.slur, content.slur }
  [
    xml:id = "content.slur"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.slur" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.slur = empty
  }
  [
    xml:id = "attlist.slur"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.slur" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.slur &=
      att.common,
      att.facsimile,
      att.log.slur,
      att.vis.slur,
      att.ges.slur,
      att.anl.slur
  }
}
[
  xml:id = "tempo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "tempo" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        'Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.",\x{a}' ~
        '          "a tempo", "cantabile", "Moderato", "[qtrnote]=60", "Moderato [qtrnote] =60").\x{a}' ~
        '          Both "instantaneous" and "continuous" tempo markings may be encoded using this\x{a}' ~
        "          element. The %model.textphraseLike.limited entity is employed here instead of\x{a}" ~
        "          %model.textphrase in order to disallow the use of the pb sub-element. Used by:\x{a}" ~
        "          model.controleventLike.common Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  tempo = element tempo { attlist.tempo, content.tempo }
  [
    xml:id = "content.tempo"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.tempo" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.tempo =
      (text
       | model.textphraseLike.limited
       | model.graphicprimitiveLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.tempo"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.tempo" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.tempo &=
      att.common,
      att.facsimile,
      att.lang,
      att.log.tempo,
      att.vis.tempo,
      att.ges.tempo,
      att.anl.tempo
  }
}
[
  xml:id = "tie"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "tie" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Tie (Read, p. 110-111, 122). Used by: model.controleventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  tie = element tie { attlist.tie, content.tie }
  [
    xml:id = "content.tie"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.tie" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.tie = empty
  }
  [
    xml:id = "attlist.tie"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.tie" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.tie &=
      att.common,
      att.facsimile,
      att.log.tie,
      att.vis.tie,
      att.ges.tie,
      att.anl.tie
  }
}
[
  xml:id = "trill"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "trill" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Trill (Read, p. 232-235). Events may be contained within trill in order\x{a}" ~
        "          to record precise performance data. Used by: model.ornamentLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  trill = element trill { attlist.trill, content.trill }
  [
    xml:id = "content.trill"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.trill" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.trill = model.eventLike*
  }
  [
    xml:id = "attlist.trill"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.trill" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.trill &=
      att.common,
      att.facsimile,
      att.log.trill,
      att.vis.trill,
      att.ges.trill,
      att.anl.trill
  }
}
[
  xml:id = "tupletspan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "tupletspan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Alternative element for encoding tuplets, especially useful for those\x{a}" ~
        "          which extend across barlines. Used by: model.controleventLike.cmn\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  tupletspan =
    element tupletspan { attlist.tupletspan, content.tupletspan }
  [
    xml:id = "content.tupletspan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.tupletspan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.tupletspan = empty
  }
  [
    xml:id = "attlist.tupletspan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.tupletspan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.tupletspan &=
      att.common,
      att.facsimile,
      att.log.tupletspan,
      att.vis.tupletspan,
      att.ges.tupletspan,
      att.anl.tupletspan
  }
}
[
  xml:id = "turn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "turn" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Turn (Read, p. 246-247). Events may be contained within turn in order to\x{a}" ~
        "          record precise performance data. Whether the turn is accented or unaccented may\x{a}" ~
        "          be inferred from the timestamp - accented turns occur directly on the affected\x{a}" ~
        "          beat, unaccented ones do not. Used by: model.ornamentLike.cmn Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  turn = element turn { attlist.turn, content.turn }
  [
    xml:id = "content.turn"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.turn" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.turn = model.eventLike*
  }
  [
    xml:id = "attlist.turn"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.turn" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.turn &=
      att.common,
      att.facsimile,
      att.log.turn,
      att.vis.turn,
      att.ges.turn,
      att.anl.turn
  }
}
[
  xml:id = "altmeiid"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "altmeiid" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The altmeiid element may contain a bibliographic identifier that does not\x{a}" ~
        "          fit within the meihead id attribute, for example because the id does not fit the\x{a}" ~
        "          definition of an XML id or because multiple identifiers are needed. Used by:\x{a}" ~
        "          meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  altmeiid = element altmeiid { attlist.altmeiid, content.altmeiid }
  [
    xml:id = "content.altmeiid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.altmeiid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.altmeiid = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.altmeiid"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.altmeiid" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.altmeiid &= att.bibl, att.common, att.typed
  }
}
[
  xml:id = "filedesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "filedesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Filedesc contains a full bibliographic description of the MEI file.\x{a}" ~
        "          Extent in this context is file size. Used by: meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  filedesc = element filedesc { attlist.filedesc, content.filedesc }
  [
    xml:id = "content.filedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.filedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.filedesc =
      titlestmt,
      editionstmt?,
      extent?,
      fingerprint?,
      pubstmt,
      seriesstmt?,
      notesstmt?,
      sourcedesc?
  }
  [
    xml:id = "attlist.filedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.filedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.filedesc &= att.bibl, att.common
  }
}
[
  xml:id = "encodingdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "encodingdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Documents the relationship between an electronic file and the source or\x{a}" ~
        "          sources from which it was derived as well as applications used in the\x{a}" ~
        "          encoding/editing process. Used by: meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  encodingdesc =
    element encodingdesc { attlist.encodingdesc, content.encodingdesc }
  [
    xml:id = "content.encodingdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.encodingdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.encodingdesc = model.encodingPart
  }
  [
    xml:id = "attlist.encodingdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.encodingdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.encodingdesc &= att.bibl, att.common
  }
}
[
  xml:id = "appinfo"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "appinfo" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Appinfo (application information) groups information about applications\x{a}" ~
        "          which have acted upon the MEI file. This is not to be confused with applications\x{a}" ~
        "          which were used to create the MEI file. These are recorded in the projectdesc\x{a}" ~
        "          element. Used by: model.encodingPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  appinfo = element appinfo { attlist.appinfo, content.appinfo }
  [
    xml:id = "content.appinfo"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.appinfo" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.appinfo = application*
  }
  [
    xml:id = "attlist.appinfo"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.appinfo" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.appinfo &= att.common
  }
}
[
  xml:id = "application"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "application" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Application provides information about an application which has acted\x{a}" ~
        "          upon the document. Used by: appinfo Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  application =
    element application { attlist.application, content.application }
  [
    xml:id = "content.application"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.application" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.application = name+, (ptr* | model.pLike*)
  }
  [
    xml:id = "attlist.application"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.application" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.application &=
      att.common,
      att.date,
      att.typed,
      attribute version { text }?
  }
}
[
  xml:id = "profiledesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "profiledesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Profiledesc provides a detailed description of the non- bibliographic\x{a}" ~
        "          aspects of the creation of a work, specifically the languages and sublanguages\x{a}" ~
        "          used, the situation in which it was produced, e.g. the participants, setting,\x{a}" ~
        "          reception history, etc. Used by: meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  profiledesc =
    element profiledesc { attlist.profiledesc, content.profiledesc }
  [
    xml:id = "content.profiledesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.profiledesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.profiledesc = model.profiledescPart
  }
  [
    xml:id = "attlist.profiledesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.profiledesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.profiledesc &= att.bibl, att.common
  }
}
[
  xml:id = "titlestmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "titlestmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for title and responsibility meta-data. The title element is\x{a}" ~
        "          declared in the meiShared DTD. Used by: filedesc source Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  titlestmt = element titlestmt { attlist.titlestmt, content.titlestmt }
  [
    xml:id = "content.titlestmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.titlestmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.titlestmt = title+, respstmt?
  }
  [
    xml:id = "attlist.titlestmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.titlestmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.titlestmt &= att.bibl, att.common
  }
}
[
  xml:id = "respstmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "respstmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A statement of responsibility names one or more individuals, groups, or\x{a}" ~
        "          in rare cases, mechanical processes, responsible for creation or realization of\x{a}" ~
        "          the intellectual or artistic content. The name element is declared in the\x{a}" ~
        "          meiShared DTD. Used by: model.pubstmtPart model.respLike titlestmt editionstmt\x{a}" ~
        "          seriesstmt Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  respstmt = element respstmt { attlist.respstmt, content.respstmt }
  [
    xml:id = "content.respstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.respstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.respstmt = model.nameLike.agent+
  }
  [
    xml:id = "attlist.respstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.respstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.respstmt &= att.bibl, att.common
  }
}
[
  xml:id = "editionstmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "editionstmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for meta-data pertaining to the edition. Used by: filedesc\x{a}" ~
        "          source Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  editionstmt =
    element editionstmt { attlist.editionstmt, content.editionstmt }
  [
    xml:id = "content.editionstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.editionstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.editionstmt = (edition, respstmt*)+
  }
  [
    xml:id = "attlist.editionstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.editionstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.editionstmt &= att.common, att.bibl
  }
}
[
  xml:id = "edition"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "edition" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The edition designation is a word or text phrase that normally indicates\x{a}" ~
        "          a difference in either content or form between the item being described and a\x{a}" ~
        "          related item previously issued by the same publisher/distributor (e.g. 2nd\x{a}" ~
        "          edition, version 2.0, etc.), or simultaneously issued by either the same\x{a}" ~
        "          publisher/distributor or another publisher/distributor (e.g. large print\x{a}" ~
        "          edition, British edition, etc.). The %model.textphraseLike.limited entity is\x{a}" ~
        "          used here in order to disallow the pb element. Used by: model.biblPart\x{a}" ~
        "          editionstmt Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  edition = element edition { attlist.edition, content.edition }
  [
    xml:id = "content.edition"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.edition" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.edition = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.edition"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.edition" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.edition &= att.common, att.bibl
  }
}
[
  xml:id = "pubstmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pubstmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Publication meta-data. The geogname, address, date, and identifier\x{a}" ~
        "          elements are declared in the meiShared DTD. Used by: filedesc source\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pubstmt = element pubstmt { attlist.pubstmt, content.pubstmt }
  [
    xml:id = "content.pubstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pubstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pubstmt = unpub? | model.pubstmtPart*
  }
  [
    xml:id = "attlist.pubstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pubstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pubstmt &= att.common, att.bibl
  }
}
[
  xml:id = "unpub"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "unpub" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The unpub element should be used to explicitly indicate that a\x{a}" ~
        "          bibliographic source is unpublished. Used by: pubstmt Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  unpub = element unpub { attlist.unpub, content.unpub }
  [
    xml:id = "content.unpub"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.unpub" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.unpub = empty
  }
  [
    xml:id = "attlist.unpub"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.unpub" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.unpub &= att.common, att.bibl
  }
}
[
  xml:id = "availability"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "availability" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Availability information/qualifications. Used by: model.pubstmtPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  availability =
    element availability { attlist.availability, content.availability }
  [
    xml:id = "content.availability"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.availability" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.availability = model.availabilityPart
  }
  [
    xml:id = "attlist.availability"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.availability" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.availability &= att.common, att.bibl
  }
}
[
  xml:id = "acqsource"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "acqsource" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Source from which access to this item may be obtained, e.g. vendor,\x{a}" ~
        "          distributor, etc. The %model.textphraseLike.limited entity is used here in order\x{a}" ~
        "          to disallow the pb element. Used by: model.availabilityPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  acqsource = element acqsource { attlist.acqsource, content.acqsource }
  [
    xml:id = "content.acqsource"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.acqsource" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.acqsource = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.acqsource"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.acqsource" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.acqsource &= att.common, att.bibl
  }
}
[
  xml:id = "accessdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "accessdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Description of the access that may be obtained. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. Used by: model.availabilityPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  accessdesc =
    element accessdesc { attlist.accessdesc, content.accessdesc }
  [
    xml:id = "content.accessdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.accessdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.accessdesc = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.accessdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.accessdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.accessdesc &= att.common, att.bibl
  }
}
[
  xml:id = "userestrict"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "userestrict" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Usage restrictions, e.g., copyright statement in the filedesc, or\x{a}" ~
        "          (re-)publication rights in the source element. The %model.textphraseLike.limited\x{a}" ~
        "          entity is used here in order to disallow the pb element. Used by:\x{a}" ~
        "          model.availabilityPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  userestrict =
    element userestrict { attlist.userestrict, content.userestrict }
  [
    xml:id = "content.userestrict"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.userestrict" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.userestrict = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.userestrict"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.userestrict" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.userestrict &= att.common, att.bibl
  }
}
[
  xml:id = "price"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "price" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The cost of access. The %model.textphraseLike.limited entity is used here\x{a}" ~
        "          in order to disallow the pb element. Used by: model.availabilityPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  price = element price { attlist.price, content.price }
  [
    xml:id = "content.price"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.price" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.price = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.price"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.price" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.price &=
      att.common,
      att.bibl,
      attribute units { text }?
  }
}
[
  xml:id = "sysreq"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "sysreq" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "System requirements for using the electronic item. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. Used by: model.availabilityPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  sysreq = element sysreq { attlist.sysreq, content.sysreq }
  [
    xml:id = "content.sysreq"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.sysreq" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.sysreq = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.sysreq"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.sysreq" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.sysreq &= att.common, att.bibl
  }
}
[
  xml:id = "seriesstmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "seriesstmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Groups information about the series, if any, to which a publication\x{a}" ~
        "          belongs. In this context, the title element records the series title, the\x{a}" ~
        "          respStmt element records the person or group responsible for the series, and the\x{a}" ~
        "          identifier element contains a series identifier. The list element should be used\x{a}" ~
        "          when it is necessary to enumerate the contents of the series. The seriesstmt is\x{a}" ~
        "          provided within seriesstmt for the description of a sub-series. The title, list,\x{a}" ~
        "          and identifier elements are declared in the meiShared DTD. Used by: filedesc\x{a}" ~
        "          source seriesstmt Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  seriesstmt =
    element seriesstmt { attlist.seriesstmt, content.seriesstmt }
  [
    xml:id = "content.seriesstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.seriesstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.seriesstmt =
      title+, respstmt?, identifier*, (model.listLike | seriesstmt*)
  }
  [
    xml:id = "attlist.seriesstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.seriesstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.seriesstmt &= att.common, att.bibl
  }
}
[
  xml:id = "extent"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "extent" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The extent element is used to express size in terms other than physical\x{a}" ~
        "          dimensions, such as number of pages, number of records in file, number of bytes,\x{a}" ~
        "          performance duration for music, audio recordings and visual projections, etc.\x{a}" ~
        "          For physical dimensions use the dimensions element. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. Used by: model.physdescPart filedesc Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  extent = element extent { attlist.extent, content.extent }
  [
    xml:id = "content.extent"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.extent" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.extent = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.extent"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.extent" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.extent &=
      att.common,
      att.bibl,
      attribute units { text }?
  }
}
[
  xml:id = "fingerprint"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "fingerprint" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Traditionally, an identifier constructed by combining groups of\x{a}" ~
        "          characters transcribed from specified pages of a printed item. For an electronic\x{a}" ~
        "          item, however, the fingerprint should be a checksum. The checksum makes it\x{a}" ~
        "          possible to signal differences between copies of the item. Used by: filedesc\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  fingerprint =
    element fingerprint { attlist.fingerprint, content.fingerprint }
  [
    xml:id = "content.fingerprint"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.fingerprint" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.fingerprint = text
  }
  [
    xml:id = "attlist.fingerprint"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.fingerprint" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.fingerprint &= att.common, att.lang
  }
}
[
  xml:id = "notesstmt"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "notesstmt" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Collects together any bibliographic notes providing information\x{a}" ~
        "          additional to that recorded in other parts of the bibliographic description.\x{a}" ~
        "          Used by: filedesc Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  notesstmt = element notesstmt { attlist.notesstmt, content.notesstmt }
  [
    xml:id = "content.notesstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.notesstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.notesstmt = model.annotLike+
  }
  [
    xml:id = "attlist.notesstmt"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.notesstmt" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.notesstmt &= att.common, att.bibl
  }
}
[
  xml:id = "projectdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "projectdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Project-level meta-data describing the aim or purpose for which the\x{a}" ~
        "          electronic file was encoded, funding agencies, etc. together with any other\x{a}" ~
        "          relevant information concerning the process by which it was assembled or\x{a}" ~
        "          collected. The model.textcomponent class elements are declared in the meiShared\x{a}" ~
        "          DTD. Used by: model.encodingPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  projectdesc =
    element projectdesc { attlist.projectdesc, content.projectdesc }
  [
    xml:id = "content.projectdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.projectdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.projectdesc = model.pLike+
  }
  [
    xml:id = "attlist.projectdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.projectdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.projectdesc &= att.common, att.bibl
  }
}
[
  xml:id = "editorialdecl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "editorialdecl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Editorialdecl should be used to provide details of editorial principles\x{a}" ~
        "          and practices applied during the encoding of musical text. The\x{a}" ~
        "          model.textcomponent class elements are declared in the meiShared DTD. Used by:\x{a}" ~
        "          model.encodingPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  editorialdecl =
    element editorialdecl {
      attlist.editorialdecl, content.editorialdecl
    }
  [
    xml:id = "content.editorialdecl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.editorialdecl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.editorialdecl =
      model.pLike+ | (model.editorialdeclPart+, model.pLike*)
  }
  [
    xml:id = "attlist.editorialdecl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.editorialdecl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.editorialdecl &= att.common, att.bibl
  }
}
[
  xml:id = "correction"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "correction" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "States how and under what circumstances corrections have been made in the\x{a}" ~
        "          music/text. Used by: model.editorialdeclPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  correction =
    element correction { attlist.correction, content.correction }
  [
    xml:id = "content.correction"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.correction" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.correction = model.pLike+
  }
  [
    xml:id = "attlist.correction"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.correction" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.correction &=
      att.common,
      att.bibl,
      attribute method { "silent" | "tags" }?,
      attribute status { "high" | "medium" | "low" | "unknown" }?
  }
}
[
  xml:id = "interpretation"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "interpretation" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Describes the scope of any analytic or interpretive information added to\x{a}" ~
        "          the musical text in addition to the transcription. Used by:\x{a}" ~
        "          model.editorialdeclPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  interpretation =
    element interpretation {
      attlist.interpretation, content.interpretation
    }
  [
    xml:id = "content.interpretation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.interpretation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.interpretation = model.pLike+
  }
  [
    xml:id = "attlist.interpretation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.interpretation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.interpretation &= att.common, att.bibl
  }
}
[
  xml:id = "normalization"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "normalization" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Indicates the extent of normalization or regularization of the original\x{a}" ~
        "          source carried out in converting it to electronic form. Used by:\x{a}" ~
        "          model.editorialdeclPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  normalization =
    element normalization {
      attlist.normalization, content.normalization
    }
  [
    xml:id = "content.normalization"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.normalization" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.normalization = model.pLike+
  }
  [
    xml:id = "attlist.normalization"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.normalization" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.normalization &=
      att.common,
      att.bibl,
      attribute method { "silent" | "tags" }?
  }
}
[
  xml:id = "segmentation"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "segmentation" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Describes the principles according to which the musical text has been\x{a}" ~
        "          segmented, for example into movements, sections, etc. Used by:\x{a}" ~
        "          model.editorialdeclPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  segmentation =
    element segmentation { attlist.segmentation, content.segmentation }
  [
    xml:id = "content.segmentation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.segmentation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.segmentation = model.pLike+
  }
  [
    xml:id = "attlist.segmentation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.segmentation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.segmentation &= att.common, att.bibl
  }
}
[
  xml:id = "stdvals"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "stdvals" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Specifies the format used when standardized date or number values are\x{a}" ~
        "          supplied. Used by: model.editorialdeclPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  stdvals = element stdvals { attlist.stdvals, content.stdvals }
  [
    xml:id = "content.stdvals"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.stdvals" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.stdvals = model.pLike+
  }
  [
    xml:id = "attlist.stdvals"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.stdvals" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.stdvals &= att.common, att.bibl
  }
}
[
  xml:id = "creation"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "creation" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Non-bibliographic creation details for the work being encoded, in\x{a}" ~
        "          narrative form. The model.textcomponent class elements are declared in the\x{a}" ~
        "          meiShared DTD. Used by: model.profiledescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  creation = element creation { attlist.creation, content.creation }
  [
    xml:id = "content.creation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.creation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.creation = model.textcomponentLike+
  }
  [
    xml:id = "attlist.creation"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.creation" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.creation &= att.common, att.bibl
  }
}
[
  xml:id = "langusage"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "langusage" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Langusage describes the languages, sublanguages, dialects, etc.,\x{a}" ~
        "          represented within the encoded work. Used by: model.profiledescPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  langusage = element langusage { attlist.langusage, content.langusage }
  [
    xml:id = "content.langusage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.langusage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.langusage = language+
  }
  [
    xml:id = "attlist.langusage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.langusage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.langusage &= att.common, att.bibl
  }
}
[
  xml:id = "language"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "language" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The name of a language. The language of text elements may be related to\x{a}" ~
        "          this element via its id, which may take the form of a code, drawn from a coded\x{a}" ~
        "          list, such as iso639-2b. The %model.textphraseLike.limited entity is used here\x{a}" ~
        "          in order to disallow the pb element. Used by: langusage Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  language = element language { attlist.language, content.language }
  [
    xml:id = "content.language"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.language" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.language = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.language"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.language" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.language &= att.common, att.bibl
  }
}
[
  xml:id = "classification"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "classification" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The classification element groups information which describes the nature\x{a}" ~
        "          or topic of a musical work in terms of a standard classification scheme,\x{a}" ~
        "          thesaurus, etc. Used by: model.profiledescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  classification =
    element classification {
      attlist.classification, content.classification
    }
  [
    xml:id = "content.classification"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.classification" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.classification = (classcode | keywords)+
  }
  [
    xml:id = "attlist.classification"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.classification" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.classification &= att.common, att.bibl
  }
}
[
  xml:id = "classcode"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "classcode" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A classification code, i.e., LC subject or call number, or a thesaurus or\x{a}" ~
        "          ontology citation. The source of controlled-vocabulary terms used in the\x{a}" ~
        "          keywords element. Used by: classification Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  classcode = element classcode { attlist.classcode, content.classcode }
  [
    xml:id = "content.classcode"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.classcode" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.classcode = text
  }
  [
    xml:id = "attlist.classcode"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.classcode" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.classcode &= att.common, att.bibl
  }
}
[
  xml:id = "keywords"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "keywords" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Collection of keywords or text phrases which describe the work. Used by:\x{a}" ~
        "          classification Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  keywords = element keywords { attlist.keywords, content.keywords }
  [
    xml:id = "content.keywords"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.keywords" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.keywords = term+
  }
  [
    xml:id = "attlist.keywords"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.keywords" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.keywords &= att.common, att.bibl
  }
}
[
  xml:id = "term"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "term" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Individual keywords or phrases which describe the work. The classcode\x{a}" ~
        "          attribute may be used to link the term to a terminological source given in a\x{a}" ~
        "          classcode element. The %model.textphraseLike.limited entity is used here in\x{a}" ~
        "          order to disallow the pb element. The term element may include other term\x{a}" ~
        "          elements in order to allow the creation of coordinated terms; i.e., terms\x{a}" ~
        "          created from a combination of other, independent terms. Used by: keywords\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  term = element term { attlist.term, content.term }
  [
    xml:id = "content.term"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.term" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.term = (text | term | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.term"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.term" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.term &=
      attribute classcode { xsd:IDREF }?,
      att.common,
      att.bibl
  }
}
[
  xml:id = "samplingdecl"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "samplingdecl" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains a prose description of the rationale and methods used in\x{a}" ~
        "          sampling texts in the creation of a corpus or collection. Used by:\x{a}" ~
        "          model.encodingPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  samplingdecl =
    element samplingdecl { attlist.samplingdecl, content.samplingdecl }
  [
    xml:id = "content.samplingdecl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.samplingdecl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.samplingdecl = model.pLike+
  }
  [
    xml:id = "attlist.samplingdecl"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.samplingdecl" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.samplingdecl &= att.common, att.bibl
  }
}
[
  xml:id = "revisiondesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "revisiondesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The revision history for an MEI file. Used by: meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  revisiondesc =
    element revisiondesc { attlist.revisiondesc, content.revisiondesc }
  [
    xml:id = "content.revisiondesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.revisiondesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.revisiondesc = change+
  }
  [
    xml:id = "attlist.revisiondesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.revisiondesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.revisiondesc &= att.common, att.bibl
  }
}
[
  xml:id = "change"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "change" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Individual change within the revision description. The resp attribute\x{a}" ~
        "          contains a pointer to an element containing info about the person/entity\x{a}" ~
        "          responsible for change. The date element is declared in the meiShared DTD. Used\x{a}" ~
        "          by: revisiondesc Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  change = element change { attlist.change, content.change }
  [
    xml:id = "content.change"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.change" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.change = changedesc, model.dateLike
  }
  [
    xml:id = "attlist.change"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.change" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.change &=
      att.common,
      att.bibl,
      attribute resp { xsd:IDREF }?
  }
}
[
  xml:id = "changedesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "changedesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Description of a revision. The p element is declared in the meiShared\x{a}" ~
        "          DTD. Used by: change Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  changedesc =
    element changedesc { attlist.changedesc, content.changedesc }
  [
    xml:id = "content.changedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.changedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.changedesc = model.pLike+
  }
  [
    xml:id = "attlist.changedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.changedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.changedesc &= att.common, att.bibl
  }
}
[
  xml:id = "sourcedesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "sourcedesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Sourcedesc is a container for the descriptions of the source(s) used in\x{a}" ~
        "          the creation of the electronic file. Used by: meihead Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  sourcedesc =
    element sourcedesc { attlist.sourcedesc, content.sourcedesc }
  [
    xml:id = "content.sourcedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.sourcedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.sourcedesc = source+
  }
  [
    xml:id = "attlist.sourcedesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.sourcedesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.sourcedesc &= att.common
  }
}
[
  xml:id = "source"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "source" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Source contains a bibliographic description of a source for the\x{a}" ~
        "          electronic file. When there are multiple sources, the data attribute may be used\x{a}" ~
        "          to link the description to a particular data element, i.e., mdiv, part, section,\x{a}" ~
        "          ending, reading, measure, staff or layer. Within source, the extent element may\x{a}" ~
        "          be used when only a portion of the source, pages 1-3 for example, are encoded.\x{a}" ~
        "          If extent is absent, then the entire source is presumed to have been encoded.\x{a}" ~
        "          Multiple physdesc sub-elements may be used to describe the physically separate\x{a}" ~
        "          parts of a single source. Used by: sourcedesc Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  source = element source { attlist.source, content.source }
  [
    xml:id = "content.source"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.source" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.source =
      identifier*,
      titlestmt?,
      editionstmt?,
      pubstmt,
      physdesc?,
      seriesstmt?,
      notesstmt?,
      langusage?,
      classification?
  }
  [
    xml:id = "attlist.source"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.source" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.source &=
      attribute data { xsd:IDREFS }?,
      att.common,
      att.bibl
  }
}
[
  xml:id = "physdesc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "physdesc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Physical description of a source for the electronic edition. Dedicatory\x{a}" ~
        "          text and title page features may be encoded here when they are not transcribed\x{a}" ~
        "          as part of the front or back matter; i.e., when they are considered to be\x{a}" ~
        "          meta-data. Used by: source Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  physdesc = element physdesc { attlist.physdesc, content.physdesc }
  [
    xml:id = "content.physdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.physdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.physdesc = model.physdescPart+
  }
  [
    xml:id = "attlist.physdesc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.physdesc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.physdesc &= att.common, att.bibl
  }
}
[
  xml:id = "physmedium"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "physmedium" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Physmedium is used to record the physical materials used in the source,\x{a}" ~
        "          such as ink and paper. The %model.textphraseLike.limited entity is used here in\x{a}" ~
        "          order to disallow the pb element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  physmedium =
    element physmedium { attlist.physmedium, content.physmedium }
  [
    xml:id = "content.physmedium"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.physmedium" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.physmedium = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.physmedium"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.physmedium" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.physmedium &= att.common, att.bibl
  }
}
[
  xml:id = "dimensions"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "dimensions" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Physical dimensions of a bibliographic source. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. There are no height and width sub-elements; however, the num element\x{a}" ~
        "          may be used. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  dimensions =
    element dimensions { attlist.dimensions, content.dimensions }
  [
    xml:id = "content.dimensions"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.dimensions" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.dimensions = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.dimensions"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.dimensions" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.dimensions &=
      att.common,
      att.bibl,
      attribute units { text }?
  }
}
[
  xml:id = "provenance"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "provenance" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The record of ownership or custodianship of an item. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  provenance =
    element provenance { attlist.provenance, content.provenance }
  [
    xml:id = "content.provenance"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.provenance" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.provenance =
      (text | model.listLike | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.provenance"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.provenance" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.provenance &= att.common, att.bibl
  }
}
[
  xml:id = "inscription"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "inscription" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An inscription added to an item, such as a bookplate, a note designating\x{a}" ~
        "          the item as a gift, and/or the author's signature. The\x{a}" ~
        "          %model.textphraseLike.limited entity is used here in order to disallow the pb\x{a}" ~
        "          element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  inscription =
    element inscription { attlist.inscription, content.inscription }
  [
    xml:id = "content.inscription"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.inscription" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.inscription =
      (text
       | model.textphraseLike.limited
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.inscription"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.inscription" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.inscription &= att.common, att.bibl
  }
}
[
  xml:id = "exhibithist"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "exhibithist" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Exhibition history is a record of public exhibitions, including dates,\x{a}" ~
        "          venues, etc. The %model.textphraseLike.limited entity is used here in order to\x{a}" ~
        "          disallow the pb element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  exhibithist =
    element exhibithist { attlist.exhibithist, content.exhibithist }
  [
    xml:id = "content.exhibithist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.exhibithist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.exhibithist = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.exhibithist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.exhibithist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.exhibithist &= att.common, att.bibl
  }
}
[
  xml:id = "condition"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "condition" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The physical condition of an item, particularly any variances between the\x{a}" ~
        "          physical makeup of the item and that of other copies of the same item (e.g.,\x{a}" ~
        "          missing pages, plates, etc.). Condition may reflect other aspects of the\x{a}" ~
        "          physical condition of the item as well (e.g., brittleness, faded images, etc.).\x{a}" ~
        "          The %model.textphraseLike.limited entity is used here in order to disallow the\x{a}" ~
        "          pb element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  condition = element condition { attlist.condition, content.condition }
  [
    xml:id = "content.condition"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.condition" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.condition = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.condition"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.condition" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.condition &= att.common, att.bibl
  }
}
[
  xml:id = "treatmenthist"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "treatmenthist" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A record of the treatment the item has undergone (e.g., deacidification,\x{a}" ~
        "          restoration, etc.) Treatment history may also comprise details of the treatment\x{a}" ~
        "          process (e.g., chemical solutions used, techniques applied, etc.), the date the\x{a}" ~
        "          treatment was applied, etc. The %model.textphraseLike.limited entity is used\x{a}" ~
        "          here in order to disallow the pb element. Used by: model.physdescPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  treatmenthist =
    element treatmenthist {
      attlist.treatmenthist, content.treatmenthist
    }
  [
    xml:id = "content.treatmenthist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.treatmenthist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.treatmenthist = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.treatmenthist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.treatmenthist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.treatmenthist &= att.common, att.bibl
  }
}
[
  xml:id = "treatmentsched"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "treatmentsched" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Scheduled treatment, e.g. deacidification, restoration, etc., for an\x{a}" ~
        "          item. The %model.textphraseLike.limited entity is used here in order to disallow\x{a}" ~
        "          the pb element. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  treatmentsched =
    element treatmentsched {
      attlist.treatmentsched, content.treatmentsched
    }
  [
    xml:id = "content.treatmentsched"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.treatmentsched" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.treatmentsched = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.treatmentsched"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.treatmentsched" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.treatmentsched &= att.common, att.bibl
  }
}
[
  xml:id = "physloc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "physloc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Location of the source within a repository, e.g., shelf mark or other\x{a}" ~
        "          locational information. Used by: model.physdescPart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  physloc = element physloc { attlist.physloc, content.physloc }
  [
    xml:id = "content.physloc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.physloc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.physloc = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.physloc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.physloc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.physloc &= att.common, att.bibl
  }
}
[
  xml:id = "handlist"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "handlist" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The handlist element contains a series of <hand> elements\x{a}" ~
        "          listing the different hands of the source. Used by: model.physdescPart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  handlist = element handlist { attlist.handlist, content.handlist }
  [
    xml:id = "content.handlist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.handlist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.handlist = hand+
  }
  [
    xml:id = "attlist.handlist"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.handlist" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.handlist &= att.common, att.bibl
  }
}
[
  xml:id = "hand"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "hand" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The hand element is used to define each distinct scribe or handwriting\x{a}" ~
        "          style. The initial attribute indicates whether this is the first or main scribe\x{a}" ~
        "          of the document. The medium attribute describes the writing medium, e.g.,\x{a}" ~
        "          'pencil', or the tint or type of ink, e.g. 'brown'. The resp attribute contains\x{a}" ~
        "          an ID reference to an element containing the name of the editor or transcriber\x{a}" ~
        "          responsible for identifying the hand. The characteristics of the hand,\x{a}" ~
        "          particularly those related to the quality of the writing, such as 'shaky',\x{a}" ~
        "          'thick', etc. may be described within the content of the hand element. Used by:\x{a}" ~
        "          handlist Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  hand = element hand { attlist.hand, content.hand }
  [
    xml:id = "content.hand"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.hand" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.hand = (text | model.textphraseLike.limited)*
  }
  [
    xml:id = "attlist.hand"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.hand" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.hand &=
      att.common,
      att.bibl,
      attribute initial { data.BOOLEAN }?,
      attribute medium { text }?,
      attribute resp { xsd:IDREF }?
  }
}
[
  xml:id = "front"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "front" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Front matter. The pb element is allowed here in order to accommodate page\x{a}" ~
        "          images, e.g. cover, endpapers, etc. before and after the actual textual matter.\x{a}" ~
        "          The pb element and titlepage elements are declared in the meiShared DTD. Used\x{a}" ~
        "          by: music Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  front = element front { attlist.front, content.front }
  [
    xml:id = "content.front"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.front" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.front =
      model.milestoneLike.text*,
      (model.divLike | model.frontPart)+,
      model.milestoneLike.text*
  }
  [
    xml:id = "attlist.front"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.front" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.front &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "back"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "back" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Back matter such as indexes, advertisements, etc. Used by: music\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  back = element back { attlist.back, content.back }
  [
    xml:id = "content.back"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.back" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.back =
      model.milestoneLike.text*,
      model.divLike+,
      model.milestoneLike.text*
  }
  [
    xml:id = "attlist.back"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.back" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.back &= att.common, att.facsimile, att.lang
  }
}
[
  xml:id = "div"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "div" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Textual division. Used by: model.divLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  \div = element div { attlist.div, content.div }
  [
    xml:id = "content.div"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.div" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.div =
      model.milestoneLike.text*,
      model.headLike?,
      (model.divLike | model.textcomponentLike)+,
      model.milestoneLike.text*
  }
  [
    xml:id = "attlist.div"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.div" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.div &= att.common, att.facsimile, att.lang, att.typed
  }
}
[
  xml:id = "midi"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "midi" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Container for a collection of elements which contain information useful\x{a}" ~
        "          when generating MIDI output. The n attribute can be used to differentiate\x{a}" ~
        "          between multiple MIDI data streams, e.g. quantized/unquantized, straight/swing,\x{a}" ~
        "          ornamented/as notated, etc. Used by: model.midiLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  midi = element midi { attlist.midi, content.midi }
  [
    xml:id = "content.midi"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.midi" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.midi =
      (cc
       | chan
       | chanpr
       | cue
       | hex
       | marker
       | metatext
       | noteoff
       | noteon
       | port
       | prog
       | seqnum
       | trkname
       | vel)*
  }
  [
    xml:id = "attlist.midi"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.midi" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.midi &=
      att.common, att.log.midi, att.vis.midi, att.ges.midi, att.anl.midi
  }
}
[
  xml:id = "cc"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "cc" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Parameter/control change. The n attribute specifies parameter number,\x{a}" ~
        "          while val contains the parameter value. Each must fall in the range 0-127. A\x{a}" ~
        "          sampling of controllers and their numbers: 0 Bank Select MSB 1 Modulation 2\x{a}" ~
        "          Breath Control 5 Portamento Time 7 Main Volume 10 Pan 11 Expression 32 Bank\x{a}" ~
        "          Select LSB 64 Sustain Pedal (0=up, 127=down) 65 Portamento Pedal (0=off, 127=on)\x{a}" ~
        "          91 Reverb 93 Chorus Depth 120 All Sounds Off (0) 121 Reset All Controllers (0)\x{a}" ~
        "          123 All Notes Off (0) Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  cc = element cc { attlist.cc, content.cc }
  [
    xml:id = "content.cc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.cc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.cc = empty
  }
  [
    xml:id = "attlist.cc"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.cc" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.cc &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE },
      attribute val { data.MIDIVALUE }
  }
}
[
  xml:id = "chan"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chan" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Channel assignment Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chan = element chan { attlist.chan, content.chan }
  [
    xml:id = "content.chan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chan = empty
  }
  [
    xml:id = "attlist.chan"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chan" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chan &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDICHANNEL }
  }
}
[
  xml:id = "chanpr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "chanpr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Channel pressure/after touch. The n attribute must be in the range 0-127.\x{a}" ~
        "          Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  chanpr = element chanpr { attlist.chanpr, content.chanpr }
  [
    xml:id = "content.chanpr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.chanpr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.chanpr = empty
  }
  [
    xml:id = "attlist.chanpr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.chanpr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.chanpr &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE }
  }
}
[
  xml:id = "cue"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "cue" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Cue point Used by: model.midieventLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  cue = element cue { attlist.cue, content.cue }
  [
    xml:id = "content.cue"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.cue" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.cue = text
  }
  [
    xml:id = "attlist.cue"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.cue" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.cue &= att.common.anl, att.common, att.midi.event
  }
}
[
  xml:id = "hex"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "hex" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Arbitrary MIDI data in hex Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  hex = element hex { attlist.hex, content.hex }
  [
    xml:id = "content.hex"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.hex" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.hex = text
  }
  [
    xml:id = "attlist.hex"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.hex" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.hex &= att.common.anl, att.common, att.midi.event
  }
}
[
  xml:id = "marker"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "marker" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Marker meta event Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  marker = element marker { attlist.marker, content.marker }
  [
    xml:id = "content.marker"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.marker" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.marker = text
  }
  [
    xml:id = "attlist.marker"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.marker" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.marker &= att.common.anl, att.common, att.midi.event
  }
}
[
  xml:id = "metatext"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "metatext" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Text meta event Used by: model.midieventLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  metatext = element metatext { attlist.metatext, content.metatext }
  [
    xml:id = "content.metatext"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.metatext" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.metatext = text
  }
  [
    xml:id = "attlist.metatext"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.metatext" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.metatext &= att.common.anl, att.common, att.midi.event
  }
}
[
  xml:id = "noteoff"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "noteoff" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Note-off Used by: model.midieventLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  noteoff = element noteoff { attlist.noteoff, content.noteoff }
  [
    xml:id = "content.noteoff"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.noteoff" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.noteoff = empty
  }
  [
    xml:id = "attlist.noteoff"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.noteoff" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.noteoff &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE }
  }
}
[
  xml:id = "noteon"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "noteon" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Note-on Used by: model.midieventLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  noteon = element noteon { attlist.noteon, content.noteon }
  [
    xml:id = "content.noteon"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.noteon" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.noteon = empty
  }
  [
    xml:id = "attlist.noteon"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.noteon" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.noteon &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE }
  }
}
[
  xml:id = "port"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "port" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "MIDI port. The n attribute must be in the range 0-127. Used by:\x{a}" ~
        "          model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  port = element port { attlist.port, content.port }
  [
    xml:id = "content.port"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.port" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.port = empty
  }
  [
    xml:id = "attlist.port"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.port" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.port &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE }
  }
}
[
  xml:id = "prog"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "prog" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Program change/new instrument. The n attribute must be in the range\x{a}" ~
        "          0-127. Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  prog = element prog { attlist.prog, content.prog }
  [
    xml:id = "content.prog"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.prog" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.prog = empty
  }
  [
    xml:id = "attlist.prog"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.prog" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.prog &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.MIDIVALUE }
  }
}
[
  xml:id = "seqnum"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "seqnum" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Sequence number. The n attribute must be in the range 0-65535 Used by:\x{a}" ~
        "          model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  seqnum = element seqnum { attlist.seqnum, content.seqnum }
  [
    xml:id = "content.seqnum"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.seqnum" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.seqnum = empty
  }
  [
    xml:id = "attlist.seqnum"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.seqnum" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.seqnum &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute num { data.INTEGERNONNEGATIVE }
  }
}
[
  xml:id = "trkname"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "trkname" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Track/sequence name Used by: model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  trkname = element trkname { attlist.trkname, content.trkname }
  [
    xml:id = "content.trkname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.trkname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.trkname = text
  }
  [
    xml:id = "attlist.trkname"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.trkname" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.trkname &= att.common.anl, att.common, att.midi.event
  }
}
[
  xml:id = "vel"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "vel" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Note-on/off velocity. For on velocity, the attribute must be in the range\x{a}" ~
        "          1-127. For off velocity, the n attribute must be in the range 0-127. Used by:\x{a}" ~
        "          model.midieventLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  vel = element vel { attlist.vel, content.vel }
  [
    xml:id = "content.vel"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.vel" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.vel = empty
  }
  [
    xml:id = "attlist.vel"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.vel" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.vel &=
      att.common.anl,
      att.common,
      att.midi.event,
      attribute form { "on" | "off" },
      attribute num { text }
  }
}
[
  xml:id = "add"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "add" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Marks an addition to the musical text. The add element contains material\x{a}" ~
        "          inserted by an author, scribe, annotator, or corrector. The resp attribute\x{a}" ~
        "          contains a ID reference to an element containing the editor or transcriber\x{a}" ~
        "          responsible for identifying the hand of the addition. The cert attribute\x{a}" ~
        "          signifies the degree of certainty ascribed to the identification of the hand of\x{a}" ~
        "          the addition. The hand attribute signifies the hand of the agent which made the\x{a}" ~
        "          addition. Used by: model.transcriptionLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  add = element add { attlist.add, content.add }
  [
    xml:id = "content.add"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.add" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.add =
      (text
       | model.textphraseLike
       | model.eventLike
       | model.controleventLike
       | model.midiLike
       | model.annotLike
       | model.editLike
       | model.transcriptionLike
       | model.eventLike.cmn.measureFilling
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.add"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.add" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.add &= att.common, att.facsimile, att.edit, att.trans
  }
}
[
  xml:id = "choice"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "choice" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Choice Used by: model.editLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  choice = element choice { attlist.choice, content.choice }
  [
    xml:id = "content.choice"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.choice" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.choice = (choice | model.choicePart)*
  }
  [
    xml:id = "attlist.choice"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.choice" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.choice &= att.common
  }
}
[
  xml:id = "corr"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "corr" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Correction contains the correct form of an apparent erroneous passage.\x{a}" ~
        "          The resp attribute contains an ID reference to an element containing the name of\x{a}" ~
        "          the editor or transcriber responsible for suggesting the correction held as the\x{a}" ~
        "          content of the <corr> element. If the correction was made in the\x{a}" ~
        "          source, resp should be used to identify the hand of the corrector. Used by:\x{a}" ~
        "          model.transcriptionLike model.choicePart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  corr = element corr { attlist.corr, content.corr }
  [
    xml:id = "content.corr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.corr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.corr =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.corr"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.corr" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.corr &= att.common, att.edit, att.trans
  }
}
[
  xml:id = "damage"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "damage" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains an area of damage to the carrier. In the case of damage\x{a}" ~
        "          resulting from an identifiable cause, the agent attribute signifies the\x{a}" ~
        "          causative agent. The degree attribute signifies the degree of damage according\x{a}" ~
        "          to a convenient scale. The <damage> tag with this attribute should\x{a}" ~
        "          only be used where the text may be read with some confidence; data supplied from\x{a}" ~
        "          other sources should be tagged as <supplied>. The extent attribute\x{a}" ~
        "          indicates approximately how much text is in the damaged area, in notes,\x{a}" ~
        "          measures, inches, or any appropriate unit, where this cannot be deduced from the\x{a}" ~
        "          contents of the tag. For example, the damage may span structural divisions in\x{a}" ~
        "          the text so that the tag must then be empty of content. In the case of damage\x{a}" ~
        "          (deliberate defacement, etc.) assignable to an identifiable hand, the hand\x{a}" ~
        "          attribute signifies the hand responsible for the damage. Used by:\x{a}" ~
        "          model.transcriptionLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  damage = element damage { attlist.damage, content.damage }
  [
    xml:id = "content.damage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.damage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.damage =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.damage"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.damage" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.damage &=
      att.common,
      att.facsimile,
      att.typed,
      attribute agent { text }?,
      attribute degree { text }?,
      attribute extent { text }?,
      attribute hand { xsd:IDREF }?
  }
}
[
  xml:id = "del"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "del" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Del contains information deleted, marked as deleted, or otherwise\x{a}" ~
        "          indicated as superfluous or spurious in the copy text by an author, scribe,\x{a}" ~
        "          annotator, or corrector. The resp attribute contains an ID reference to an\x{a}" ~
        "          element containing the name of the editor or transcriber responsible for\x{a}" ~
        "          identifying the hand of the deletion. The cert attribute signifies the degree of\x{a}" ~
        "          certainty ascribed to the identification of the hand of the deletion. The hand\x{a}" ~
        "          of the agent which made the deletion should be pointed to using the hand\x{a}" ~
        "          attribute. The rend attribute may be used to record the method used to make the\x{a}" ~
        "          deletion (overstrike, strike[through], etc.) or how the deleted matter should be\x{a}" ~
        "          displayed. Used by: model.transcriptionLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  del = element del { attlist.del, content.del }
  [
    xml:id = "content.del"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.del" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.del =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.del"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.del" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.del &=
      att.common,
      att.facsimile,
      att.trans,
      attribute rend { text }?
  }
}
[
  xml:id = "orig"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "orig" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  orig = element orig { attlist.orig, content.orig }
  [
    xml:id = "content.orig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.orig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.orig =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.orig"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.orig" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.orig &= att.common, att.edit, att.facsimile, att.typed
  }
}
[
  xml:id = "reg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "reg" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  reg = element reg { attlist.reg, content.reg }
  [
    xml:id = "content.reg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.reg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.reg =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.reg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.reg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.reg &= att.common, att.edit
  }
}
[
  xml:id = "restore"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "restore" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Restore indicates restoration of musical material to an earlier state by\x{a}" ~
        "          cancellation of an editorial or authorial marking or instruction. The desc\x{a}" ~
        "          (description) attribute gives a prose description of the means of restoration,\x{a}" ~
        "          'stet' or 'strike-down', for example. The cert attribute signifies the degree of\x{a}" ~
        "          certainty ascribed to the identification of the hand of the restoration. The\x{a}" ~
        "          type attribute may be used to indicate the action cancelled by the restoration.\x{a}" ~
        "          The resp attribute contains an ID reference to an element containing the name of\x{a}" ~
        "          the editor or transcriber responsible for identifying the hand of the\x{a}" ~
        "          restoration. The hand attribute signifies the hand of the agent which made the\x{a}" ~
        "          restoration. Used by: model.transcriptionLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  restore = element restore { attlist.restore, content.restore }
  [
    xml:id = "content.restore"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.restore" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.restore =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.restore"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.restore" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.restore &=
      att.common,
      att.facsimile,
      att.trans,
      att.typed,
      attribute desc { text }?
  }
}
[
  xml:id = "sic"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "sic" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Contains apparently incorrect or inaccurate musical material. A\x{a}" ~
        "          correction for the apparent error may be given in an accompanying child or\x{a}" ~
        "          sibling corr element. Used by: model.transcriptionLike model.choicePart\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  sic = element sic { attlist.sic, content.sic }
  [
    xml:id = "content.sic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.sic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.sic =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.sic"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.sic" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.sic &= att.common, att.facsimile
  }
}
[
  xml:id = "subst"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "subst" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [ "Substitution Used by: model.editLike Module:" ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  subst = element subst { attlist.subst, content.subst }
  [
    xml:id = "content.subst"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.subst" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.subst = model.transcriptionLike, model.transcriptionLike+
  }
  [
    xml:id = "attlist.subst"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.subst" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.subst &=
      [ a:defaultValue = "subst" ] attribute meiform { string "subst" }?
  }
}
[
  xml:id = "supplied"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "supplied" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Supplied contains musical material supplied by the transcriber or editor\x{a}" ~
        "          in place of text which cannot be read, either because of physical damage or loss\x{a}" ~
        "          in the original or because it is illegible for any reason. When the presumed\x{a}" ~
        "          loss of text arises from an identifiable cause, agent signifies the causative\x{a}" ~
        "          agent. When the presumed loss of text arises from action (partial deletion,\x{a}" ~
        "          etc.) assignable to an identifiable hand, the hand attribute signifies the hand\x{a}" ~
        "          responsible for the action. The reason attribute indicates why the text has to\x{a}" ~
        "          be supplied, e.g. 'overbinding', 'faded ink', 'lost folio', 'omitted in\x{a}" ~
        "          original', etc. The source attribute contains the source of the supplied text.\x{a}" ~
        "          Used by: model.transcriptionLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  supplied = element supplied { attlist.supplied, content.supplied }
  [
    xml:id = "content.supplied"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.supplied" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.supplied =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.supplied"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.supplied" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.supplied &=
      att.common,
      att.edit,
      att.facsimile,
      attribute agent { text }?,
      attribute reason { text }?
  }
}
[
  xml:id = "unclear"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "unclear" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Unclear contains musical material which cannot be transcribed with\x{a}" ~
        "          certainty because it is illegible or inaudible in the source. Where the\x{a}" ~
        "          difficulty in transcription arises from an identifiable cause, the agent\x{a}" ~
        "          attribute signifies the causative agent. The cert attribute signifies the degree\x{a}" ~
        "          of certainty ascribed to the transcription of the text contained within the\x{a}" ~
        "          <unclear> element. Where the difficulty in transcription arises\x{a}" ~
        "          from action (partial deletion, etc.) assignable to an identifiable hand, the\x{a}" ~
        "          hand attribute signifies the hand responsible for the action. The reason\x{a}" ~
        "          attribute indicates why the material is difficult to transcribe. The resp\x{a}" ~
        "          attribute indicates the individual responsible for the transcription of the\x{a}" ~
        "          word, phrase, or passage contained with the <unclear> element.\x{a}" ~
        "          Used by: model.transcriptionLike model.choicePart Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  unclear = element unclear { attlist.unclear, content.unclear }
  [
    xml:id = "content.unclear"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.unclear" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.unclear =
      (text
       | model.textphraseLike
       | model.layerPart
       | model.noteModifierLike)*
  }
  [
    xml:id = "attlist.unclear"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.unclear" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.unclear &=
      att.common,
      att.edit,
      att.facsimile,
      attribute agent { text }?,
      attribute hand { xsd:IDREF }?,
      attribute reason { text }?
  }
}
[
  xml:id = "handshift"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "handshift" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Marks the beginning of a passage written in a new hand, or of a change in\x{a}" ~
        "          the scribe, writing style, ink or character of the document hand. The character\x{a}" ~
        "          attribute describes characteristics of the hand, particularly those related to\x{a}" ~
        "          the quality of the writing, e.g., 'shaky', 'thick', regular'. A description of\x{a}" ~
        "          the tint or type of ink, e.g. 'brown' or the writing medium, e.g. 'pencil', may\x{a}" ~
        "          be placed in the medium attribute. The new hand may be identified using the new\x{a}" ~
        "          attribute, while the previous hand may be recorded in the old attribute. The\x{a}" ~
        "          resp attribute contains an ID reference to an element containing the name of the\x{a}" ~
        "          editor or transcriber responsible for identifying the change of hand. Used by:\x{a}" ~
        "          model.editLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  handshift = element handshift { attlist.handshift, content.handshift }
  [
    xml:id = "content.handshift"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.handshift" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.handshift = empty
  }
  [
    xml:id = "attlist.handshift"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.handshift" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.handshift &=
      att.common,
      att.edit,
      att.facsimile,
      attribute character { text }?,
      attribute medium { text }?,
      attribute new { xsd:IDREF }?,
      attribute old { xsd:IDREF }?
  }
}
[
  xml:id = "gap"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "gap" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Indicates a point where material has been omitted in a transcription,\x{a}" ~
        "          whether as part of sampling practice or for editorial reasons described in the\x{a}" ~
        "          MEI header. When material is omitted because it is illegible or inaudible,\x{a}" ~
        "          <unclear> should be used instead. Similarly, use\x{a}" ~
        "          <damage> if the omission is due to damage and <del>\x{a}" ~
        "          if the omission is because the material is marked as deleted, or otherwise\x{a}" ~
        "          indicated as superfluous or spurious in the copy text by an author, scribe,\x{a}" ~
        "          annotator, or corrector. An indication of how much material has been omitted\x{a}" ~
        "          from the transcription may be recorded in the extent attribute. The unit\x{a}" ~
        "          attribute names the unit used for describing the extent of the gap. The reason\x{a}" ~
        "          attribute gives the reason for omission. Sample values include 'sampling',\x{a}" ~
        "          'irrelevant', 'cancelled'. The resp attribute contains an ID reference to an\x{a}" ~
        "          element containing the name of the editor, transcriber or encoder responsible\x{a}" ~
        "          for the decision not to provide any transcription of the material and hence the\x{a}" ~
        "          application of the <gap> tag. Used by: model.editLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  gap = element gap { attlist.gap, content.gap }
  [
    xml:id = "content.gap"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.gap" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.gap = empty
  }
  [
    xml:id = "attlist.gap"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.gap" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.gap &=
      att.common,
      att.edit,
      attribute extent { text }?,
      attribute hand { xsd:IDREF }?,
      attribute reason { text }?,
      attribute unit { text }?
  }
}
[
  xml:id = "nota"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "nota" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A single pitched event in the mensural repertoire. The nota element is\x{a}" ~
        "          allowed to contain other events for situations where a single written note may\x{a}" ~
        "          be representative of a group of performed notes. The accid and artic\x{a}" ~
        "          sub-elements may be used instead of the note element's attributes when accid and\x{a}" ~
        "          artic represent first-class objects, e.g. when they require attributes, such as\x{a}" ~
        "          x and y location attributes. Similarly, the syl sub-element may be used instead\x{a}" ~
        "          of the syl attribute. The verse sub-element may be used to group text syllables\x{a}" ~
        "          by verse. Used by: model.eventLike.mensural Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  nota = element nota { attlist.nota, content.nota }
  [
    xml:id = "content.nota"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.nota" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.nota =
      (model.eventLike
       | model.notaModifierLike
       | model.apparatusLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.nota"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.nota" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.nota &=
      att.common,
      att.facsimile,
      att.log.nota,
      att.vis.nota,
      att.ges.nota,
      att.anl.nota
  }
}
[
  xml:id = "pausa"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "pausa" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A rest in the mensural repertoire. Used by: model.eventLike.mensural\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  pausa = element pausa { attlist.pausa, content.pausa }
  [
    xml:id = "content.pausa"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.pausa" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.pausa = empty
  }
  [
    xml:id = "attlist.pausa"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.pausa" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.pausa &=
      att.common,
      att.facsimile,
      att.log.pausa,
      att.vis.pausa,
      att.ges.pausa,
      att.anl.pausa
  }
}
[
  xml:id = "ineume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "ineume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The interrupted neume element is provided for the encoding of neume\x{a}" ~
        "          notation. It is only available when the meiNeumes entity has been set to\x{a}" ~
        "          INCLUDE. Used by: model.eventLike.neume Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  ineume = element ineume { attlist.ineume, content.ineume }
  [
    xml:id = "content.ineume"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.ineume" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.ineume =
      (model.eventLike
       | model.neumeModifierLike
       | model.apparatusLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.ineume"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.ineume" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.ineume &=
      att.common,
      att.facsimile,
      att.typed,
      att.log.ineume,
      att.vis.ineume,
      att.ges.ineume,
      att.anl.ineume
  }
}
[
  xml:id = "uneume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "uneume" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "A single, uninterrupted neume sign. While ineume is allowed here as part\x{a}" ~
        "          of the model.events class, it is unlikely that an uninterrupted neume containing\x{a}" ~
        "          an interrupted neume is a meaningful construct. Used by: model.eventLike.neume\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  uneume = element uneume { attlist.uneume, content.uneume }
  [
    xml:id = "content.uneume"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.uneume" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.uneume =
      (model.eventLike
       | model.neumeModifierLike
       | model.apparatusLike
       | model.editLike
       | model.transcriptionLike)*
  }
  [
    xml:id = "attlist.uneume"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.uneume" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.uneume &=
      att.common,
      att.facsimile,
      att.typed,
      att.log.uneume,
      att.vis.uneume,
      att.ges.uneume,
      att.anl.uneume
  }
}
[
  xml:id = "syllable"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "syllable" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The syllable element is used only for neume notation. Most neume notation\x{a}" ~
        '          can be thought of as "neumed text". Used by: model.eventLike.neume\x{a}' ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  syllable = element syllable { attlist.syllable, content.syllable }
  [
    xml:id = "content.syllable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.syllable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.syllable =
      ((model.eventLike
        | syl
        | model.apparatusLike
        | model.editLike
        | model.transcriptionLike),
       model.milestoneLike.music?)*
  }
  [
    xml:id = "attlist.syllable"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.syllable" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.syllable &= att.common
  }
}
[
  xml:id = "app"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "app" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "An app (apparatus) element contains one or more alternative encodings.\x{a}" ~
        "          The alternatives may be thought of as exclusive or as parallel. The type\x{a}" ~
        "          attribute may contain any convenient descriptive word, describing the extent of\x{a}" ~
        "          the variation (e.g. note, phrase, measure, etc.), its text-critical significance\x{a}" ~
        "          (e.g. significant, accidental, unclear), or the nature of the variation or the\x{a}" ~
        "          principles required to understand it (e.g. lectio difficilior, usus auctoris,\x{a}" ~
        "          etc.) Used by: model.apparatusLike Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  app = element app { attlist.app, content.app }
  [
    xml:id = "content.app"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.app" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.app = rdg, rdg*
  }
  [
    xml:id = "attlist.app"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.app" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.app &= att.common, att.typed
  }
}
[
  xml:id = "rdg"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "rdg" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Reading. Since a reading can be a multi-measure section, the scoredef\x{a}" ~
        "          element is allowed so that a reading may have its own meta- data without the\x{a}" ~
        "          overhead of child sections. The measure sub-element is declared in the meiBase\x{a}" ~
        "          DTD and the pb sub-element is declared in the meiShared DTD. The app sub-element\x{a}" ~
        "          is permitted in order to allow nested sub-variants. Used by: app\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  rdg = element rdg { attlist.rdg, content.rdg }
  [
    xml:id = "content.rdg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.rdg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.rdg = model.rdgPart*
  }
  [
    xml:id = "attlist.rdg"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.rdg" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.rdg &=
      att.common,
      att.crit,
      att.typed,
      att.link.common,
      att.link.external,
      att.link.internal,
      att.anl.rdg,
      att.ges.rdg,
      att.log.rdg,
      att.vis.rdg
  }
}
[
  xml:id = "facsimile"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "facsimile" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "Facsimile contains a representation of some written source in the form of\x{a}" ~
        "          a set of images rather than as transcribed or encoded text. The source attribute\x{a}" ~
        "          may be used to link the collection of images with a particular source. The\x{a}" ~
        "          graphic element is declared in meiShared.dtd. Used by: model.facsimileLike\x{a}" ~
        "          Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  facsimile = element facsimile { attlist.facsimile, content.facsimile }
  [
    xml:id = "content.facsimile"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.facsimile" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.facsimile = (model.graphicLike | surface)*
  }
  [
    xml:id = "attlist.facsimile"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.facsimile" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.facsimile &=
      att.common,
      attribute source { xsd:IDREF }?
  }
}
[
  xml:id = "surface"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "surface" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The surface element defines a written surface in terms of a rectangular\x{a}" ~
        "          coordinate space, optionally grouping one or more graphic representations of\x{a}" ~
        "          that space, and rectangular zones of interest within it. The desc element is\x{a}" ~
        "          declared in meiShared.dtd. Used by: zone Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  surface = element surface { attlist.surface, content.surface }
  [
    xml:id = "content.surface"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.surface" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.surface = figdesc*, model.graphicLike*, zone*
  }
  [
    xml:id = "attlist.surface"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.surface" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.surface &=
      att.common,
      att.coordinated,
      attribute start { xsd:IDREF }?
  }
}
[
  xml:id = "zone"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "zone" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The zone element defines a rectangular area contained within a surface\x{a}" ~
        "          element. Used by: surface Module:"
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  zone = element zone { attlist.zone, content.zone }
  [
    xml:id = "content.zone"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "content.zone" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    content.zone = figdesc*, model.graphicLike*
  }
  [
    xml:id = "attlist.zone"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.zone" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.zone &= att.common, att.coordinated
  }
}
[
  xml:id = "mei"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "mei" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The names of the potential document elements, i.e., mei, meicorpus,\x{a}" ~
        "          meihead, and music, should not be changed in order to assure an absolute minimum\x{a}" ~
        "          level of MEI compliance. The version attribute contains the version of the DTD\x{a}" ~
        "          used by the instance. The document element for a single document contains a\x{a}" ~
        "          header and data."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  mei = element mei { attlist.mei, meihead, music }
  [
    xml:id = "attlist.mei"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.mei" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.mei &=
      attribute id { xsd:ID }?,
      [ a:defaultValue = "1.9b" ]
      attribute version { xsd:NMTOKEN "1.9b" }?
  }
}
[
  xml:id = "meicorpus"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "meicorpus" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The document element for a group of documents, each with its own complete\x{a}" ~
        "          header, contains a header for the group, and one or more mei elements."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  meicorpus = element meicorpus { attlist.meicorpus, meihead, mei+ }
  [
    xml:id = "attlist.meicorpus"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.meicorpus" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.meicorpus &=
      attribute id { xsd:ID }?,
      [ a:defaultValue = "1.9b" ]
      attribute version { xsd:NMTOKEN "1.9b" }?
  }
}
[
  xml:id = "meihead"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "meihead" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "The meihead element contains general information about the encoded file.\x{a}" ~
        "          The sourcedesc element is required where the MEI file is a transcription of\x{a}" ~
        "          existing music. In the case where the data is originally created in MEI form,\x{a}" ~
        "          the sourcedesc element is not required."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  meihead =
    element meihead {
      attlist.meihead,
      altmeiid*,
      filedesc,
      model.headerPart,
      revisiondesc?
    }
  [
    xml:id = "attlist.meihead"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.meihead" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.meihead &=
      att.bibl,
      att.common,
      att.lang,
      attribute type { "music" | "corpus" }?,
      [ a:defaultValue = "1.9b" ]
      attribute version { xsd:NMTOKEN "1.9b" }?
  }
}
[
  xml:id = "music"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "music" ]
    "\x{a}" ~
    "      "
    xhtml:div [
      class = "desc"
      "\x{a}" ~
      "        "
      xhtml:p [
        "This element is a container for everything else in the document besides\x{a}" ~
        "          the header. The front and back elements are declared in the meiText\x{a}" ~
        "          DTD."
      ]
      "\x{a}" ~
      "      "
    ]
    "\x{a}" ~
    "    "
  ]
]
div {
  music =
    element music {
      attlist.music,
      model.facsimileLike*,
      front?,
      (body | group)?,
      back?
    }
  [
    xml:id = "attlist.music"
    xhtml:div [
      "\x{a}" ~
      "        "
      xhtml:h1 [ class = "name" "attlist.music" ]
      "\x{a}" ~
      "        "
      xhtml:div [ class = "desc" ]
      "\x{a}" ~
      "      "
    ]
  ]
  div {
    attlist.music &=
      att.common,
      [ a:defaultValue = "1.9b" ]
      attribute version { xsd:NMTOKEN "1.9b" }?
  }
}
[
  xml:id = "_DUMMYmodel.controleventLike.mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "_DUMMYmodel.controleventLike.mensural" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  _DUMMYmodel.controleventLike.mensural |= notAllowed
}
[
  xml:id = "_DUMMYmodel.controleventLike.mensural-cmn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [
      class = "name"
      "_DUMMYmodel.controleventLike.mensural-cmn"
    ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  _DUMMYmodel.controleventLike.mensural-cmn |= notAllowed
}
[
  xml:id = "_DUMMYmodel.controleventLike.neume"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "_DUMMYmodel.controleventLike.neume" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  _DUMMYmodel.controleventLike.neume |= notAllowed
}
[
  xml:id = "_DUMMYmodel.controleventLike.neume-mensural"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [
      class = "name"
      "_DUMMYmodel.controleventLike.neume-mensural"
    ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  _DUMMYmodel.controleventLike.neume-mensural |= notAllowed
}
[
  xml:id = "_DUMMYmodel.eventLike.neume-cmn"
  xhtml:div [
    "\x{a}" ~
    "      "
    xhtml:h1 [ class = "name" "_DUMMYmodel.eventLike.neume-cmn" ]
    "\x{a}" ~
    "      "
    xhtml:div [ class = "desc" ]
    "\x{a}" ~
    "    "
  ]
]
div {
  _DUMMYmodel.eventLike.neume-cmn |= notAllowed
}
start = mei | meihead | meicorpus | music
