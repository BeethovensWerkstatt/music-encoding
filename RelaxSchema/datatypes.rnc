namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

# This file contains definitions of datatypes.  It should be substituted
# for the definitions created by Trang from mei19-all-test.dtd.

# A beat location, i.e., [0-9]+(\.?[0-9]*)? The value must fall
# between 0 and the numerator of the time signature + 1, where 0
# represents the left barline and the upper bound represents the right
# barline.  For example, in 12/8 the value must be in the range from 0 to
# 13.
data.BEAT = xsd:decimal { minInclusive = "0" }
# EITHER a hexadecimal color value, ie., x[0-9A-Fa-f]{6,6} OR a
# descriptive word, i.e., aqua, black, blue, fuchsia, gray, green, lime,
# maroon, navy, olive, purple, red, silver, teal, white, or yellow, for
# colors defined by the HTML 4.01 specification.
data.COLOR =
  xsd:token {
    pattern =
      "(x[0-9A-Fa-f]{6,6})|\x{a}" ~
      "        (aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow)"
  }
# 360th-unit measure of a cirle's circumference; optionally signed
# decimal number, i.e., [+-]?[0-9]+(\.?[0-9]*)?
data.DEGREES = xsd:decimal
# unsigned positive integer values including '0', i.e., [0-9]+
data.INTEGERNONNEGATIVE = xsd:nonNegativeInteger
# unsigned positive integer values excluding '0', i.e., 1 to
# infinity.
data.INTEGERPOSITIVE = xsd:positiveInteger
# ISO date format: YYYYMMDD
data.ISODATE = xsd:date
#  ISO 24-hour time format: HH:MM:SS.ss, i.e.,
# [0-9][0-9]:[0-9][0-9]:[0-9][0-9](\.?[0-9]*)?
data.ISOTIME = xsd:time
# A duration expressed as a count of measures plus a beat location,
# i.e., [0-9]+m *\+ *[0-9]+(\.?[0-9]*)?, e.g., dur="1m + 3.5" indicates a
# duration of 1 measure plus 3 and one half beats or, in other words, on
# the 2nd half of the 3rd beat of the next measure. The measure number
# must be in the range of 0 to the number of remaining measures and the
# beat number must be in the range from 0 to the numerator of the time
# signature plus 1.  For example, for an event starting in the first
# measure of a piece containing 6 measures in 6/8, the measure number must
# be between 0 to 5 and the beat number must be within the range from 0 to
# 7, e.g., "4m+3".
data.MEASUREBEAT =
  xsd:token { pattern = "([0-9]+m *\+ *)?[0-9]+(\.?[0-9]*)?" }
# MIDI quarter notes per minute: positive integer in the range
# 10-1000
data.MIDITEMPO =
  xsd:positiveInteger { minInclusive = "10" maxInclusive = "1000" }
# optionally signed decimal number, i.e., [+-]?[0-9]+(\.?[0-9]*)?
data.NUMBER = xsd:decimal
# unsigned positive decimal values excluding '0', i.e., 1 to
# infinity.
data.NUMBERPOSITIVE = xsd:decimal { minInclusive = "1" }
# positive decimal number plus '%', i.e., [0-9]+(\.?[0-9]*)?\%
data.PERCENT = xsd:token { pattern = "[0-9]+(\.?[0-9]*)?%" }
#  a ratio, i.e., [0-9]+(\.?[0-9]*)?:[0-9]+(\.?[0-9]*)?  For example,
# "40:7.2319"
data.RATIO =
  xsd:token { pattern = "[0-9]+(\.?[0-9]*)?:[0-9]+(\.?[0-9]*)?" }
# In string tablature, the number of the string to be played, i.e.,
# [1-9]+.
data.STRINGNUMBER = xsd:positiveInteger
# Beats (meter signature denominator) per minute, e.g. 120.
data.TEMPOVALUE = xsd:positiveInteger
# A positive or negative offset from the value given in the tstamp
# attribute. The datatype of this attribute must be the same as that of
# the tstamp, tstamp.ges, or tstamp.real attribute.
data.TSTAMPOFFSET = text
# a Uniform Resource Identifier, see [RFC2396]
data.URI = xsd:anyURI
# Accidental attribute values: s = sharp, f = flat, ss = dblsharp,
# x=dblsharp, ff = dblflat, n = natural, nf = naturalflat, ns =
# naturalsharp. ss indicates the use of 2 sharp signs, while x indicates
# the use of a single double sharp. nf and ns are used to cancel dbflats
# and dblsharps, respectively. su = sharp note qtr. tone up, sd = sharp
# note qtr. tone down, fu = flat note qtr. tone up, fd = flat note qtr.
# tone down, nu = natural note qtr. tone up, nd = natural note quarter
# tone down. Quarter-tone accidentals listed in Read, p. 145.
data.ACCIDENTAL.EXPLICIT =
  "s"
  | "f"
  | "ss"
  | "x"
  | "ff"
  | "n"
  | "nf"
  | "ns"
  | "su"
  | "sd"
  | "fu"
  | "fd"
  | "nu"
  | "nd"
data.ACCIDENTAL.IMPLICIT = "s" | "f" | "ss" | "ff" | "n"
# The following list of articulations mostly corresponds to symbols
# 1D110-1D111, 1D17B-1D182, 1D185-1D189, 1D1AA-1D1AD, 1D1B3-1D1B5 from
# the Western Musical Symbols portion of the Unicode Standard, v. 3.1.
# The dot and stroke values may be used in cases where interpretation is
# not desirable.
data.ARTICULATION =
  "acc"
  | "stacc"
  | "ten"
  | "stacciss"
  | "marc"
  | "marc-stacc"
  | "acc-marc"
  | "loure"
  | "spicc"
  | "rip"
  | "doit"
  | "plop"
  | "fall"
  | "bend"
  | "flip"
  | "smear"
  | "dnbow"
  | "upbow"
  | "harm"
  | "snap"
  | "fingernail"
  | "damp"
  | "dampall"
  | "open"
  | "stop"
  | "dbltongue"
  | "trpltongue"
  | "heel"
  | "toe"
  | "tap"
  | "pluck"
  | "dot"
  | "stroke"
# 1 or more from the list given in the definition of the
# ARTICULATION entity. Changing this to CDATA, however, would allow the
# use of character entities.
data.ARTICULATIONS = list { data.ARTICULATION* }
# Dots attribute values (number of augmentation dots) (Read,
# 113-119, ex. 8-21)
data.AUGMENTDOT = xsd:nonNegativeInteger { maxInclusive = "4" }
# Placement of barlines: 'mensur' = between staves only, 'staff'
# = between and across staves as necessary, 'takt' = short line
# above staff or through top line
data.BARPLACE = "mensur" | "staff" | "takt"
# Renderings of barlines
data.BARRENDITION =
  "dashed"
  | "dotted"
  | "dbl"
  | "dbldashed"
  | "dbldotted"
  | "end"
  | "invis"
  | "rptstart"
  | "rptboth"
  | "rptend"
  | "single"
# Beam attribute values: initial, medial, terminal. Nested beaming
# is permitted.
data.BEAM = xsd:token { pattern = "[i|m|t][1-6]" }
# 1 or more from the list given in the definition of the BEAM entity.
data.BEAMS = list { data.BEAM+ }
# Boolean attribute values
data.BOOLEAN = "true" | "false"
# Values for certainty attribute
data.CERTAINTY = "high" | "medium" | "low" | "unknown"
# Clef line attribute values
data.CLEFLINE = data.INTEGERPOSITIVE
#   1 or more from the list given in the definition of the CLEFLINE
#   entity.
# <define name="data.CLEFLINES">
#   <list>
#     <oneOrMore>
#       <ref name="data.CLEFLINE"/>
#     </oneOrMore>
#   </list>
# </define>

# Clef shape attribute values (Read, p.53-56)
data.CLEFSHAPE = "G" | "GG" | "F" | "C" | "perc" | "TAB"
#   1 or more from the list given in the definition of the CLEFSHAPE
#   entity. Changing this to CDATA would allow the use of character
#   entities.
# <define name="data.CLEFSHAPES">
#   <list>
#     <oneOrMore>
#       <ref name="data.CLEFSHAPE"/>
#     </oneOrMore>
#   </list>
# </define>

# Clef trans attribute values
data.CLEFTRAN = "8va" | "8vb" | "15va"
# Tone-clusters
data.CLUSTER = "whbox" | "blbox"
# Renderings of curves
data.CURVERENDITION = "medium" | "wide" | "dashed" | "dotted"
# Logical, that is, written, duration attribute values. Whole note
# duration = '1'.
data.DURATION.BASE =
  "long"
  | "breve"
  | "1"
  | "2"
  | "4"
  | "8"
  | "16"
  | "32"
  | "64"
  | "128"
  | "256"
  | "512"
  | "1024"
  | "2048"
data.DURATION.MEN =
  "maxima"
  | "longa"
  | "brevis"
  | "semibrevis"
  | "minima"
  | "semiminima"
  | "fusa"
  | "semifusa"
data.DURATION = data.DURATION.BASE
data.DURATION.MENSURAL = data.DURATION.MEN
data.DURATIONS = data.DURATION.BASE | data.DURATION.MEN
# Enclosures for editorial notes and accidentals
data.ENCLOSURE = "paren" | "brack"
# Font family (for text) attribute values
# Mup-acceptable values: <!ENTITY % FONTFAMILY
#                      '(avantgarde|bookman|courier|helvetica|
#                      newcentury|palatino|times)'>
data.FONTFAMILY = xsd:token
# Font name (for text) attribute values
# Mup-acceptable values: <!ENTITY % FONTNAME  '(rom|ital|bold|boldital)'>
data.FONTNAME = xsd:token
# Font style (for text) attribute values
data.FONTSTYLE = "ital" | "normal"
# Font weight (for text) attribute values
data.FONTWEIGHT = "bold"
# Fragment referencing method.  Setting this entity to '%data.XPATH;' or
# '%data.XPOINTER;' makes it possible to document the use of these methods.
data.XPATH = xsd:token
data.XPOINTER = xsd:token
data.FRAGMENT = data.XPATH | data.XPOINTER
# In string tablature, the fret number, i.e., [0-9]+. The value '0'
# indicates the open string.
data.FRETNUMBER = xsd:nonNegativeInteger { maxInclusive = "9" }
# Analytical glissando attribute values: i(nitial), m(edial),
# t(erminal)
data.GLISSANDO = "i" | "m" | "t"
# Do grace notes get time from the current (acc) or previous (unacc)
# one?
data.GRACE = "acc" | "unacc"
# Allowed notehead shapes
data.HEADSHAPE =
  "quarter"
  | "half"
  | "whole"
  | "dblwhole"
  | "filldiamond"
  | "diamond"
  | "dwdiamond"
  | "fillisotriangle"
  | "isotriangle"
  | "dwhisotriangle"
  | "fillpiewedge"
  | "piewedge"
  | "dwhpiewedge"
  | "fillrectangle"
  | "rectangle"
  | "dwhrectangle"
  | "fillrtriangle"
  | "rtriangle"
  | "dwrtriangle"
  | "fillurtriangle"
  | "urtriangle"
  | "dwurtriangle"
  | "fillsemicircle"
  | "semicircle"
  | "dwsemicircle"
  | "fillslash"
  | "slash"
  | "dwslash"
  | "x"
  | "blank"
  | "circlex"
  | "cross"
# Interrupted neume, i.e. neumes written as 2 or more sub-neumes
data.INEUMENAME =
  "pessubpunctis"
  | "climacus"
  | "scandicus"
  | "bistropha"
  | "tristropha"
  | "pressusminor"
  | "pressusmaior"
  | "pressusliquescens"
  | "virgastrata"
# Interrupted neume forms
data.INEUMEFORM =
  "liquescent1"
  | "liquescent2"
  | "tied"
  | "tiedliquescent1"
  | "tiedliquescent2"
data.KEYSIGTOKEN =
  xsd:token {
    pattern = "[a-g][s|f|ss|x|ff|n|nf|ns|su|sd|fu|fd|nu|nd][0-9]"
  }
# Key signature is normally indicated by a value showing where the
# key is in the circle of fifths. Mixed key signatures, e.g. those
# consisting of a mixture of flats and sharps, and key signatures with
# unorthodox placement of the accidentals (Read, p. 143) must be
# indicated by setting the key.sig attribute to 'mixed' and providing
# explicit keysig info in the key.sig.mixed attribute.
data.KEYSIGNATURE = xsd:token { pattern = "mixed|0|[1-7][f|s]" }
# Indicates how stems should be drawn when more than one layer is
# present and stem directions are not indicated on the notes/chords
# themselves. '1' indicates that there is only a single layer on a staff.
# '2o' means there are two layers with opposing stems. '2f' indicates
# two 'free' layers; that is, opposing stems will be drawn unless one of
# the layers has 'space'. In that case, stem direction in the remaining
# layer will be determined as if there were only one layer. '3o' and
# '3f' are analogous to '2o' and '2f' with three layers allowed. What
# about more than 3 layers?
data.LAYERSCHEME = "1" | "2o" | "2f" | "3o" | "3f"
# Ligature forms
data.LIGATUREFORM = "recta" | "obliqua"
# Renderings of lines
data.LINERENDITION =
  "narrow" | "medium" | "wide" | "dashed" | "dotted" | "wavy"
# Mensuration attribute values
data.MENSURATIONSIGN = "C" | "O"
# Meter.sym attribute values for common-practice notation
data.METERSIGN = "common" | "cut"
# MIDI channel numbers
data.MIDICHANNEL = xsd:positiveInteger { maxInclusive = "16" }
# MIDI values are in the following range
data.MIDIVALUE = xsd:nonNegativeInteger { maxInclusive = "127" }
# Modes
data.MODE =
  "major"
  | "minor"
  | "dorian"
  | "phrygian"
  | "lydian"
  | "mixolydian"
  | "aeolian"
  | "locrian"
# Music font family
data.MUSICFONT = xsd:token
# Oct attribute values. The default values conform to Acoustical
# Society of America representation. Read, p. 44. The entity name is
# plural so as not to conflict with the %octave entity used in the
# definition of the octave element.
data.OCTAVE = xsd:nonNegativeInteger { maxInclusive = "9" }
# Page scale factor datatype.  Setting this to %data.RATIO; allows
# page.scale attributes to contain a virtual units to real units conversion
# ratio.
data.PGSCALE = data.PERCENT | data.RATIO
# Values for unit attribute
data.PGUNITS = "in" | "cm" | "mm"
# Pclass (pitch class) attribute values
data.PITCHCLASS = xsd:nonNegativeInteger { maxInclusive = "11" }
# The pitch names (gamut) used within a single octave. The default
# values conform to Acoustical Society of America representation.
data.PITCHNAME = xsd:token { pattern = "[a-g]" }
# Gestural pitch names need an additional value for when the notated
# pitch is not to be played.
data.PITCHNAME.GES = xsd:token { pattern = "[a-g]|none" }
# Pnum (pitch number, e.g. MIDI) attribute values
data.PITCHNUMBER = data.INTEGERNONNEGATIVE
# Participant list referencing method.  Setting this entity to '%data.XPATH;'
# or '%data.XPOINTER;' makes it possible to document the use of these methods.
data.PLIST =
  xsd:IDREFS
  # <choice>
  #   <data type="IDREFS"/>
  #   <ref name="data.XPATH"/>
  #   <ref name="data.XPOINTER"/>
  # </choice>
  
# Place, i.e., relative location of musical material
data.PLACE = "above" | "below"
# Size attribute values
data.SIZE = "normal" | "cue"
# i=initial, t=terminal. Number is used to match endpoints of the
# slur when slurs are nested or overlap, e.g. 
# <note slur='i1 i2'/><note slur='t1'/><note slur='t2'/> encodes the
# fact that two slurs begin on note 1, one which terminates on note 2
# and one which terminates on note 3. % SLUR isn't currently invoked in
# the DTD; it serves as documentation for the tokens that can be used
# where % SLURS is invoked.
data.SLUR = xsd:token { pattern = "[i|m|t][1-6]" }
# 1 or more from the list given in the definition of the SLUR
# entity.
data.SLURS = list { data.SLUR+ }
# Slur direction
data.SLURDIRECTION = "up" | "down"
# Staff location. Staff location includes staff lines, spaces, and
# the spaces directly above and below the staff. The value ranges between
# 0 (just below the staff) to 2 * number of staff lines (directly above
# the staff).  For example, on a 5-line staff the lines would be numbered
# 1,3,5,7, and 9 while the spaces would be numbered 0,2,4,6,8,10.
data.STAFFLOC = data.INTEGERNONNEGATIVE
# Stem direction
data.STEMDIRECTION = "up" | "down"
# Stem modification
data.STEMMODIFIER =
  "1slash"
  | "2slash"
  | "3slash"
  | "4slash"
  | "5slash"
  | "6slash"
  | "sprech"
  | "z"
# Which side of stem?
data.STEMPOSITION = "left" | "right" | "center"
# Temperament
data.TEMPERAMENT = "equal" | "just" | "mean"
# Text renditions
data.TEXTRENDITION =
  "box"
  | "circle"
  | "dblunderline"
  | "none"
  | "quoted"
  | "smcaps"
  | "strike"
  | "sub"
  | "sup"
  | "underline"
# Tie attribute values: initial, medial, terminal
data.TIE = xsd:token { pattern = "[i|m|t]" }
# Tie direction
data.TIEDIRECTION = "up" | "down"
# Tuplet attribute values: initial, medial, terminal
data.TUPLET = xsd:token { pattern = "[i|m|t][1-6]" }
# Basic, i.e., single, uninterrupted, neume names
data.UNEUMENAME =
  "punctum"
  | "virga"
  | "pes"
  | "clivis"
  | "torculus"
  | "torculusresupinus"
  | "porrectus"
  | "porrectusflexus"
  | "apostropha"
  | "oriscus"
data.UNEUMEFORM =
  "liquescent1"
  | "liquescent2"
  | "liquescent3"
  | "quilismatic"
  | "rectangular"
  | "rhombic"
  | "tied"
# Visual, i.e. ho and vo, offsets are expressed in terms of staff
# interline distance; that is, in "stepsizes", which are half the
# distance between staff lines.
data.VISUALOFFSET = data.NUMBER
